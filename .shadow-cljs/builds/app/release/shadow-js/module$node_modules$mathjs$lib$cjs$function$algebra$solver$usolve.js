["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/solver/usolve.js"],"~:js","shadow$provide[174]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createUsolve=void 0;c=b(25);var q=b(172);b=(0,c.factory)(\"usolve\",\"typed matrix divideScalar multiplyScalar subtract equalScalar DenseMatrix\".split(\" \"),function(f){function u(r,v){v=n(r,v,!0);v=v._data;var C=r._size[0],z=[],w=r._data;for(r=r._size[1]-1;0<=r;r--){var B=v[r][0]||0;if(l(B,0))B=0;else{var x=w[r][r];if(l(x,0))throw Error(\"Linear system cannot be solved since matrix is singular\");B=p(B,x);for(x=r-\n1;0<=x;x--)v[x]=[d(v[x][0]||0,g(B,w[x][r]))]}z[r]=[B]}return new h({data:z,size:[C,1]})}var k=f.typed,t=f.matrix,p=f.divideScalar,g=f.multiplyScalar,d=f.subtract,l=f.equalScalar,h=f.DenseMatrix,n=(0,q.createSolveValidation)({DenseMatrix:h});return k(\"usolve\",{\"SparseMatrix, Array | Matrix\":function(r,v){v=n(r,v,!0);v=v._data;var C=r._size[0],z=r._values,w=r._index,B=r._ptr,x=[];for(r=r._size[1]-1;0<=r;r--){var D=v[r][0]||0;if(l(D,0))x[r]=[0];else{for(var F=0,E=[],G=[],I=B[r],L=B[r+1]-1;L>=I;L--){var M=\nw[L];M===r?F=z[L]:M<r&&(E.push(z[L]),G.push(M))}if(l(F,0))throw Error(\"Linear system cannot be solved since matrix is singular\");D=p(D,F);F=0;for(I=G.length;F<I;F++)L=G[F],v[L]=[d(v[L][0],g(D,E[F]))];x[r]=[D]}}return new h({data:x,size:[C,1]})},\"DenseMatrix, Array | Matrix\":function(r,v){return u(r,v)},\"Array, Array | Matrix\":function(r,v){r=t(r);return u(r,v).valueOf()}})});a.createUsolve=b}","~:source","shadow$provide[174] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUsolve = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar name = 'usolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createUsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [[8], [9]]\n   *\n   * See also:\n   *\n   *    usolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var r = _denseBackwardSubstitution(m, b);\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns backwards\n\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0;\n\n      if (!equalScalar(bj, 0)) {\n        // value at [j, j]\n        var vjj = mdata[j][j];\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // zero value at j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns backwards\n\n    for (var j = columns - 1; j >= 0; j--) {\n      var bj = bdata[j][0] || 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // upper triangular matrix values & index (column j)\n\n        var jValues = [];\n        var jIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards\n\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        var xj = divideScalar(bj, vjj);\n\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\n        }\n\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});\nexports.createUsolve = createUsolve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["DenseMatrix","__esModule","value","size","data","createUsolve"]],"~:compiled-at",1619135723901,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$usolve.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/solver/usolve.js\"],\n\"sourcesContent\":[\"shadow$provide[174] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createUsolve = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _solveValidation = require(\\\"./utils/solveValidation.js\\\");\\n\\nvar name = 'usolve';\\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\\nvar createUsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divideScalar = _ref.divideScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      subtract = _ref.subtract,\\n      equalScalar = _ref.equalScalar,\\n      DenseMatrix = _ref.DenseMatrix;\\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\\n    DenseMatrix: DenseMatrix\\n  });\\n  /**\\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\\n   *\\n   * `U * x = b`\\n   *\\n   * Syntax:\\n   *\\n   *    math.usolve(U, b)\\n   *\\n   * Examples:\\n   *\\n   *    const a = [[-2, 3], [2, 1]]\\n   *    const b = [11, 9]\\n   *    const x = usolve(a, b)  // [[8], [9]]\\n   *\\n   * See also:\\n   *\\n   *    usolveAll, lup, slu, usolve, lusolve\\n   *\\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\\n   * @param {Matrix, Array} b       A column vector with the b values\\n   *\\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\\n   */\\n\\n  return typed(name, {\\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\\n      return _sparseBackwardSubstitution(m, b);\\n    },\\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\\n      return _denseBackwardSubstitution(m, b);\\n    },\\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\\n      var m = matrix(a);\\n\\n      var r = _denseBackwardSubstitution(m, b);\\n\\n      return r.valueOf();\\n    }\\n  });\\n\\n  function _denseBackwardSubstitution(m, b) {\\n    // make b into a column vector\\n    b = solveValidation(m, b, true);\\n    var bdata = b._data;\\n    var rows = m._size[0];\\n    var columns = m._size[1]; // result\\n\\n    var x = [];\\n    var mdata = m._data; // loop columns backwards\\n\\n    for (var j = columns - 1; j >= 0; j--) {\\n      // b[j]\\n      var bj = bdata[j][0] || 0; // x[j]\\n\\n      var xj = void 0;\\n\\n      if (!equalScalar(bj, 0)) {\\n        // value at [j, j]\\n        var vjj = mdata[j][j];\\n\\n        if (equalScalar(vjj, 0)) {\\n          // system cannot be solved\\n          throw new Error('Linear system cannot be solved since matrix is singular');\\n        }\\n\\n        xj = divideScalar(bj, vjj); // loop rows\\n\\n        for (var i = j - 1; i >= 0; i--) {\\n          // update copy of b\\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\\n        }\\n      } else {\\n        // zero value at j\\n        xj = 0;\\n      } // update x\\n\\n\\n      x[j] = [xj];\\n    }\\n\\n    return new DenseMatrix({\\n      data: x,\\n      size: [rows, 1]\\n    });\\n  }\\n\\n  function _sparseBackwardSubstitution(m, b) {\\n    // make b into a column vector\\n    b = solveValidation(m, b, true);\\n    var bdata = b._data;\\n    var rows = m._size[0];\\n    var columns = m._size[1];\\n    var values = m._values;\\n    var index = m._index;\\n    var ptr = m._ptr; // result\\n\\n    var x = []; // loop columns backwards\\n\\n    for (var j = columns - 1; j >= 0; j--) {\\n      var bj = bdata[j][0] || 0;\\n\\n      if (!equalScalar(bj, 0)) {\\n        // non-degenerate row, find solution\\n        var vjj = 0; // upper triangular matrix values & index (column j)\\n\\n        var jValues = [];\\n        var jIndices = []; // first & last indeces in column\\n\\n        var firstIndex = ptr[j];\\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards\\n\\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\\n          var i = index[k]; // check row (rows are not sorted!)\\n\\n          if (i === j) {\\n            vjj = values[k];\\n          } else if (i < j) {\\n            // store upper triangular\\n            jValues.push(values[k]);\\n            jIndices.push(i);\\n          }\\n        } // at this point we must have a value in vjj\\n\\n\\n        if (equalScalar(vjj, 0)) {\\n          throw new Error('Linear system cannot be solved since matrix is singular');\\n        }\\n\\n        var xj = divideScalar(bj, vjj);\\n\\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\\n          var _i = jIndices[_k];\\n          bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\\n        }\\n\\n        x[j] = [xj];\\n      } else {\\n        // degenerate row, we can choose any value\\n        x[j] = [0];\\n      }\\n    }\\n\\n    return new DenseMatrix({\\n      data: x,\\n      size: [rows, 1]\\n    });\\n  }\\n});\\nexports.createUsolve = createUsolve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createUsolve\",\"_factory\",\"_solveValidation\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_denseBackwardSubstitution\",\"m\",\"b\",\"solveValidation\",\"bdata\",\"_data\",\"rows\",\"_size\",\"x\",\"mdata\",\"j\",\"columns\",\"bj\",\"equalScalar\",\"xj\",\"vjj\",\"Error\",\"divideScalar\",\"i\",\"subtract\",\"multiplyScalar\",\"DenseMatrix\",\"data\",\"size\",\"typed\",\"matrix\",\"createSolveValidation\",\"SparseMatrixArrayMatrix\",\"values\",\"_values\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"jValues\",\"jIndices\",\"firstIndex\",\"k\",\"lastIndex\",\"push\",\"_k\",\"_lastIndex\",\"length\",\"_i\",\"DenseMatrixArrayMatrix\",\"ArrayArrayMatrix\",\"a\",\"r\",\"valueOf\"]\n}\n"]