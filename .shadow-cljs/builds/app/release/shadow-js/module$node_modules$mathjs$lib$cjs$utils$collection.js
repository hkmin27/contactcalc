["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/collection.js"],"~:js","shadow$provide[38]=function(c,b,y,a){function q(g,d){(0,k.isMatrix)(g)&&(g=g.valueOf());for(var l=0,h=g.length;l<h;l++){var n=g[l];Array.isArray(n)?q(n,d):d(n)}}function f(g,d,l){return g&&\"function\"===typeof g.map?g.map(function(h){return f(h,d,l)}):d(g)}function u(g,d,l){if(0>=d){if(Array.isArray(g[0])){var h=g.length;var n=g[0].length;var r,v,C=[];for(v=0;v<n;v++){var z=[];for(r=0;r<h;r++)z.push(g[r][v]);C.push(z)}n=[];for(h=0;h<C.length;h++)n[h]=u(C[h],d-1,l);return n}d=g[0];for(h=1;h<g.length;h++)d=\nl(d,g[h]);return d}n=[];for(h=0;h<g.length;h++)n[h]=u(g[h],d-1,l);return n}Object.defineProperty(a,\"__esModule\",{value:!0});a.containsCollections=function(g){for(var d=0;d<g.length;d++)if((0,k.isCollection)(g[d]))return!0;return!1};a.deepForEach=q;a.deepMap=f;a.reduce=function(g,d,l){var h=Array.isArray(g)?(0,p.arraySize)(g):g.size();if(0>d||d>=h.length)throw new t.IndexError(d,h.length);return(0,k.isMatrix)(g)?g.create(u(g.valueOf(),d,l)):u(g,d,l)};a.scatter=function(g,d,l,h,n,r,v,C,z,w,B){var x=\ng._values,D=g._index,F=g._ptr;if(h)for(g=F[d],d=F[d+1];g<d;g++)F=D[g],l[F]!==r?(l[F]=r,v.push(F),w?(h[F]=z?C(x[g],B):C(B,x[g]),n[F]=r):h[F]=x[g]):(h[F]=z?C(x[g],h[F]):C(h[F],x[g]),n[F]=r);else for(g=F[d],d=F[d+1];g<d;g++)F=D[g],l[F]!==r?(l[F]=r,v.push(F)):n[F]=r};var k=b(14),t=b(23),p=b(24)}","~:source","shadow$provide[38] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsCollections = containsCollections;\nexports.deepForEach = deepForEach;\nexports.deepMap = deepMap;\nexports.reduce = reduce;\nexports.scatter = scatter;\n\nvar _is = require(\"./is.js\");\n\nvar _IndexError = require(\"../error/IndexError.js\");\n\nvar _array = require(\"./array.js\");\n\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\nfunction containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if ((0, _is.isCollection)(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\n\nfunction deepForEach(array, callback) {\n  if ((0, _is.isMatrix)(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\n\nfunction deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\n\nfunction reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new _IndexError.IndexError(dim, size.length);\n  }\n\n  if ((0, _is.isMatrix)(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n} // TODO: document function scatter\n\n\nfunction scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$error$IndexError","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array"]],"~:properties",["^5",["__esModule","containsCollections","scatter","deepForEach","value","reduce","deepMap"]],"~:compiled-at",1619135723747,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$collection.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/collection.js\"],\n\"sourcesContent\":[\"shadow$provide[38] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.containsCollections = containsCollections;\\nexports.deepForEach = deepForEach;\\nexports.deepMap = deepMap;\\nexports.reduce = reduce;\\nexports.scatter = scatter;\\n\\nvar _is = require(\\\"./is.js\\\");\\n\\nvar _IndexError = require(\\\"../error/IndexError.js\\\");\\n\\nvar _array = require(\\\"./array.js\\\");\\n\\n/**\\n * Test whether an array contains collections\\n * @param {Array} array\\n * @returns {boolean} Returns true when the array contains one or multiple\\n *                    collections (Arrays or Matrices). Returns false otherwise.\\n */\\nfunction containsCollections(array) {\\n  for (var i = 0; i < array.length; i++) {\\n    if ((0, _is.isCollection)(array[i])) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n/**\\n * Recursively loop over all elements in a given multi dimensional array\\n * and invoke the callback on each of the elements.\\n * @param {Array | Matrix} array\\n * @param {Function} callback     The callback method is invoked with one\\n *                                parameter: the current element in the array\\n */\\n\\n\\nfunction deepForEach(array, callback) {\\n  if ((0, _is.isMatrix)(array)) {\\n    array = array.valueOf();\\n  }\\n\\n  for (var i = 0, ii = array.length; i < ii; i++) {\\n    var value = array[i];\\n\\n    if (Array.isArray(value)) {\\n      deepForEach(value, callback);\\n    } else {\\n      callback(value);\\n    }\\n  }\\n}\\n/**\\n * Execute the callback function element wise for each element in array and any\\n * nested array\\n * Returns an array with the results\\n * @param {Array | Matrix} array\\n * @param {Function} callback   The callback is called with two parameters:\\n *                              value1 and value2, which contain the current\\n *                              element of both arrays.\\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\\n *\\n * @return {Array | Matrix} res\\n */\\n\\n\\nfunction deepMap(array, callback, skipZeros) {\\n  if (array && typeof array.map === 'function') {\\n    // TODO: replace array.map with a for loop to improve performance\\n    return array.map(function (x) {\\n      return deepMap(x, callback, skipZeros);\\n    });\\n  } else {\\n    return callback(array);\\n  }\\n}\\n/**\\n * Reduce a given matrix or array to a new matrix or\\n * array with one less dimension, applying the given\\n * callback in the selected dimension.\\n * @param {Array | Matrix} mat\\n * @param {number} dim\\n * @param {Function} callback\\n * @return {Array | Matrix} res\\n */\\n\\n\\nfunction reduce(mat, dim, callback) {\\n  var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\\n\\n  if (dim < 0 || dim >= size.length) {\\n    // TODO: would be more clear when throwing a DimensionError here\\n    throw new _IndexError.IndexError(dim, size.length);\\n  }\\n\\n  if ((0, _is.isMatrix)(mat)) {\\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\\n  } else {\\n    return _reduce(mat, dim, callback);\\n  }\\n}\\n/**\\n * Recursively reduce a matrix\\n * @param {Array} mat\\n * @param {number} dim\\n * @param {Function} callback\\n * @returns {Array} ret\\n * @private\\n */\\n\\n\\nfunction _reduce(mat, dim, callback) {\\n  var i, ret, val, tran;\\n\\n  if (dim <= 0) {\\n    if (!Array.isArray(mat[0])) {\\n      val = mat[0];\\n\\n      for (i = 1; i < mat.length; i++) {\\n        val = callback(val, mat[i]);\\n      }\\n\\n      return val;\\n    } else {\\n      tran = _switch(mat);\\n      ret = [];\\n\\n      for (i = 0; i < tran.length; i++) {\\n        ret[i] = _reduce(tran[i], dim - 1, callback);\\n      }\\n\\n      return ret;\\n    }\\n  } else {\\n    ret = [];\\n\\n    for (i = 0; i < mat.length; i++) {\\n      ret[i] = _reduce(mat[i], dim - 1, callback);\\n    }\\n\\n    return ret;\\n  }\\n}\\n/**\\n * Transpose a matrix\\n * @param {Array} mat\\n * @returns {Array} ret\\n * @private\\n */\\n\\n\\nfunction _switch(mat) {\\n  var I = mat.length;\\n  var J = mat[0].length;\\n  var i, j;\\n  var ret = [];\\n\\n  for (j = 0; j < J; j++) {\\n    var tmp = [];\\n\\n    for (i = 0; i < I; i++) {\\n      tmp.push(mat[i][j]);\\n    }\\n\\n    ret.push(tmp);\\n  }\\n\\n  return ret;\\n} // TODO: document function scatter\\n\\n\\nfunction scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\\n  // a arrays\\n  var avalues = a._values;\\n  var aindex = a._index;\\n  var aptr = a._ptr; // vars\\n\\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\\n\\n  if (x) {\\n    // values in j\\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\\n      // row\\n      i = aindex[k]; // check value exists in current j\\n\\n      if (w[i] !== mark) {\\n        // i is new entry in j\\n        w[i] = mark; // add i to pattern of C\\n\\n        cindex.push(i); // x(i) = A, check we need to call function this time\\n\\n        if (update) {\\n          // copy value to workspace calling callback function\\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\\n\\n          u[i] = mark;\\n        } else {\\n          // copy value to workspace\\n          x[i] = avalues[k];\\n        }\\n      } else {\\n        // i exists in C already\\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\\n\\n        u[i] = mark;\\n      }\\n    }\\n  } else {\\n    // values in j\\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\\n      // row\\n      i = aindex[k]; // check value exists in current j\\n\\n      if (w[i] !== mark) {\\n        // i is new entry in j\\n        w[i] = mark; // add i to pattern of C\\n\\n        cindex.push(i);\\n      } else {\\n        // indicate function was called on current row\\n        u[i] = mark;\\n      }\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"deepForEach\",\"array\",\"callback\",\"_is\",\"isMatrix\",\"valueOf\",\"i\",\"ii\",\"length\",\"value\",\"Array\",\"isArray\",\"deepMap\",\"skipZeros\",\"map\",\"x\",\"_reduce\",\"mat\",\"dim\",\"I\",\"J\",\"j\",\"ret\",\"tmp\",\"push\",\"val\",\"Object\",\"defineProperty\",\"containsCollections\",\"isCollection\",\"reduce\",\"size\",\"_array\",\"arraySize\",\"_IndexError\",\"IndexError\",\"create\",\"scatter\",\"a\",\"w\",\"u\",\"mark\",\"cindex\",\"f\",\"inverse\",\"update\",\"avalues\",\"_values\",\"aindex\",\"_index\",\"aptr\",\"_ptr\",\"k0\",\"k1\",\"k\"]\n}\n"]