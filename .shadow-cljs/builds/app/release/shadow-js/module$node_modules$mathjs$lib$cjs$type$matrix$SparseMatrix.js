["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/matrix/SparseMatrix.js"],"~:js","shadow$provide[61]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSparseMatrixClass=void 0;var q=b(14),f=b(19),u=b(21),k=b(15),t=b(24);c=b(25);var p=b(22);b=(0,c.factory)(\"SparseMatrix\",[\"typed\",\"equalScalar\",\"Matrix\"],function(g){function d(x,D){if(!(this instanceof d))throw new SyntaxError(\"Constructor must be called with the new operator\");if(D&&!(0,q.isString)(D))throw Error(\"Invalid datatype: \"+D);if((0,q.isMatrix)(x))\"SparseMatrix\"===x.type?(this._values=x._values?\n(0,k.clone)(x._values):void 0,this._index=(0,k.clone)(x._index),this._ptr=(0,k.clone)(x._ptr),this._size=(0,k.clone)(x._size),this._datatype=D||x._datatype):l(this,x.valueOf(),D||x._datatype);else if(x&&(0,q.isArray)(x.index)&&(0,q.isArray)(x.ptr)&&(0,q.isArray)(x.size))this._values=x.values,this._index=x.index,this._ptr=x.ptr,this._size=x.size,this._datatype=D||x.datatype;else if((0,q.isArray)(x))l(this,x,D);else{if(x)throw new TypeError(\"Unsupported type of data (\"+(0,q.typeOf)(x)+\")\");this._values=\n[];this._index=[];this._ptr=[0];this._size=[0,0];this._datatype=D}}function l(x,D,F){x._values=[];x._index=[];x._ptr=[];x._datatype=F;var E=D.length,G=0,I=B,L=0;(0,q.isString)(F)&&(I=w.find(B,[F,F])||B,L=w.convert(0,F));if(0<E){F=0;do{x._ptr.push(x._index.length);for(var M=0;M<E;M++){var S=D[M];(0,q.isArray)(S)?(0===F&&G<S.length&&(G=S.length),F<S.length&&(S=S[F],I(S,L)||(x._values.push(S),x._index.push(M)))):(0===F&&1>G&&(G=1),I(S,L)||(x._values.push(S),x._index.push(M)))}F++}while(F<G)}x._ptr.push(x._index.length);\nx._size=[E,G]}function h(x,D){if(!(0,q.isIndex)(D))throw new TypeError(\"Invalid index\");if(D.isScalar())return x.get(D.min());var F=D.size();if(F.length!==x._size.length)throw new p.DimensionError(F.length,x._size.length);var E,G,I,L=D.min(),M=D.max();var S=0;for(E=x._size.length;S<E;S++)(0,t.validateIndex)(L[S],x._size[S]),(0,t.validateIndex)(M[S],x._size[S]);var P=x._values,R=x._index,ba=x._ptr;E=D.dimension(0);D=D.dimension(1);var Q=[],T=[];E.forEach(function(ha,wa){T[ha]=wa[0];Q[ha]=!0});var Y=\nP?[]:void 0,ca=[],ka=[];D.forEach(function(ha){ka.push(ca.length);G=ba[ha];for(I=ba[ha+1];G<I;G++)S=R[G],!0===Q[S]&&(ca.push(T[S]),Y&&Y.push(P[G]))});ka.push(ca.length);return new d({values:Y,index:ca,ptr:ka,size:F,datatype:x._datatype})}function n(x,D,F,E){if(0===F-D)return F;for(var G=D;G<F;G++)if(E[G]===x)return G;return D}function r(x,D,F,E,G,I,L){G.splice(x,0,E);I.splice(x,0,D);for(x=F+1;x<L.length;x++)L[x]++}function v(x,D,F,E){E=E||0;var G=B,I=0;(0,q.isString)(x._datatype)&&(G=w.find(B,[x._datatype,\nx._datatype])||B,I=w.convert(0,x._datatype),E=w.convert(E,x._datatype));var L=!G(E,I),M=x._size[0];G=x._size[1];var S;if(F>G){for(S=G;S<F;S++)if(x._ptr[S]=x._values.length,L)for(I=0;I<M;I++)x._values.push(E),x._index.push(I);x._ptr[F]=x._values.length}else F<G&&(x._ptr.splice(F+1,G-F),x._values.splice(x._ptr[F],x._values.length),x._index.splice(x._ptr[F],x._index.length));G=F;if(D>M){if(L){var P=0;for(S=0;S<G;S++){x._ptr[S]+=P;L=x._ptr[S+1]+P;var R=0;for(I=M;I<D;I++,R++)x._values.splice(L+R,0,E),\nx._index.splice(L+R,0,I),P++}x._ptr[G]=x._values.length}}else if(D<M){for(S=E=0;S<G;S++)for(x._ptr[S]-=E,M=x._ptr[S+1]-E,L=x._ptr[S];L<M;L++)I=x._index[L],I>D-1&&(x._values.splice(L,1),x._index.splice(L,1),E++);x._ptr[S]=x._values.length}x._size[0]=D;x._size[1]=F;return x}function C(x,D,F,E,G,I,L){var M=[],S=[],P=[],R=B,ba=0;(0,q.isString)(x._datatype)&&(R=w.find(B,[x._datatype,x._datatype])||B,ba=w.convert(0,x._datatype));for(var Q=function(ha,wa,Ia){ha=I(ha,wa,Ia);R(ha,ba)||(M.push(ha),S.push(wa))},\nT=E;T<=G;T++){P.push(M.length);var Y=x._ptr[T],ca=x._ptr[T+1];if(L)for(var ka=Y;ka<ca;ka++)Y=x._index[ka],Y>=D&&Y<=F&&Q(x._values[ka],Y-D,T-E);else{for(ka={};Y<ca;Y++)ka[x._index[Y]]=x._values[Y];for(ca=D;ca<=F;ca++)Q(ca in ka?ka[ca]:0,ca-D,T-E)}}P.push(M.length);return new d({values:M,index:S,ptr:P,size:[F-D+1,G-E+1]})}function z(x,D,F,E,G){var I=E[0];E=E[1];var L=[],M,S;for(M=0;M<I;M++)for(L[M]=[],S=0;S<E;S++)L[M][S]=0;for(S=0;S<E;S++){I=F[S+1];for(var P=F[S];P<I;P++)M=D[P],L[M][S]=x?G?(0,k.clone)(x[P]):\nx[P]:1}return L}var w=g.typed,B=g.equalScalar;d.prototype=new g.Matrix;d.prototype.createSparseMatrix=function(x,D){return new d(x,D)};d.prototype.type=\"SparseMatrix\";d.prototype.isSparseMatrix=!0;d.prototype.getDataType=function(){return(0,t.getArrayDataType)(this._values,q.typeOf)};d.prototype.storage=function(){return\"sparse\"};d.prototype.datatype=function(){return this._datatype};d.prototype.create=function(x,D){return new d(x,D)};d.prototype.density=function(){var x=this._size[0],D=this._size[1];\nreturn 0!==x&&0!==D?this._index.length/(x*D):0};d.prototype.subset=function(x,D,F){if(!this._values)throw Error(\"Cannot invoke subset on a Pattern only matrix\");switch(arguments.length){case 1:return h(this,x);case 2:case 3:var E=D;if(!x||!0!==x.isIndex)throw new TypeError(\"Invalid index\");var G=x.size(),I=x.isScalar();if((0,q.isMatrix)(E)){var L=E.size();E=E.toArray()}else L=(0,t.arraySize)(E);if(I){if(0!==L.length)throw new TypeError(\"Scalar expected\");this.set(x.min(),E,F)}else{if(1!==G.length&&\n2!==G.length)throw new p.DimensionError(G.length,this._size.length,\"\\x3c\");if(L.length<G.length){for(var M=I=0;1===G[I]&&1===L[I];)I++;for(;1===G[I];)M++,I++;E=(0,t.unsqueeze)(E,G.length,M,L)}if(!(0,k.deepStrictEqual)(G,L))throw new p.DimensionError(G,L,\"\\x3e\");G=x.min()[0];I=x.min()[1];M=L[0];L=L[1];for(var S=0;S<M;S++)for(var P=0;P<L;P++)this.set([S+G,P+I],E[S][P],F)}return this;default:throw new SyntaxError(\"Wrong number of arguments\");}};d.prototype.get=function(x){if(!(0,q.isArray)(x))throw new TypeError(\"Array expected\");\nif(x.length!==this._size.length)throw new p.DimensionError(x.length,this._size.length);if(!this._values)throw Error(\"Cannot invoke get on a Pattern only matrix\");var D=x[0];x=x[1];(0,t.validateIndex)(D,this._size[0]);(0,t.validateIndex)(x,this._size[1]);var F=n(D,this._ptr[x],this._ptr[x+1],this._index);return F<this._ptr[x+1]&&this._index[F]===D?this._values[F]:0};d.prototype.set=function(x,D,F){if(!(0,q.isArray)(x))throw new TypeError(\"Array expected\");if(x.length!==this._size.length)throw new p.DimensionError(x.length,\nthis._size.length);if(!this._values)throw Error(\"Cannot invoke set on a Pattern only matrix\");var E=x[0];x=x[1];var G=this._size[0],I=this._size[1],L=B,M=0;(0,q.isString)(this._datatype)&&(L=w.find(B,[this._datatype,this._datatype])||B,M=w.convert(0,this._datatype));if(E>G-1||x>I-1)v(this,Math.max(E+1,G),Math.max(x+1,I),F),G=this._size[0],I=this._size[1];(0,t.validateIndex)(E,G);(0,t.validateIndex)(x,I);F=n(E,this._ptr[x],this._ptr[x+1],this._index);if(F<this._ptr[x+1]&&this._index[F]===E)if(L(D,\nM))for(E=this._index,D=this._ptr,this._values.splice(F,1),E.splice(F,1),x+=1;x<D.length;x++)D[x]--;else this._values[F]=D;else r(F,E,x,D,this._values,this._index,this._ptr);return this};d.prototype.resize=function(x,D,F){if(!(0,q.isCollection)(x))throw new TypeError(\"Array or Matrix expected\");var E=x.valueOf().map(function(G){return Array.isArray(G)&&1===G.length?G[0]:G});if(2!==E.length)throw Error(\"Only two dimensions matrix are supported\");E.forEach(function(G){if(!(0,q.isNumber)(G)||!(0,f.isInteger)(G)||\n0>G)throw new TypeError(\"Invalid size, must contain positive integers (size: \"+(0,u.format)(E)+\")\");});x=F?this.clone():this;return v(x,E[0],E[1],D)};d.prototype.reshape=function(x,D){if(!(0,q.isArray)(x))throw new TypeError(\"Array expected\");if(2!==x.length)throw Error(\"Sparse matrices can only be reshaped in two dimensions\");x.forEach(function(R){if(!(0,q.isNumber)(R)||!(0,f.isInteger)(R)||-2>=R||0===R)throw new TypeError(\"Invalid size, must contain positive integers or -1 (size: \"+(0,u.format)(x)+\n\")\");});var F=this._size[0]*this._size[1];x=(0,t.processSizesWildcard)(x,F);if(F!==x[0]*x[1])throw Error(\"Reshaping sparse matrix will result in the wrong number of elements\");D=D?this.clone():this;if(this._size[0]===x[0]&&this._size[1]===x[1])return D;F=[];for(var E=0;E<D._ptr.length;E++)for(var G=0;G<D._ptr[E+1]-D._ptr[E];G++)F.push(E);E=D._values.slice();G=D._index.slice();for(var I=0;I<D._index.length;I++){var L=G[I]*D._size[1]+F[I];F[I]=L%x[1];G[I]=Math.floor(L/x[1])}D._values.length=0;D._index.length=\n0;D._ptr.length=x[1]+1;D._size=x.slice();for(I=0;I<D._ptr.length;I++)D._ptr[I]=0;for(I=0;I<E.length;I++){L=G[I];var M=F[I],S=E[I],P=n(L,D._ptr[M],D._ptr[M+1],D._index);r(P,L,M,S,D._values,D._index,D._ptr)}return D};d.prototype.clone=function(){return new d({values:this._values?(0,k.clone)(this._values):void 0,index:(0,k.clone)(this._index),ptr:(0,k.clone)(this._ptr),size:(0,k.clone)(this._size),datatype:this._datatype})};d.prototype.size=function(){return this._size.slice(0)};d.prototype.map=function(x,\nD){if(!this._values)throw Error(\"Cannot invoke map on a Pattern only matrix\");var F=this;return C(this,0,this._size[0]-1,0,this._size[1]-1,function(E,G,I){return x(E,[G,I],F)},D)};d.prototype.forEach=function(x,D){if(!this._values)throw Error(\"Cannot invoke forEach on a Pattern only matrix\");for(var F=this._size[0],E=this._size[1],G=0;G<E;G++){var I=this._ptr[G],L=this._ptr[G+1];if(D)for(var M=I;M<L;M++)x(this._values[M],[this._index[M],G],this);else{for(M={};I<L;I++)M[this._index[I]]=this._values[I];\nfor(L=0;L<F;L++)x(L in M?M[L]:0,[L,G],this)}}};d.prototype.toArray=function(){return z(this._values,this._index,this._ptr,this._size,!0)};d.prototype.valueOf=function(){return z(this._values,this._index,this._ptr,this._size,!1)};d.prototype.format=function(x){var D=this._size[0],F=this._size[1],E=this.density();D=\"Sparse Matrix [\"+(0,u.format)(D,x)+\" x \"+(0,u.format)(F,x)+\"] density: \"+(0,u.format)(E,x)+\"\\n\";for(E=0;E<F;E++)for(var G=this._ptr[E+1],I=this._ptr[E];I<G;I++){var L=this._index[I];D+=\n\"\\n    (\"+(0,u.format)(L,x)+\", \"+(0,u.format)(E,x)+\") \\x3d\\x3d\\x3e \"+(this._values?(0,u.format)(this._values[I],x):\"X\")}return D};d.prototype.toString=function(){return(0,u.format)(this.toArray())};d.prototype.toJSON=function(){return{mathjs:\"SparseMatrix\",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}};d.prototype.diagonal=function(x){if(x){if((0,q.isBigNumber)(x)&&(x=x.toNumber()),!(0,q.isNumber)(x)||!(0,f.isInteger)(x))throw new TypeError(\"The parameter k must be an integer number\");\n}else x=0;var D=0<x?x:0;x=0>x?-x:0;for(var F=this._size[1],E=Math.min(this._size[0]-x,F-D),G=[],I=[],L=[0],M=D;M<F&&G.length<E;M++)for(var S=this._ptr[M+1],P=this._ptr[M];P<S;P++){var R=this._index[P];if(R===M-D+x){G.push(this._values[P]);I[G.length-1]=R-x;break}}L.push(G.length);return new d({values:G,index:I,ptr:L,size:[E,1]})};d.fromJSON=function(x){return new d(x)};d.diagonal=function(x,D,F,E,G){if(!(0,q.isArray)(x))throw new TypeError(\"Array expected, size parameter\");if(2!==x.length)throw Error(\"Only two dimensions matrix are supported\");\nx=x.map(function(ca){(0,q.isBigNumber)(ca)&&(ca=ca.toNumber());if(!(0,q.isNumber)(ca)||!(0,f.isInteger)(ca)||1>ca)throw Error(\"Size values must be positive integers\");return ca});if(F){if((0,q.isBigNumber)(F)&&(F=F.toNumber()),!(0,q.isNumber)(F)||!(0,f.isInteger)(F))throw new TypeError(\"The parameter k must be an integer number\");}else F=0;E=B;var I=0;(0,q.isString)(G)&&(E=w.find(B,[G,G])||B,I=w.convert(0,G));G=0<F?F:0;F=0>F?-F:0;var L=x[0];x=x[1];var M=Math.min(L-F,x-G);if((0,q.isArray)(D)){if(D.length!==\nM)throw Error(\"Invalid value array length\");var S=function(ca){return D[ca]}}else if((0,q.isMatrix)(D)){S=D.size();if(1!==S.length||S[0]!==M)throw Error(\"Invalid matrix length\");S=function(ca){return D.get([ca])}}else S=function(){return D};for(var P=[],R=[],ba=[],Q=0;Q<x;Q++){ba.push(P.length);var T=Q-G;if(0<=T&&T<M){var Y=S(T);E(Y,I)||(R.push(T+F),P.push(Y))}}ba.push(P.length);return new d({values:P,index:R,ptr:ba,size:[L,x]})};d.prototype.swapRows=function(x,D){if(!((0,q.isNumber)(x)&&(0,f.isInteger)(x)&&\n(0,q.isNumber)(D)&&(0,f.isInteger)(D)))throw Error(\"Row index must be positive integers\");if(2!==this._size.length)throw Error(\"Only two dimensional matrix is supported\");(0,t.validateIndex)(x,this._size[0]);(0,t.validateIndex)(D,this._size[0]);d._swapRows(x,D,this._size[1],this._values,this._index,this._ptr);return this};d._forEachRow=function(x,D,F,E,G){var I=E[x+1];for(x=E[x];x<I;x++)G(F[x],D[x])};d._swapRows=function(x,D,F,E,G,I){for(var L=0;L<F;L++){var M=I[L],S=I[L+1],P=n(x,M,S,G);M=n(D,M,S,\nG);P<S&&M<S&&G[P]===x&&G[M]===D?E&&(S=E[P],E[P]=E[M],E[M]=S):P<S&&G[P]===x&&(M>=S||G[M]!==D)?(S=E?E[P]:void 0,G.splice(M,0,D),E&&E.splice(M,0,S),G.splice(M<=P?P+1:P,1),E&&E.splice(M<=P?P+1:P,1)):M<S&&G[M]===D&&(P>=S||G[P]!==x)&&(S=E?E[M]:void 0,G.splice(P,0,x),E&&E.splice(P,0,S),G.splice(P<=M?M+1:M,1),E&&E.splice(P<=M?M+1:M,1))}};return d},{isClass:!0});a.createSparseMatrixClass=b}","~:source","shadow$provide[61] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSparseMatrixClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _DimensionError = require(\"../../error/DimensionError.js\");\n\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nvar createSparseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      equalScalar = _ref.equalScalar,\n      Matrix = _ref.Matrix;\n\n  /**\n   * Sparse Matrix implementation. This type implements a Compressed Column Storage format\n   * for sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if ((0, _is.isMatrix)(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && (0, _is.isArray)(data.index) && (0, _is.isArray)(data.ptr) && (0, _is.isArray)(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? (0, _object.clone)(source._values) : undefined;\n      matrix._index = (0, _object.clone)(source._index);\n      matrix._ptr = (0, _object.clone)(source._ptr);\n      matrix._size = (0, _object.clone)(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if ((0, _is.isArray)(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n\n    matrix._ptr.push(matrix._index.length); // size\n\n\n    matrix._size = [rows, columns];\n  }\n\n  SparseMatrix.prototype = new Matrix();\n  /**\n   * Create a new SparseMatrix\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._values, _is.typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!(0, _is.isIndex)(idx)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = idx.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n\n    var size = idx.size();\n\n    if (size.length !== matrix._size.length) {\n      throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n    } // vars\n\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      (0, _array.validateIndex)(min[i], matrix._size[i]);\n      (0, _array.validateIndex)(max[i], matrix._size[i]);\n    } // matrix arrays\n\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if ((0, _is.isMatrix)(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = (0, _array.arraySize)(submatrix);\n    } // check index is a scalar\n\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      } // offsets\n\n\n      var x0 = index.min()[0];\n      var y0 = index.min()[1]; // submatrix rows and columns\n\n      var m = sSize[0];\n      var n = sSize[1]; // loop submatrix\n\n      for (var x = 0; x < m; x++) {\n        // loop columns\n        for (var y = 0; y < n; y++) {\n          // value at i, j\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\n\n          matrix.set([x + x0, y + y0], v, defaultValue);\n        }\n      }\n    }\n\n    return matrix;\n  }\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n\n    return 0;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if ((0, _is.isString)(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n\n    (0, _array.validateIndex)(i, rows);\n    (0, _array.validateIndex)(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n\n    return this;\n  };\n\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n\n    return top;\n  }\n\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[] | Matrix} size  The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n\n    sizeArray.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(sizeArray) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n\n            matrix._index.splice(k, 1); // increase deletes\n\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} sizes          The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!(0, _is.isArray)(sizes)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n\n    sizes.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + (0, _string.format)(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = (0, _array.processSizesWildcard)(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\n\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n\n    var colIndex = [];\n\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n\n    var values = m._values.slice(); // Clone the row index array\n\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n\n    return m;\n  };\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? (0, _object.clone)(this._values) : undefined,\n      index: (0, _object.clone)(this._index),\n      ptr: (0, _object.clone)(this._ptr),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   */\n\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? (0, _object.clone)(values[k]) : values[k] : 1;\n      }\n    }\n\n    return a;\n  }\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + (0, _string.format)(rows, options) + ' x ' + (0, _string.format)(columns, options) + '] density: ' + (0, _string.format)(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + (0, _string.format)(i, options) + ', ' + (0, _string.format)(j, options) + ') ==> ' + (this._values ? (0, _string.format)(this._values[k], options) : 'X');\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this.toArray());\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n\n        continue;\n      } // check x row exist & no y row\n\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n\n        continue;\n      } // check y row exist & no x row\n\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n\n  return SparseMatrix;\n}, {\n  isClass: true\n});\nexports.createSparseMatrixClass = createSparseMatrixClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$module$node_modules$mathjs$lib$cjs$error$DimensionError","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","values","subset","isSparseMatrix","forEach","valueOf","getDataType","fromJSON","index","isClass","prototype","_swapRows","_ptr","__esModule","storage","diagonal","toString","createSparseMatrix","reshape","_datatype","_forEachRow","value","_values","_size","length","mathjs","type","clone","datatype","create","set","resize","size","createSparseMatrixClass","toArray","_index","ptr","swapRows","get","density","format","toJSON"]],"~:compiled-at",1619135723761,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$matrix$SparseMatrix.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/matrix/SparseMatrix.js\"],\n\"sourcesContent\":[\"shadow$provide[61] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSparseMatrixClass = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _DimensionError = require(\\\"../../error/DimensionError.js\\\");\\n\\nvar name = 'SparseMatrix';\\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\\nvar createSparseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      equalScalar = _ref.equalScalar,\\n      Matrix = _ref.Matrix;\\n\\n  /**\\n   * Sparse Matrix implementation. This type implements a Compressed Column Storage format\\n   * for sparse matrices.\\n   * @class SparseMatrix\\n   */\\n  function SparseMatrix(data, datatype) {\\n    if (!(this instanceof SparseMatrix)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if (datatype && !(0, _is.isString)(datatype)) {\\n      throw new Error('Invalid datatype: ' + datatype);\\n    }\\n\\n    if ((0, _is.isMatrix)(data)) {\\n      // create from matrix\\n      _createFromMatrix(this, data, datatype);\\n    } else if (data && (0, _is.isArray)(data.index) && (0, _is.isArray)(data.ptr) && (0, _is.isArray)(data.size)) {\\n      // initialize fields\\n      this._values = data.values;\\n      this._index = data.index;\\n      this._ptr = data.ptr;\\n      this._size = data.size;\\n      this._datatype = datatype || data.datatype;\\n    } else if ((0, _is.isArray)(data)) {\\n      // create from array\\n      _createFromArray(this, data, datatype);\\n    } else if (data) {\\n      // unsupported type\\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\\n    } else {\\n      // nothing provided\\n      this._values = [];\\n      this._index = [];\\n      this._ptr = [0];\\n      this._size = [0, 0];\\n      this._datatype = datatype;\\n    }\\n  }\\n\\n  function _createFromMatrix(matrix, source, datatype) {\\n    // check matrix type\\n    if (source.type === 'SparseMatrix') {\\n      // clone arrays\\n      matrix._values = source._values ? (0, _object.clone)(source._values) : undefined;\\n      matrix._index = (0, _object.clone)(source._index);\\n      matrix._ptr = (0, _object.clone)(source._ptr);\\n      matrix._size = (0, _object.clone)(source._size);\\n      matrix._datatype = datatype || source._datatype;\\n    } else {\\n      // build from matrix data\\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\\n    }\\n  }\\n\\n  function _createFromArray(matrix, data, datatype) {\\n    // initialize fields\\n    matrix._values = [];\\n    matrix._index = [];\\n    matrix._ptr = [];\\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\\n\\n    var rows = data.length;\\n    var columns = 0; // equal signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0;\\n\\n    if ((0, _is.isString)(datatype)) {\\n      // find signature that matches (datatype, datatype)\\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, datatype);\\n    } // check we have rows (empty array)\\n\\n\\n    if (rows > 0) {\\n      // column index\\n      var j = 0;\\n\\n      do {\\n        // store pointer to values index\\n        matrix._ptr.push(matrix._index.length); // loop rows\\n\\n\\n        for (var i = 0; i < rows; i++) {\\n          // current row\\n          var row = data[i]; // check row is an array\\n\\n          if ((0, _is.isArray)(row)) {\\n            // update columns if needed (only on first column)\\n            if (j === 0 && columns < row.length) {\\n              columns = row.length;\\n            } // check row has column\\n\\n\\n            if (j < row.length) {\\n              // value\\n              var v = row[j]; // check value != 0\\n\\n              if (!eq(v, zero)) {\\n                // store value\\n                matrix._values.push(v); // index\\n\\n\\n                matrix._index.push(i);\\n              }\\n            }\\n          } else {\\n            // update columns if needed (only on first column)\\n            if (j === 0 && columns < 1) {\\n              columns = 1;\\n            } // check value != 0 (row is a scalar)\\n\\n\\n            if (!eq(row, zero)) {\\n              // store value\\n              matrix._values.push(row); // index\\n\\n\\n              matrix._index.push(i);\\n            }\\n          }\\n        } // increment index\\n\\n\\n        j++;\\n      } while (j < columns);\\n    } // store number of values in ptr\\n\\n\\n    matrix._ptr.push(matrix._index.length); // size\\n\\n\\n    matrix._size = [rows, columns];\\n  }\\n\\n  SparseMatrix.prototype = new Matrix();\\n  /**\\n   * Create a new SparseMatrix\\n   */\\n\\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\\n    return new SparseMatrix(data, datatype);\\n  };\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  SparseMatrix.prototype.type = 'SparseMatrix';\\n  SparseMatrix.prototype.isSparseMatrix = true;\\n  /**\\n   * Get the matrix type\\n   *\\n   * Usage:\\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\\n   *\\n   * @memberOf SparseMatrix\\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \\\"mixed\\\"\\n   */\\n\\n  SparseMatrix.prototype.getDataType = function () {\\n    return (0, _array.getArrayDataType)(this._values, _is.typeOf);\\n  };\\n  /**\\n   * Get the storage format used by the matrix.\\n   *\\n   * Usage:\\n   *     const format = matrix.storage()   // retrieve storage format\\n   *\\n   * @memberof SparseMatrix\\n   * @return {string}           The storage format.\\n   */\\n\\n\\n  SparseMatrix.prototype.storage = function () {\\n    return 'sparse';\\n  };\\n  /**\\n   * Get the datatype of the data stored in the matrix.\\n   *\\n   * Usage:\\n   *     const format = matrix.datatype()    // retrieve matrix datatype\\n   *\\n   * @memberof SparseMatrix\\n   * @return {string}           The datatype.\\n   */\\n\\n\\n  SparseMatrix.prototype.datatype = function () {\\n    return this._datatype;\\n  };\\n  /**\\n   * Create a new SparseMatrix\\n   * @memberof SparseMatrix\\n   * @param {Array} data\\n   * @param {string} [datatype]\\n   */\\n\\n\\n  SparseMatrix.prototype.create = function (data, datatype) {\\n    return new SparseMatrix(data, datatype);\\n  };\\n  /**\\n   * Get the matrix density.\\n   *\\n   * Usage:\\n   *     const density = matrix.density()                   // retrieve matrix density\\n   *\\n   * @memberof SparseMatrix\\n   * @return {number}           The matrix density.\\n   */\\n\\n\\n  SparseMatrix.prototype.density = function () {\\n    // rows & columns\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // calculate density\\n\\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\\n  };\\n  /**\\n   * Get a subset of the matrix, or replace a subset of the matrix.\\n   *\\n   * Usage:\\n   *     const subset = matrix.subset(index)               // retrieve subset\\n   *     const value = matrix.subset(index, replacement)   // replace subset\\n   *\\n   * @memberof SparseMatrix\\n   * @param {Index} index\\n   * @param {Array | Matrix | *} [replacement]\\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\\n   *                                  the matrix is resized. If not provided,\\n   *                                  new matrix elements will be filled with zeros.\\n   */\\n\\n\\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\\n    // check it is a pattern matrix\\n    if (!this._values) {\\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\\n    } // check arguments\\n\\n\\n    switch (arguments.length) {\\n      case 1:\\n        return _getsubset(this, index);\\n      // intentional fall through\\n\\n      case 2:\\n      case 3:\\n        return _setsubset(this, index, replacement, defaultValue);\\n\\n      default:\\n        throw new SyntaxError('Wrong number of arguments');\\n    }\\n  };\\n\\n  function _getsubset(matrix, idx) {\\n    // check idx\\n    if (!(0, _is.isIndex)(idx)) {\\n      throw new TypeError('Invalid index');\\n    }\\n\\n    var isScalar = idx.isScalar();\\n\\n    if (isScalar) {\\n      // return a scalar\\n      return matrix.get(idx.min());\\n    } // validate dimensions\\n\\n\\n    var size = idx.size();\\n\\n    if (size.length !== matrix._size.length) {\\n      throw new _DimensionError.DimensionError(size.length, matrix._size.length);\\n    } // vars\\n\\n\\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\\n\\n    var min = idx.min();\\n    var max = idx.max();\\n\\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\\n      (0, _array.validateIndex)(min[i], matrix._size[i]);\\n      (0, _array.validateIndex)(max[i], matrix._size[i]);\\n    } // matrix arrays\\n\\n\\n    var mvalues = matrix._values;\\n    var mindex = matrix._index;\\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\\n\\n    var rows = idx.dimension(0);\\n    var columns = idx.dimension(1); // workspace & permutation vector\\n\\n    var w = [];\\n    var pv = []; // loop rows in resulting matrix\\n\\n    rows.forEach(function (i, r) {\\n      // update permutation vector\\n      pv[i] = r[0]; // mark i in workspace\\n\\n      w[i] = true;\\n    }); // result matrix arrays\\n\\n    var values = mvalues ? [] : undefined;\\n    var index = [];\\n    var ptr = []; // loop columns in result matrix\\n\\n    columns.forEach(function (j) {\\n      // update ptr\\n      ptr.push(index.length); // loop values in column j\\n\\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\\n        // row\\n        i = mindex[k]; // check row is in result matrix\\n\\n        if (w[i] === true) {\\n          // push index\\n          index.push(pv[i]); // check we need to process values\\n\\n          if (values) {\\n            values.push(mvalues[k]);\\n          }\\n        }\\n      }\\n    }); // update ptr\\n\\n    ptr.push(index.length); // return matrix\\n\\n    return new SparseMatrix({\\n      values: values,\\n      index: index,\\n      ptr: ptr,\\n      size: size,\\n      datatype: matrix._datatype\\n    });\\n  }\\n\\n  function _setsubset(matrix, index, submatrix, defaultValue) {\\n    // check index\\n    if (!index || index.isIndex !== true) {\\n      throw new TypeError('Invalid index');\\n    } // get index size and check whether the index contains a single value\\n\\n\\n    var iSize = index.size();\\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\\n\\n    var sSize;\\n\\n    if ((0, _is.isMatrix)(submatrix)) {\\n      // submatrix size\\n      sSize = submatrix.size(); // use array representation\\n\\n      submatrix = submatrix.toArray();\\n    } else {\\n      // get submatrix size (array, scalar)\\n      sSize = (0, _array.arraySize)(submatrix);\\n    } // check index is a scalar\\n\\n\\n    if (isScalar) {\\n      // verify submatrix is a scalar\\n      if (sSize.length !== 0) {\\n        throw new TypeError('Scalar expected');\\n      } // set value\\n\\n\\n      matrix.set(index.min(), submatrix, defaultValue);\\n    } else {\\n      // validate dimensions, index size must be one or two dimensions\\n      if (iSize.length !== 1 && iSize.length !== 2) {\\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\\n      } // check submatrix and index have the same dimensions\\n\\n\\n      if (sSize.length < iSize.length) {\\n        // calculate number of missing outer dimensions\\n        var i = 0;\\n        var outer = 0;\\n\\n        while (iSize[i] === 1 && sSize[i] === 1) {\\n          i++;\\n        }\\n\\n        while (iSize[i] === 1) {\\n          outer++;\\n          i++;\\n        } // unsqueeze both outer and inner dimensions\\n\\n\\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\\n      } // check whether the size of the submatrix matches the index size\\n\\n\\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\\n      } // offsets\\n\\n\\n      var x0 = index.min()[0];\\n      var y0 = index.min()[1]; // submatrix rows and columns\\n\\n      var m = sSize[0];\\n      var n = sSize[1]; // loop submatrix\\n\\n      for (var x = 0; x < m; x++) {\\n        // loop columns\\n        for (var y = 0; y < n; y++) {\\n          // value at i, j\\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\\n\\n          matrix.set([x + x0, y + y0], v, defaultValue);\\n        }\\n      }\\n    }\\n\\n    return matrix;\\n  }\\n  /**\\n   * Get a single element from the matrix.\\n   * @memberof SparseMatrix\\n   * @param {number[]} index   Zero-based index\\n   * @return {*} value\\n   */\\n\\n\\n  SparseMatrix.prototype.get = function (index) {\\n    if (!(0, _is.isArray)(index)) {\\n      throw new TypeError('Array expected');\\n    }\\n\\n    if (index.length !== this._size.length) {\\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\\n    } // check it is a pattern matrix\\n\\n\\n    if (!this._values) {\\n      throw new Error('Cannot invoke get on a Pattern only matrix');\\n    } // row and column\\n\\n\\n    var i = index[0];\\n    var j = index[1]; // check i, j are valid\\n\\n    (0, _array.validateIndex)(i, this._size[0]);\\n    (0, _array.validateIndex)(j, this._size[1]); // find value index\\n\\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\\n\\n\\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\\n      return this._values[k];\\n    }\\n\\n    return 0;\\n  };\\n  /**\\n   * Replace a single element in the matrix.\\n   * @memberof SparseMatrix\\n   * @param {number[]} index   Zero-based index\\n   * @param {*} v\\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\\n   *                                  the matrix is resized. If not provided,\\n   *                                  new matrix elements will be set to zero.\\n   * @return {SparseMatrix} self\\n   */\\n\\n\\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\\n    if (!(0, _is.isArray)(index)) {\\n      throw new TypeError('Array expected');\\n    }\\n\\n    if (index.length !== this._size.length) {\\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\\n    } // check it is a pattern matrix\\n\\n\\n    if (!this._values) {\\n      throw new Error('Cannot invoke set on a Pattern only matrix');\\n    } // row and column\\n\\n\\n    var i = index[0];\\n    var j = index[1]; // rows & columns\\n\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // equal signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0;\\n\\n    if ((0, _is.isString)(this._datatype)) {\\n      // find signature that matches (datatype, datatype)\\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, this._datatype);\\n    } // check we need to resize matrix\\n\\n\\n    if (i > rows - 1 || j > columns - 1) {\\n      // resize matrix\\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\\n\\n\\n      rows = this._size[0];\\n      columns = this._size[1];\\n    } // check i, j are valid\\n\\n\\n    (0, _array.validateIndex)(i, rows);\\n    (0, _array.validateIndex)(j, columns); // find value index\\n\\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\\n\\n\\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\\n      // check value != 0\\n      if (!eq(v, zero)) {\\n        // update value\\n        this._values[k] = v;\\n      } else {\\n        // remove value from matrix\\n        _remove(k, j, this._values, this._index, this._ptr);\\n      }\\n    } else {\\n      // insert value @ (i, j)\\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\\n    }\\n\\n    return this;\\n  };\\n\\n  function _getValueIndex(i, top, bottom, index) {\\n    // check row is on the bottom side\\n    if (bottom - top === 0) {\\n      return bottom;\\n    } // loop rows [top, bottom[\\n\\n\\n    for (var r = top; r < bottom; r++) {\\n      // check we found value index\\n      if (index[r] === i) {\\n        return r;\\n      }\\n    } // we did not find row\\n\\n\\n    return top;\\n  }\\n\\n  function _remove(k, j, values, index, ptr) {\\n    // remove value @ k\\n    values.splice(k, 1);\\n    index.splice(k, 1); // update pointers\\n\\n    for (var x = j + 1; x < ptr.length; x++) {\\n      ptr[x]--;\\n    }\\n  }\\n\\n  function _insert(k, i, j, v, values, index, ptr) {\\n    // insert value\\n    values.splice(k, 0, v); // update row for k\\n\\n    index.splice(k, 0, i); // update column pointers\\n\\n    for (var x = j + 1; x < ptr.length; x++) {\\n      ptr[x]++;\\n    }\\n  }\\n  /**\\n   * Resize the matrix to the given size. Returns a copy of the matrix when\\n   * `copy=true`, otherwise return the matrix itself (resize in place).\\n   *\\n   * @memberof SparseMatrix\\n   * @param {number[] | Matrix} size  The new size the matrix should have.\\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\\n   *                                  If not provided, the matrix elements will\\n   *                                  be filled with zeros.\\n   * @param {boolean} [copy]          Return a resized copy of the matrix\\n   *\\n   * @return {Matrix}                 The resized matrix\\n   */\\n\\n\\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\\n    // validate arguments\\n    if (!(0, _is.isCollection)(size)) {\\n      throw new TypeError('Array or Matrix expected');\\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\\n\\n\\n    var sizeArray = size.valueOf().map(function (value) {\\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\\n    });\\n\\n    if (sizeArray.length !== 2) {\\n      throw new Error('Only two dimensions matrix are supported');\\n    } // check sizes\\n\\n\\n    sizeArray.forEach(function (value) {\\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(sizeArray) + ')');\\n      }\\n    }); // matrix to resize\\n\\n    var m = copy ? this.clone() : this; // resize matrix\\n\\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\\n  };\\n\\n  function _resize(matrix, rows, columns, defaultValue) {\\n    // value to insert at the time of growing matrix\\n    var value = defaultValue || 0; // equal signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0;\\n\\n    if ((0, _is.isString)(matrix._datatype)) {\\n      // find signature that matches (datatype, datatype)\\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\\n\\n      value = typed.convert(value, matrix._datatype);\\n    } // should we insert the value?\\n\\n\\n    var ins = !eq(value, zero); // old columns and rows\\n\\n    var r = matrix._size[0];\\n    var c = matrix._size[1];\\n    var i, j, k; // check we need to increase columns\\n\\n    if (columns > c) {\\n      // loop new columns\\n      for (j = c; j < columns; j++) {\\n        // update matrix._ptr for current column\\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\\n\\n        if (ins) {\\n          // loop rows\\n          for (i = 0; i < r; i++) {\\n            // add new matrix._values\\n            matrix._values.push(value); // update matrix._index\\n\\n\\n            matrix._index.push(i);\\n          }\\n        }\\n      } // store number of matrix._values in matrix._ptr\\n\\n\\n      matrix._ptr[columns] = matrix._values.length;\\n    } else if (columns < c) {\\n      // truncate matrix._ptr\\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\\n\\n\\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\\n\\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\\n    } // update columns\\n\\n\\n    c = columns; // check we need to increase rows\\n\\n    if (rows > r) {\\n      // check we have to insert values\\n      if (ins) {\\n        // inserts\\n        var n = 0; // loop columns\\n\\n        for (j = 0; j < c; j++) {\\n          // update matrix._ptr for current column\\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\\n\\n          k = matrix._ptr[j + 1] + n; // pointer\\n\\n          var p = 0; // loop new rows, initialize pointer\\n\\n          for (i = r; i < rows; i++, p++) {\\n            // add value\\n            matrix._values.splice(k + p, 0, value); // update matrix._index\\n\\n\\n            matrix._index.splice(k + p, 0, i); // increment inserts\\n\\n\\n            n++;\\n          }\\n        } // store number of matrix._values in matrix._ptr\\n\\n\\n        matrix._ptr[c] = matrix._values.length;\\n      }\\n    } else if (rows < r) {\\n      // deletes\\n      var d = 0; // loop columns\\n\\n      for (j = 0; j < c; j++) {\\n        // update matrix._ptr for current column\\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\\n\\n        var k0 = matrix._ptr[j];\\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\\n\\n        for (k = k0; k < k1; k++) {\\n          // row\\n          i = matrix._index[k]; // check we need to delete value and matrix._index\\n\\n          if (i > rows - 1) {\\n            // remove value\\n            matrix._values.splice(k, 1); // remove item from matrix._index\\n\\n\\n            matrix._index.splice(k, 1); // increase deletes\\n\\n\\n            d++;\\n          }\\n        }\\n      } // update matrix._ptr for current column\\n\\n\\n      matrix._ptr[j] = matrix._values.length;\\n    } // update matrix._size\\n\\n\\n    matrix._size[0] = rows;\\n    matrix._size[1] = columns; // return matrix\\n\\n    return matrix;\\n  }\\n  /**\\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\\n   *\\n   * NOTE: This might be better suited to copy by default, instead of modifying\\n   *       in place. For now, it operates in place to remain consistent with\\n   *       resize().\\n   *\\n   * @memberof SparseMatrix\\n   * @param {number[]} sizes          The new size the matrix should have.\\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\\n   *\\n   * @return {Matrix}                 The reshaped matrix\\n   */\\n\\n\\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\\n    // validate arguments\\n    if (!(0, _is.isArray)(sizes)) {\\n      throw new TypeError('Array expected');\\n    }\\n\\n    if (sizes.length !== 2) {\\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\\n    } // check sizes\\n\\n\\n    sizes.forEach(function (value) {\\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value <= -2 || value === 0) {\\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + (0, _string.format)(sizes) + ')');\\n      }\\n    });\\n    var currentLength = this._size[0] * this._size[1];\\n    sizes = (0, _array.processSizesWildcard)(sizes, currentLength);\\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\\n\\n    if (currentLength !== newLength) {\\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\\n    } // matrix to reshape\\n\\n\\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\\n\\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\\n      return m;\\n    } // Convert to COO format (generate a column index)\\n\\n\\n    var colIndex = [];\\n\\n    for (var i = 0; i < m._ptr.length; i++) {\\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\\n        colIndex.push(i);\\n      }\\n    } // Clone the values array\\n\\n\\n    var values = m._values.slice(); // Clone the row index array\\n\\n\\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\\n\\n\\n    for (var _i = 0; _i < m._index.length; _i++) {\\n      var r1 = rowIndex[_i];\\n      var c1 = colIndex[_i];\\n      var flat = r1 * m._size[1] + c1;\\n      colIndex[_i] = flat % sizes[1];\\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\\n    // sorting several arrays based on some other array.\\n    // OR, we could easily just:\\n    // 1. Remove all values from the matrix\\n\\n\\n    m._values.length = 0;\\n    m._index.length = 0;\\n    m._ptr.length = sizes[1] + 1;\\n    m._size = sizes.slice();\\n\\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\\n      m._ptr[_i2] = 0;\\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\\n    // This step is probably the most time-consuming\\n\\n\\n    for (var h = 0; h < values.length; h++) {\\n      var _i3 = rowIndex[h];\\n      var _j = colIndex[h];\\n      var v = values[h];\\n\\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\\n\\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\\n    } // The value indices are inserted out of order, but apparently that's... still OK?\\n\\n\\n    return m;\\n  };\\n  /**\\n   * Create a clone of the matrix\\n   * @memberof SparseMatrix\\n   * @return {SparseMatrix} clone\\n   */\\n\\n\\n  SparseMatrix.prototype.clone = function () {\\n    var m = new SparseMatrix({\\n      values: this._values ? (0, _object.clone)(this._values) : undefined,\\n      index: (0, _object.clone)(this._index),\\n      ptr: (0, _object.clone)(this._ptr),\\n      size: (0, _object.clone)(this._size),\\n      datatype: this._datatype\\n    });\\n    return m;\\n  };\\n  /**\\n   * Retrieve the size of the matrix.\\n   * @memberof SparseMatrix\\n   * @returns {number[]} size\\n   */\\n\\n\\n  SparseMatrix.prototype.size = function () {\\n    return this._size.slice(0); // copy the Array\\n  };\\n  /**\\n   * Create a new matrix with the results of the callback function executed on\\n   * each entry of the matrix.\\n   * @memberof SparseMatrix\\n   * @param {Function} callback   The callback function is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Matrix being traversed.\\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\\n   *\\n   * @return {SparseMatrix} matrix\\n   */\\n\\n\\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\\n    // check it is a pattern matrix\\n    if (!this._values) {\\n      throw new Error('Cannot invoke map on a Pattern only matrix');\\n    } // matrix instance\\n\\n\\n    var me = this; // rows and columns\\n\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // invoke callback\\n\\n    var invoke = function invoke(v, i, j) {\\n      // invoke callback\\n      return callback(v, [i, j], me);\\n    }; // invoke _map\\n\\n\\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\\n  };\\n  /**\\n   * Create a new matrix with the results of the callback function executed on the interval\\n   * [minRow..maxRow, minColumn..maxColumn].\\n   */\\n\\n\\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\\n    // result arrays\\n    var values = [];\\n    var index = [];\\n    var ptr = []; // equal signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0;\\n\\n    if ((0, _is.isString)(matrix._datatype)) {\\n      // find signature that matches (datatype, datatype)\\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, matrix._datatype);\\n    } // invoke callback\\n\\n\\n    var invoke = function invoke(v, x, y) {\\n      // invoke callback\\n      v = callback(v, x, y); // check value != 0\\n\\n      if (!eq(v, zero)) {\\n        // store value\\n        values.push(v); // index\\n\\n        index.push(x);\\n      }\\n    }; // loop columns\\n\\n\\n    for (var j = minColumn; j <= maxColumn; j++) {\\n      // store pointer to values index\\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n\\n      var k0 = matrix._ptr[j];\\n      var k1 = matrix._ptr[j + 1];\\n\\n      if (skipZeros) {\\n        // loop k within [k0, k1[\\n        for (var k = k0; k < k1; k++) {\\n          // row index\\n          var i = matrix._index[k]; // check i is in range\\n\\n          if (i >= minRow && i <= maxRow) {\\n            // value @ k\\n            invoke(matrix._values[k], i - minRow, j - minColumn);\\n          }\\n        }\\n      } else {\\n        // create a cache holding all defined values\\n        var _values = {};\\n\\n        for (var _k = k0; _k < k1; _k++) {\\n          var _i4 = matrix._index[_k];\\n          _values[_i4] = matrix._values[_k];\\n        } // loop over all rows (indexes can be unordered so we can't use that),\\n        // and either read the value or zero\\n\\n\\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\\n          var value = _i5 in _values ? _values[_i5] : 0;\\n          invoke(value, _i5 - minRow, j - minColumn);\\n        }\\n      }\\n    } // store number of values in ptr\\n\\n\\n    ptr.push(values.length); // return sparse matrix\\n\\n    return new SparseMatrix({\\n      values: values,\\n      index: index,\\n      ptr: ptr,\\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\\n    });\\n  }\\n  /**\\n   * Execute a callback function on each entry of the matrix.\\n   * @memberof SparseMatrix\\n   * @param {Function} callback   The callback function is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Matrix being traversed.\\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\\n   */\\n\\n\\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\\n    // check it is a pattern matrix\\n    if (!this._values) {\\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\\n    } // matrix instance\\n\\n\\n    var me = this; // rows and columns\\n\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // loop columns\\n\\n    for (var j = 0; j < columns; j++) {\\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n      var k0 = this._ptr[j];\\n      var k1 = this._ptr[j + 1];\\n\\n      if (skipZeros) {\\n        // loop k within [k0, k1[\\n        for (var k = k0; k < k1; k++) {\\n          // row index\\n          var i = this._index[k]; // value @ k\\n\\n          callback(this._values[k], [i, j], me);\\n        }\\n      } else {\\n        // create a cache holding all defined values\\n        var values = {};\\n\\n        for (var _k2 = k0; _k2 < k1; _k2++) {\\n          var _i6 = this._index[_k2];\\n          values[_i6] = this._values[_k2];\\n        } // loop over all rows (indexes can be unordered so we can't use that),\\n        // and either read the value or zero\\n\\n\\n        for (var _i7 = 0; _i7 < rows; _i7++) {\\n          var value = _i7 in values ? values[_i7] : 0;\\n          callback(value, [_i7, j], me);\\n        }\\n      }\\n    }\\n  };\\n  /**\\n   * Create an Array with a copy of the data of the SparseMatrix\\n   * @memberof SparseMatrix\\n   * @returns {Array} array\\n   */\\n\\n\\n  SparseMatrix.prototype.toArray = function () {\\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\\n  };\\n  /**\\n   * Get the primitive value of the SparseMatrix: a two dimensions array\\n   * @memberof SparseMatrix\\n   * @returns {Array} array\\n   */\\n\\n\\n  SparseMatrix.prototype.valueOf = function () {\\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\\n  };\\n\\n  function _toArray(values, index, ptr, size, copy) {\\n    // rows and columns\\n    var rows = size[0];\\n    var columns = size[1]; // result\\n\\n    var a = []; // vars\\n\\n    var i, j; // initialize array\\n\\n    for (i = 0; i < rows; i++) {\\n      a[i] = [];\\n\\n      for (j = 0; j < columns; j++) {\\n        a[i][j] = 0;\\n      }\\n    } // loop columns\\n\\n\\n    for (j = 0; j < columns; j++) {\\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n      var k0 = ptr[j];\\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\\n\\n      for (var k = k0; k < k1; k++) {\\n        // row index\\n        i = index[k]; // set value (use one for pattern matrix)\\n\\n        a[i][j] = values ? copy ? (0, _object.clone)(values[k]) : values[k] : 1;\\n      }\\n    }\\n\\n    return a;\\n  }\\n  /**\\n   * Get a string representation of the matrix, with optional formatting options.\\n   * @memberof SparseMatrix\\n   * @param {Object | number | Function} [options]  Formatting options. See\\n   *                                                lib/utils/number:format for a\\n   *                                                description of the available\\n   *                                                options.\\n   * @returns {string} str\\n   */\\n\\n\\n  SparseMatrix.prototype.format = function (options) {\\n    // rows and columns\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // density\\n\\n    var density = this.density(); // rows & columns\\n\\n    var str = 'Sparse Matrix [' + (0, _string.format)(rows, options) + ' x ' + (0, _string.format)(columns, options) + '] density: ' + (0, _string.format)(density, options) + '\\\\n'; // loop columns\\n\\n    for (var j = 0; j < columns; j++) {\\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n      var k0 = this._ptr[j];\\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\\n\\n      for (var k = k0; k < k1; k++) {\\n        // row index\\n        var i = this._index[k]; // append value\\n\\n        str += '\\\\n    (' + (0, _string.format)(i, options) + ', ' + (0, _string.format)(j, options) + ') ==> ' + (this._values ? (0, _string.format)(this._values[k], options) : 'X');\\n      }\\n    }\\n\\n    return str;\\n  };\\n  /**\\n   * Get a string representation of the matrix\\n   * @memberof SparseMatrix\\n   * @returns {string} str\\n   */\\n\\n\\n  SparseMatrix.prototype.toString = function () {\\n    return (0, _string.format)(this.toArray());\\n  };\\n  /**\\n   * Get a JSON representation of the matrix\\n   * @memberof SparseMatrix\\n   * @returns {Object}\\n   */\\n\\n\\n  SparseMatrix.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'SparseMatrix',\\n      values: this._values,\\n      index: this._index,\\n      ptr: this._ptr,\\n      size: this._size,\\n      datatype: this._datatype\\n    };\\n  };\\n  /**\\n   * Get the kth Matrix diagonal.\\n   *\\n   * @memberof SparseMatrix\\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\\n   *\\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\\n   */\\n\\n\\n  SparseMatrix.prototype.diagonal = function (k) {\\n    // validate k if any\\n    if (k) {\\n      // convert BigNumber to a number\\n      if ((0, _is.isBigNumber)(k)) {\\n        k = k.toNumber();\\n      } // is must be an integer\\n\\n\\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\\n        throw new TypeError('The parameter k must be an integer number');\\n      }\\n    } else {\\n      // default value\\n      k = 0;\\n    }\\n\\n    var kSuper = k > 0 ? k : 0;\\n    var kSub = k < 0 ? -k : 0; // rows & columns\\n\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // number diagonal values\\n\\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\\n\\n    var values = [];\\n    var index = [];\\n    var ptr = []; // initial ptr value\\n\\n    ptr[0] = 0; // loop columns\\n\\n    for (var j = kSuper; j < columns && values.length < n; j++) {\\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n      var k0 = this._ptr[j];\\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\\n\\n      for (var x = k0; x < k1; x++) {\\n        // row index\\n        var i = this._index[x]; // check row\\n\\n        if (i === j - kSuper + kSub) {\\n          // value on this column\\n          values.push(this._values[x]); // store row\\n\\n          index[values.length - 1] = i - kSub; // exit loop\\n\\n          break;\\n        }\\n      }\\n    } // close ptr\\n\\n\\n    ptr.push(values.length); // return matrix\\n\\n    return new SparseMatrix({\\n      values: values,\\n      index: index,\\n      ptr: ptr,\\n      size: [n, 1]\\n    });\\n  };\\n  /**\\n   * Generate a matrix from a JSON object\\n   * @memberof SparseMatrix\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"SparseMatrix\\\", \\\"values\\\": [], \\\"index\\\": [], \\\"ptr\\\": [], \\\"size\\\": []}`,\\n   *                       where mathjs is optional\\n   * @returns {SparseMatrix}\\n   */\\n\\n\\n  SparseMatrix.fromJSON = function (json) {\\n    return new SparseMatrix(json);\\n  };\\n  /**\\n   * Create a diagonal matrix.\\n   *\\n   * @memberof SparseMatrix\\n   * @param {Array} size                       The matrix size.\\n   * @param {number | Array | Matrix } value   The values for the diagonal.\\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\\n   * @param {number} [defaultValue]            The default value for non-diagonal\\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\\n   *\\n   * @returns {SparseMatrix}\\n   */\\n\\n\\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\\n    if (!(0, _is.isArray)(size)) {\\n      throw new TypeError('Array expected, size parameter');\\n    }\\n\\n    if (size.length !== 2) {\\n      throw new Error('Only two dimensions matrix are supported');\\n    } // map size & validate\\n\\n\\n    size = size.map(function (s) {\\n      // check it is a big number\\n      if ((0, _is.isBigNumber)(s)) {\\n        // convert it\\n        s = s.toNumber();\\n      } // validate arguments\\n\\n\\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\\n        throw new Error('Size values must be positive integers');\\n      }\\n\\n      return s;\\n    }); // validate k if any\\n\\n    if (k) {\\n      // convert BigNumber to a number\\n      if ((0, _is.isBigNumber)(k)) {\\n        k = k.toNumber();\\n      } // is must be an integer\\n\\n\\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\\n        throw new TypeError('The parameter k must be an integer number');\\n      }\\n    } else {\\n      // default value\\n      k = 0;\\n    } // equal signature to use\\n\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0;\\n\\n    if ((0, _is.isString)(datatype)) {\\n      // find signature that matches (datatype, datatype)\\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, datatype);\\n    }\\n\\n    var kSuper = k > 0 ? k : 0;\\n    var kSub = k < 0 ? -k : 0; // rows and columns\\n\\n    var rows = size[0];\\n    var columns = size[1]; // number of non-zero items\\n\\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\\n\\n    var _value; // check value\\n\\n\\n    if ((0, _is.isArray)(value)) {\\n      // validate array\\n      if (value.length !== n) {\\n        // number of values in array must be n\\n        throw new Error('Invalid value array length');\\n      } // define function\\n\\n\\n      _value = function _value(i) {\\n        // return value @ i\\n        return value[i];\\n      };\\n    } else if ((0, _is.isMatrix)(value)) {\\n      // matrix size\\n      var ms = value.size(); // validate matrix\\n\\n      if (ms.length !== 1 || ms[0] !== n) {\\n        // number of values in array must be n\\n        throw new Error('Invalid matrix length');\\n      } // define function\\n\\n\\n      _value = function _value(i) {\\n        // return value @ i\\n        return value.get([i]);\\n      };\\n    } else {\\n      // define function\\n      _value = function _value() {\\n        // return value\\n        return value;\\n      };\\n    } // create arrays\\n\\n\\n    var values = [];\\n    var index = [];\\n    var ptr = []; // loop items\\n\\n    for (var j = 0; j < columns; j++) {\\n      // number of rows with value\\n      ptr.push(values.length); // diagonal index\\n\\n      var i = j - kSuper; // check we need to set diagonal value\\n\\n      if (i >= 0 && i < n) {\\n        // get value @ i\\n        var v = _value(i); // check for zero\\n\\n\\n        if (!eq(v, zero)) {\\n          // column\\n          index.push(i + kSub); // add value\\n\\n          values.push(v);\\n        }\\n      }\\n    } // last value should be number of values\\n\\n\\n    ptr.push(values.length); // create SparseMatrix\\n\\n    return new SparseMatrix({\\n      values: values,\\n      index: index,\\n      ptr: ptr,\\n      size: [rows, columns]\\n    });\\n  };\\n  /**\\n   * Swap rows i and j in Matrix.\\n   *\\n   * @memberof SparseMatrix\\n   * @param {number} i       Matrix row index 1\\n   * @param {number} j       Matrix row index 2\\n   *\\n   * @return {Matrix}        The matrix reference\\n   */\\n\\n\\n  SparseMatrix.prototype.swapRows = function (i, j) {\\n    // check index\\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\\n      throw new Error('Row index must be positive integers');\\n    } // check dimensions\\n\\n\\n    if (this._size.length !== 2) {\\n      throw new Error('Only two dimensional matrix is supported');\\n    } // validate index\\n\\n\\n    (0, _array.validateIndex)(i, this._size[0]);\\n    (0, _array.validateIndex)(j, this._size[0]); // swap rows\\n\\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\\n\\n\\n    return this;\\n  };\\n  /**\\n   * Loop rows with data in column j.\\n   *\\n   * @param {number} j            Column\\n   * @param {Array} values        Matrix values\\n   * @param {Array} index         Matrix row indeces\\n   * @param {Array} ptr           Matrix column pointers\\n   * @param {Function} callback   Callback function invoked for every row in column j\\n   */\\n\\n\\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\\n    // indeces for column j\\n    var k0 = ptr[j];\\n    var k1 = ptr[j + 1]; // loop\\n\\n    for (var k = k0; k < k1; k++) {\\n      // invoke callback\\n      callback(index[k], values[k]);\\n    }\\n  };\\n  /**\\n   * Swap rows x and y in Sparse Matrix data structures.\\n   *\\n   * @param {number} x         Matrix row index 1\\n   * @param {number} y         Matrix row index 2\\n   * @param {number} columns   Number of columns in matrix\\n   * @param {Array} values     Matrix values\\n   * @param {Array} index      Matrix row indeces\\n   * @param {Array} ptr        Matrix column pointers\\n   */\\n\\n\\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\\n    // loop columns\\n    for (var j = 0; j < columns; j++) {\\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n      var k0 = ptr[j];\\n      var k1 = ptr[j + 1]; // find value index @ x\\n\\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\\n\\n\\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\\n\\n\\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\\n        // swap values (check for pattern matrix)\\n        if (values) {\\n          var v = values[kx];\\n          values[kx] = values[ky];\\n          values[ky] = v;\\n        } // next column\\n\\n\\n        continue;\\n      } // check x row exist & no y row\\n\\n\\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\\n        // value @ x (check for pattern matrix)\\n        var vx = values ? values[kx] : undefined; // insert value @ y\\n\\n        index.splice(ky, 0, y);\\n\\n        if (values) {\\n          values.splice(ky, 0, vx);\\n        } // remove value @ x (adjust array index if needed)\\n\\n\\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\\n\\n        if (values) {\\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\\n        } // next column\\n\\n\\n        continue;\\n      } // check y row exist & no x row\\n\\n\\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\\n        // value @ y (check for pattern matrix)\\n        var vy = values ? values[ky] : undefined; // insert value @ x\\n\\n        index.splice(kx, 0, x);\\n\\n        if (values) {\\n          values.splice(kx, 0, vy);\\n        } // remove value @ y (adjust array index if needed)\\n\\n\\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\\n\\n        if (values) {\\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\\n        }\\n      }\\n    }\\n  };\\n\\n  return SparseMatrix;\\n}, {\\n  isClass: true\\n});\\nexports.createSparseMatrixClass = createSparseMatrixClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSparseMatrixClass\",\"_is\",\"_number\",\"_string\",\"_object\",\"_array\",\"_factory\",\"_DimensionError\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"SparseMatrix\",\"data\",\"datatype\",\"SyntaxError\",\"isString\",\"Error\",\"isMatrix\",\"type\",\"matrix\",\"_values\",\"clone\",\"undefined\",\"_index\",\"_ptr\",\"_size\",\"_datatype\",\"_createFromArray\",\"valueOf\",\"isArray\",\"index\",\"ptr\",\"size\",\"values\",\"TypeError\",\"typeOf\",\"rows\",\"length\",\"columns\",\"eq\",\"equalScalar\",\"zero\",\"typed\",\"find\",\"convert\",\"j\",\"push\",\"i\",\"row\",\"v\",\"_getsubset\",\"idx\",\"isIndex\",\"isScalar\",\"get\",\"min\",\"DimensionError\",\"ii\",\"k\",\"kk\",\"max\",\"validateIndex\",\"mvalues\",\"mindex\",\"mptr\",\"dimension\",\"w\",\"pv\",\"forEach\",\"r\",\"_getValueIndex\",\"top\",\"bottom\",\"_insert\",\"splice\",\"x\",\"_resize\",\"defaultValue\",\"ins\",\"c\",\"n\",\"p\",\"d\",\"k1\",\"k0\",\"_map\",\"minRow\",\"maxRow\",\"minColumn\",\"maxColumn\",\"callback\",\"skipZeros\",\"invoke\",\"y\",\"_k\",\"_i4\",\"_i5\",\"_toArray\",\"copy\",\"a\",\"prototype\",\"Matrix\",\"createSparseMatrix\",\"SparseMatrix.prototype.createSparseMatrix\",\"isSparseMatrix\",\"getDataType\",\"SparseMatrix.prototype.getDataType\",\"getArrayDataType\",\"storage\",\"SparseMatrix.prototype.storage\",\"SparseMatrix.prototype.datatype\",\"create\",\"SparseMatrix.prototype.create\",\"density\",\"SparseMatrix.prototype.density\",\"subset\",\"SparseMatrix.prototype.subset\",\"replacement\",\"arguments\",\"iSize\",\"submatrix\",\"sSize\",\"toArray\",\"arraySize\",\"set\",\"outer\",\"unsqueeze\",\"deepStrictEqual\",\"x0\",\"y0\",\"m\",\"SparseMatrix.prototype.get\",\"SparseMatrix.prototype.set\",\"Math\",\"resize\",\"SparseMatrix.prototype.resize\",\"isCollection\",\"sizeArray\",\"map\",\"Array\",\"isNumber\",\"isInteger\",\"format\",\"reshape\",\"SparseMatrix.prototype.reshape\",\"sizes\",\"currentLength\",\"processSizesWildcard\",\"colIndex\",\"slice\",\"rowIndex\",\"_i\",\"flat\",\"r1\",\"c1\",\"floor\",\"_i2\",\"h\",\"_i3\",\"_j\",\"SparseMatrix.prototype.clone\",\"SparseMatrix.prototype.size\",\"SparseMatrix.prototype.map\",\"me\",\"SparseMatrix.prototype.forEach\",\"_k2\",\"_i6\",\"_i7\",\"SparseMatrix.prototype.toArray\",\"SparseMatrix.prototype.valueOf\",\"SparseMatrix.prototype.format\",\"options\",\"str\",\"toString\",\"SparseMatrix.prototype.toString\",\"toJSON\",\"SparseMatrix.prototype.toJSON\",\"mathjs\",\"diagonal\",\"SparseMatrix.prototype.diagonal\",\"isBigNumber\",\"toNumber\",\"kSuper\",\"kSub\",\"fromJSON\",\"SparseMatrix.fromJSON\",\"json\",\"SparseMatrix.diagonal\",\"s\",\"_value\",\"ms\",\"swapRows\",\"SparseMatrix.prototype.swapRows\",\"_swapRows\",\"_forEachRow\",\"SparseMatrix._forEachRow\",\"SparseMatrix._swapRows\",\"kx\",\"ky\",\"vx\",\"vy\",\"isClass\"]\n}\n"]