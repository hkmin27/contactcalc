["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/statistics/variance.js"],"~:js","shadow$provide[534]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createVariance=void 0;var q=b(38),f=b(14);c=b(25);var u=b(154);b=(0,c.factory)(\"variance\",\"typed add subtract multiply divide apply isNaN\".split(\" \"),function(k){function t(C,z){var w=0;if(0===C.length)throw new SyntaxError(\"Function variance requires one or more parameters (0 provided)\");(0,q.deepForEach)(C,function(D){try{x=void 0===x?D:d(x,D),w++}catch(F){throw(0,u.improveErrorMessage)(F,\"variance\",D);}});\nif(0===w)throw Error(\"Cannot calculate variance of an empty array\");var B=n(x,w);var x=void 0;(0,q.deepForEach)(C,function(D){D=l(D,B);x=void 0===x?h(D,D):d(x,h(D,D))});if(v(x))return x;switch(z){case \"uncorrected\":return n(x,w);case \"biased\":return n(x,w+1);case \"unbiased\":return C=(0,f.isBigNumber)(x)?x.mul(0):0,1===w?C:n(x,w-1);default:throw Error('Unknown normalization \"'+z+'\". Choose \"unbiased\" (default), \"uncorrected\", or \"biased\".');}}function p(C,z,w){try{if(0===C.length)throw new SyntaxError(\"Function variance requires one or more parameters (0 provided)\");\nreturn r(C,z,function(B){return t(B,w)})}catch(B){throw(0,u.improveErrorMessage)(B,\"variance\");}}var g=k.typed,d=k.add,l=k.subtract,h=k.multiply,n=k.divide,r=k.apply,v=k.isNaN;return g(\"variance\",{\"Array | Matrix\":function(C){return t(C,\"unbiased\")},\"Array | Matrix, string\":t,\"Array | Matrix, number | BigNumber\":function(C,z){return p(C,z,\"unbiased\")},\"Array | Matrix, number | BigNumber, string\":p,\"...\":function(C){return t(C,\"unbiased\")}})});a.createVariance=b}","~:source","shadow$provide[534] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createVariance = void 0;\n\nvar _collection = require(\"../../utils/collection.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _improveErrorMessage = require(\"./utils/improveErrorMessage.js\");\n\nvar DEFAULT_NORMALIZATION = 'unbiased';\nvar name = 'variance';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];\nvar createVariance = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      apply = _ref.apply,\n      isNaN = _ref.isNaN;\n\n  /**\n   * Compute the variance of a matrix or a  list with values.\n   * In case of a (multi dimensional) array or matrix, the variance over all\n   * elements will be calculated.\n   *\n   * Additionally, it is possible to compute the variance along the rows\n   * or columns of a matrix by specifying the dimension as the second argument.\n   *\n   * Optionally, the type of normalization can be specified as the final\n   * parameter. The parameter `normalization` can be one of the following values:\n   *\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\n   * - 'uncorrected'        The sum of squared errors is divided by n\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\n   *\n   *\n   * Note that older browser may not like the variable name `var`. In that\n   * case, the function can be called as `math['var'](...)` instead of\n   * `math.var(...)`.\n   *\n   * Syntax:\n   *\n   *     math.variance(a, b, c, ...)\n   *     math.variance(A)\n   *     math.variance(A, normalization)\n   *     math.variance(A, dimension)\n   *     math.variance(A, dimension, normalization)\n   *\n   * Examples:\n   *\n   *     math.variance(2, 4, 6)                     // returns 4\n   *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667\n   *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5\n   *     math.variance([2, 4, 6, 8], 'biased')      // returns 4\n   *\n   *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]\n   *\n   * See also:\n   *\n   *    mean, median, max, min, prod, std, sum\n   *\n   * @param {Array | Matrix} array\n   *                        A single matrix or or multiple scalar values\n   * @param {string} [normalization='unbiased']\n   *                        Determines how to normalize the variance.\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\n   * @param dimension {number | BigNumber}\n   *                        Determines the axis to compute the variance for a matrix\n   * @return {*} The variance\n   */\n  return typed(name, {\n    // variance([a, b, c, d, ...])\n    'Array | Matrix': function ArrayMatrix(array) {\n      return _var(array, DEFAULT_NORMALIZATION);\n    },\n    // variance([a, b, c, d, ...], normalization)\n    'Array | Matrix, string': _var,\n    // variance([a, b, c, c, ...], dim)\n    'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {\n      return _varDim(array, dim, DEFAULT_NORMALIZATION);\n    },\n    // variance([a, b, c, c, ...], dim, normalization)\n    'Array | Matrix, number | BigNumber, string': _varDim,\n    // variance(a, b, c, d, ...)\n    '...': function _(args) {\n      return _var(args, DEFAULT_NORMALIZATION);\n    }\n  });\n  /**\n   * Recursively calculate the variance of an n-dimensional array\n   * @param {Array} array\n   * @param {string} normalization\n   *                        Determines how to normalize the variance:\n   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)\n   *                        - 'uncorrected' The sum of squared errors is divided by n\n   *                        - 'biased'      The sum of squared errors is divided by (n + 1)\n   * @return {number | BigNumber} variance\n   * @private\n   */\n\n  function _var(array, normalization) {\n    var sum;\n    var num = 0;\n\n    if (array.length === 0) {\n      throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\n    } // calculate the mean and number of elements\n\n\n    (0, _collection.deepForEach)(array, function (value) {\n      try {\n        sum = sum === undefined ? value : add(sum, value);\n        num++;\n      } catch (err) {\n        throw (0, _improveErrorMessage.improveErrorMessage)(err, 'variance', value);\n      }\n    });\n    if (num === 0) throw new Error('Cannot calculate variance of an empty array');\n    var mean = divide(sum, num); // calculate the variance\n\n    sum = undefined;\n    (0, _collection.deepForEach)(array, function (value) {\n      var diff = subtract(value, mean);\n      sum = sum === undefined ? multiply(diff, diff) : add(sum, multiply(diff, diff));\n    });\n\n    if (isNaN(sum)) {\n      return sum;\n    }\n\n    switch (normalization) {\n      case 'uncorrected':\n        return divide(sum, num);\n\n      case 'biased':\n        return divide(sum, num + 1);\n\n      case 'unbiased':\n        {\n          var zero = (0, _is.isBigNumber)(sum) ? sum.mul(0) : 0;\n          return num === 1 ? zero : divide(sum, num - 1);\n        }\n\n      default:\n        throw new Error('Unknown normalization \"' + normalization + '\". ' + 'Choose \"unbiased\" (default), \"uncorrected\", or \"biased\".');\n    }\n  }\n\n  function _varDim(array, dim, normalization) {\n    try {\n      if (array.length === 0) {\n        throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\n      }\n\n      return apply(array, dim, function (x) {\n        return _var(x, normalization);\n      });\n    } catch (err) {\n      throw (0, _improveErrorMessage.improveErrorMessage)(err, 'variance');\n    }\n  }\n});\nexports.createVariance = createVariance;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$collection","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$function$statistics$utils$improveErrorMessage"]],"~:properties",["^5",["createVariance","__esModule","value"]],"~:compiled-at",1619135724023,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$statistics$variance.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/statistics/variance.js\"],\n\"sourcesContent\":[\"shadow$provide[534] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createVariance = void 0;\\n\\nvar _collection = require(\\\"../../utils/collection.js\\\");\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _improveErrorMessage = require(\\\"./utils/improveErrorMessage.js\\\");\\n\\nvar DEFAULT_NORMALIZATION = 'unbiased';\\nvar name = 'variance';\\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];\\nvar createVariance = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      add = _ref.add,\\n      subtract = _ref.subtract,\\n      multiply = _ref.multiply,\\n      divide = _ref.divide,\\n      apply = _ref.apply,\\n      isNaN = _ref.isNaN;\\n\\n  /**\\n   * Compute the variance of a matrix or a  list with values.\\n   * In case of a (multi dimensional) array or matrix, the variance over all\\n   * elements will be calculated.\\n   *\\n   * Additionally, it is possible to compute the variance along the rows\\n   * or columns of a matrix by specifying the dimension as the second argument.\\n   *\\n   * Optionally, the type of normalization can be specified as the final\\n   * parameter. The parameter `normalization` can be one of the following values:\\n   *\\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\\n   * - 'uncorrected'        The sum of squared errors is divided by n\\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\\n   *\\n   *\\n   * Note that older browser may not like the variable name `var`. In that\\n   * case, the function can be called as `math['var'](...)` instead of\\n   * `math.var(...)`.\\n   *\\n   * Syntax:\\n   *\\n   *     math.variance(a, b, c, ...)\\n   *     math.variance(A)\\n   *     math.variance(A, normalization)\\n   *     math.variance(A, dimension)\\n   *     math.variance(A, dimension, normalization)\\n   *\\n   * Examples:\\n   *\\n   *     math.variance(2, 4, 6)                     // returns 4\\n   *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667\\n   *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5\\n   *     math.variance([2, 4, 6, 8], 'biased')      // returns 4\\n   *\\n   *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5\\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]\\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]\\n   *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]\\n   *\\n   * See also:\\n   *\\n   *    mean, median, max, min, prod, std, sum\\n   *\\n   * @param {Array | Matrix} array\\n   *                        A single matrix or or multiple scalar values\\n   * @param {string} [normalization='unbiased']\\n   *                        Determines how to normalize the variance.\\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\\n   * @param dimension {number | BigNumber}\\n   *                        Determines the axis to compute the variance for a matrix\\n   * @return {*} The variance\\n   */\\n  return typed(name, {\\n    // variance([a, b, c, d, ...])\\n    'Array | Matrix': function ArrayMatrix(array) {\\n      return _var(array, DEFAULT_NORMALIZATION);\\n    },\\n    // variance([a, b, c, d, ...], normalization)\\n    'Array | Matrix, string': _var,\\n    // variance([a, b, c, c, ...], dim)\\n    'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {\\n      return _varDim(array, dim, DEFAULT_NORMALIZATION);\\n    },\\n    // variance([a, b, c, c, ...], dim, normalization)\\n    'Array | Matrix, number | BigNumber, string': _varDim,\\n    // variance(a, b, c, d, ...)\\n    '...': function _(args) {\\n      return _var(args, DEFAULT_NORMALIZATION);\\n    }\\n  });\\n  /**\\n   * Recursively calculate the variance of an n-dimensional array\\n   * @param {Array} array\\n   * @param {string} normalization\\n   *                        Determines how to normalize the variance:\\n   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)\\n   *                        - 'uncorrected' The sum of squared errors is divided by n\\n   *                        - 'biased'      The sum of squared errors is divided by (n + 1)\\n   * @return {number | BigNumber} variance\\n   * @private\\n   */\\n\\n  function _var(array, normalization) {\\n    var sum;\\n    var num = 0;\\n\\n    if (array.length === 0) {\\n      throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\\n    } // calculate the mean and number of elements\\n\\n\\n    (0, _collection.deepForEach)(array, function (value) {\\n      try {\\n        sum = sum === undefined ? value : add(sum, value);\\n        num++;\\n      } catch (err) {\\n        throw (0, _improveErrorMessage.improveErrorMessage)(err, 'variance', value);\\n      }\\n    });\\n    if (num === 0) throw new Error('Cannot calculate variance of an empty array');\\n    var mean = divide(sum, num); // calculate the variance\\n\\n    sum = undefined;\\n    (0, _collection.deepForEach)(array, function (value) {\\n      var diff = subtract(value, mean);\\n      sum = sum === undefined ? multiply(diff, diff) : add(sum, multiply(diff, diff));\\n    });\\n\\n    if (isNaN(sum)) {\\n      return sum;\\n    }\\n\\n    switch (normalization) {\\n      case 'uncorrected':\\n        return divide(sum, num);\\n\\n      case 'biased':\\n        return divide(sum, num + 1);\\n\\n      case 'unbiased':\\n        {\\n          var zero = (0, _is.isBigNumber)(sum) ? sum.mul(0) : 0;\\n          return num === 1 ? zero : divide(sum, num - 1);\\n        }\\n\\n      default:\\n        throw new Error('Unknown normalization \\\"' + normalization + '\\\". ' + 'Choose \\\"unbiased\\\" (default), \\\"uncorrected\\\", or \\\"biased\\\".');\\n    }\\n  }\\n\\n  function _varDim(array, dim, normalization) {\\n    try {\\n      if (array.length === 0) {\\n        throw new SyntaxError('Function variance requires one or more parameters (0 provided)');\\n      }\\n\\n      return apply(array, dim, function (x) {\\n        return _var(x, normalization);\\n      });\\n    } catch (err) {\\n      throw (0, _improveErrorMessage.improveErrorMessage)(err, 'variance');\\n    }\\n  }\\n});\\nexports.createVariance = createVariance;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createVariance\",\"_collection\",\"_is\",\"_factory\",\"_improveErrorMessage\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_var\",\"array\",\"normalization\",\"num\",\"length\",\"SyntaxError\",\"deepForEach\",\"sum\",\"undefined\",\"add\",\"err\",\"improveErrorMessage\",\"Error\",\"mean\",\"divide\",\"diff\",\"subtract\",\"multiply\",\"isNaN\",\"zero\",\"isBigNumber\",\"mul\",\"_varDim\",\"dim\",\"apply\",\"x\",\"typed\",\"ArrayMatrix\",\"DEFAULT_NORMALIZATION\",\"ArrayMatrixNumberBigNumber\",\"_\",\"args\"]\n}\n"]