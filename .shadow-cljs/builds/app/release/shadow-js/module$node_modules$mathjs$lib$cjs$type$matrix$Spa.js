["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/matrix/Spa.js"],"~:js","shadow$provide[201]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSpaClass=void 0;c=b(25);c=(0,c.factory)(\"Spa\",[\"addScalar\",\"equalScalar\",\"FibonacciHeap\"],function(q){function f(){if(!(this instanceof f))throw new SyntaxError(\"Constructor must be called with the new operator\");this._values=[];this._heap=new t}var u=q.addScalar,k=q.equalScalar,t=q.FibonacciHeap;f.prototype.type=\"Spa\";f.prototype.isSpa=!0;f.prototype.set=function(p,g){this._values[p]?this._values[p].value=\ng:(g=this._heap.insert(p,g),this._values[p]=g)};f.prototype.get=function(p){return(p=this._values[p])?p.value:0};f.prototype.accumulate=function(p,g){var d=this._values[p];d?d.value=u(d.value,g):(d=this._heap.insert(p,g),this._values[p]=d)};f.prototype.forEach=function(p,g,d){var l=this._heap,h=this._values,n=[],r=l.extractMinimum();for(r&&n.push(r);r&&r.key<=g;)r.key>=p&&(k(r.value,0)||d(r.key,r.value,this)),(r=l.extractMinimum())&&n.push(r);for(p=0;p<n.length;p++)r=n[p],r=l.insert(r.key,r.value),\nh[r.key]=r};f.prototype.swap=function(p,g){var d=this._values[p],l=this._values[g];!d&&l?(d=this._heap.insert(p,l.value),this._heap.remove(l),this._values[p]=d,this._values[g]=void 0):d&&!l?(l=this._heap.insert(g,d.value),this._heap.remove(d),this._values[g]=l,this._values[p]=void 0):d&&l&&(p=d.value,d.value=l.value,l.value=p)};return f},{isClass:!0});a.createSpaClass=c}","~:source","shadow$provide[201] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSpaClass = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Spa';\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\nvar createSpaClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var addScalar = _ref.addScalar,\n      equalScalar = _ref.equalScalar,\n      FibonacciHeap = _ref.FibonacciHeap;\n\n  /**\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\n   * of the vector elements and an ordered list of non-zero elements.\n   */\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // allocate vector, TODO use typed arrays\n\n\n    this._values = [];\n    this._heap = new FibonacciHeap();\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n  /**\n   * Set the value for index i.\n   *\n   * @param {number} i                       The index\n   * @param {number | BigNumber | Complex}   The value at index i\n   */\n\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v); // set the value @ i\n\n\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n\n    if (node) {\n      return node.value;\n    }\n\n    return 0;\n  };\n\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v); // initialize value\n\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = addScalar(node.value, v);\n    }\n  };\n\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values; // nodes\n\n    var nodes = []; // node with minimum key, save it\n\n    var node = heap.extractMinimum();\n\n    if (node) {\n      nodes.push(node);\n    } // extract nodes from heap (ordered)\n\n\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      } // extract next node, save it\n\n\n      node = heap.extractMinimum();\n\n      if (node) {\n        nodes.push(node);\n      }\n    } // reinsert all nodes in heap\n\n\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i]; // insert node in heap\n\n      node = heap.insert(n.key, n.value); // update values\n\n      values[node.key] = node;\n    }\n  };\n\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j]; // check we need to insert indeces\n\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\n\n      this._heap.remove(nodej); // set values\n\n\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\n\n      this._heap.remove(nodei); // set values\n\n\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n\n  return Spa;\n}, {\n  isClass: true\n});\nexports.createSpaClass = createSpaClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["forEach","isClass","__esModule","isSpa","value","_values","createSpaClass","type","accumulate","set","_heap","get","swap"]],"~:compiled-at",1619135723926,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$matrix$Spa.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,cAAR,CAAyB,IAAK,EAE1BC,EAAAA,CAAWP,CAAA,CAAQ,EAAR,CAIXM,EAAAA,CAAgC,CAAC,CAAA,CAAGC,CAASC,CAAAA,OAAb,EAFzBC,KAEyB,CADjBC,CAAC,WAADA,CAAc,aAAdA,CAA6B,eAA7BA,CACiB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAS5FC,QAASA,EAAG,EAAG,CACb,GAAI,EAAE,IAAF,WAAkBA,EAAlB,CAAJ,CACE,KAAM,KAAIC,WAAJ,CAAgB,kDAAhB,CAAN,CAIF,IAAKC,CAAAA,OAAL,CAAe,EACf,KAAKC,CAAAA,KAAL,CAAa,IAAIC,CAPJ,CAT6E,IACxFC,EAAYN,CAAKM,CAAAA,SADuE,CAExFC,EAAcP,CAAKO,CAAAA,WAFqE,CAGxFF,EAAgBL,CAAKK,CAAAA,aAoBzBJ,EAAIO,CAAAA,SAAUC,CAAAA,IAAd,CAAqB,KACrBR,EAAIO,CAAAA,SAAUE,CAAAA,KAAd,CAAsB,CAAA,CAQtBT,EAAIO,CAAAA,SAAUG,CAAAA,GAAd,CAAoBC,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAE7B,IAAKX,CAAAA,OAAL,CAAaU,CAAb,CAAL,CAQE,IAAKV,CAAAA,OAAL,CAAaU,CAAb,CAAgBnB,CAAAA,KARlB;AAQ0BoB,CAR1B,EAEMC,CAGJ,CAHW,IAAKX,CAAAA,KAAMY,CAAAA,MAAX,CAAkBH,CAAlB,CAAqBC,CAArB,CAGX,CAAA,IAAKX,CAAAA,OAAL,CAAaU,CAAb,CAAA,CAAkBE,CALpB,CAFkC,CAcpCd,EAAIO,CAAAA,SAAUS,CAAAA,GAAd,CAAoBC,QAAS,CAACL,CAAD,CAAI,CAG/B,MAAA,CAFIE,CAEJ,CAFW,IAAKZ,CAAAA,OAAL,CAAaU,CAAb,CAEX,EACSE,CAAKrB,CAAAA,KADd,CAIO,CAPwB,CAUjCO,EAAIO,CAAAA,SAAUW,CAAAA,UAAd,CAA2BC,QAAS,CAACP,CAAD,CAAIC,CAAJ,CAAO,CAEzC,IAAIC,EAAO,IAAKZ,CAAAA,OAAL,CAAaU,CAAb,CAENE,EAAL,CAOEA,CAAKrB,CAAAA,KAPP,CAOeY,CAAA,CAAUS,CAAKrB,CAAAA,KAAf,CAAsBoB,CAAtB,CAPf,EAEEC,CAEA,CAFO,IAAKX,CAAAA,KAAMY,CAAAA,MAAX,CAAkBH,CAAlB,CAAqBC,CAArB,CAEP,CAAA,IAAKX,CAAAA,OAAL,CAAaU,CAAb,CAAA,CAAkBE,CAJpB,CAJyC,CAe3Cd,EAAIO,CAAAA,SAAUa,CAAAA,OAAd,CAAwBC,QAAS,CAACC,CAAD,CAAOC,CAAP,CAAWC,CAAX,CAAqB,CAEpD,IAAIC,EAAO,IAAKtB,CAAAA,KAAhB,CACIuB,EAAS,IAAKxB,CAAAA,OADlB,CAGIyB,EAAQ,EAHZ,CAKIb,EAAOW,CAAKG,CAAAA,cAAL,EAOX,KALId,CAKJ,EAJEa,CAAME,CAAAA,IAAN,CAAWf,CAAX,CAIF,CAAOA,CAAP,EAAeA,CAAKgB,CAAAA,GAApB,EAA2BP,CAA3B,CAAA,CAEMT,CAAKgB,CAAAA,GAWT,EAXgBR,CAWhB,GATOhB,CAAA,CAAYQ,CAAKrB,CAAAA,KAAjB,CAAwB,CAAxB,CASP,EAPI+B,CAAA,CAASV,CAAKgB,CAAAA,GAAd,CAAmBhB,CAAKrB,CAAAA,KAAxB,CAA+B,IAA/B,CAOJ,GAFAqB,CAEA,CAFOW,CAAKG,CAAAA,cAAL,EAEP,GACED,CAAME,CAAAA,IAAN,CAAWf,CAAX,CAKJ,KAASF,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoBe,CAAMI,CAAAA,MAA1B,CAAkCnB,CAAA,EAAlC,CAEMoB,CAIJ,CAJQL,CAAA,CAAMf,CAAN,CAIR,CAFAE,CAEA,CAFOW,CAAKV,CAAAA,MAAL,CAAYiB,CAAEF,CAAAA,GAAd,CAAmBE,CAAEvC,CAAAA,KAArB,CAEP;AAAAiC,CAAA,CAAOZ,CAAKgB,CAAAA,GAAZ,CAAA,CAAmBhB,CAvC+B,CA2CtDd,EAAIO,CAAAA,SAAU0B,CAAAA,IAAd,CAAqBC,QAAS,CAACtB,CAAD,CAAIuB,CAAJ,CAAO,CAEnC,IAAIC,EAAQ,IAAKlC,CAAAA,OAAL,CAAaU,CAAb,CAAZ,CACIyB,EAAQ,IAAKnC,CAAAA,OAAL,CAAaiC,CAAb,CAER,EAACC,CAAL,EAAcC,CAAd,EAEED,CAMA,CANQ,IAAKjC,CAAAA,KAAMY,CAAAA,MAAX,CAAkBH,CAAlB,CAAqByB,CAAM5C,CAAAA,KAA3B,CAMR,CAJA,IAAKU,CAAAA,KAAMmC,CAAAA,MAAX,CAAkBD,CAAlB,CAIA,CADA,IAAKnC,CAAAA,OAAL,CAAaU,CAAb,CACA,CADkBwB,CAClB,CAAA,IAAKlC,CAAAA,OAAL,CAAaiC,CAAb,CAAA,CAAkBI,IAAAA,EARpB,EASWH,CAAJ,EAAa,CAACC,CAAd,EAELA,CAMA,CANQ,IAAKlC,CAAAA,KAAMY,CAAAA,MAAX,CAAkBoB,CAAlB,CAAqBC,CAAM3C,CAAAA,KAA3B,CAMR,CAJA,IAAKU,CAAAA,KAAMmC,CAAAA,MAAX,CAAkBF,CAAlB,CAIA,CADA,IAAKlC,CAAAA,OAAL,CAAaiC,CAAb,CACA,CADkBE,CAClB,CAAA,IAAKnC,CAAAA,OAAL,CAAaU,CAAb,CAAA,CAAkB2B,IAAAA,EARb,EASIH,CATJ,EASaC,CATb,GAWDxB,CAEJ,CAFQuB,CAAM3C,CAAAA,KAEd,CADA2C,CAAM3C,CAAAA,KACN,CADc4C,CAAM5C,CAAAA,KACpB,CAAA4C,CAAM5C,CAAAA,KAAN,CAAcoB,CAbT,CAd4B,CA+BrC,OAAOb,EAjJqF,CAA1D,CAkJjC,CACDwC,QAAS,CAAA,CADR,CAlJiC,CAqJpClD,EAAQI,CAAAA,cAAR,CAAyBA,CAjKqC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/matrix/Spa.js\"],\n\"sourcesContent\":[\"shadow$provide[201] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSpaClass = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'Spa';\\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\\nvar createSpaClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var addScalar = _ref.addScalar,\\n      equalScalar = _ref.equalScalar,\\n      FibonacciHeap = _ref.FibonacciHeap;\\n\\n  /**\\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\\n   * of the vector elements and an ordered list of non-zero elements.\\n   */\\n  function Spa() {\\n    if (!(this instanceof Spa)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // allocate vector, TODO use typed arrays\\n\\n\\n    this._values = [];\\n    this._heap = new FibonacciHeap();\\n  }\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  Spa.prototype.type = 'Spa';\\n  Spa.prototype.isSpa = true;\\n  /**\\n   * Set the value for index i.\\n   *\\n   * @param {number} i                       The index\\n   * @param {number | BigNumber | Complex}   The value at index i\\n   */\\n\\n  Spa.prototype.set = function (i, v) {\\n    // check we have a value @ i\\n    if (!this._values[i]) {\\n      // insert in heap\\n      var node = this._heap.insert(i, v); // set the value @ i\\n\\n\\n      this._values[i] = node;\\n    } else {\\n      // update the value @ i\\n      this._values[i].value = v;\\n    }\\n  };\\n\\n  Spa.prototype.get = function (i) {\\n    var node = this._values[i];\\n\\n    if (node) {\\n      return node.value;\\n    }\\n\\n    return 0;\\n  };\\n\\n  Spa.prototype.accumulate = function (i, v) {\\n    // node @ i\\n    var node = this._values[i];\\n\\n    if (!node) {\\n      // insert in heap\\n      node = this._heap.insert(i, v); // initialize value\\n\\n      this._values[i] = node;\\n    } else {\\n      // accumulate value\\n      node.value = addScalar(node.value, v);\\n    }\\n  };\\n\\n  Spa.prototype.forEach = function (from, to, callback) {\\n    // references\\n    var heap = this._heap;\\n    var values = this._values; // nodes\\n\\n    var nodes = []; // node with minimum key, save it\\n\\n    var node = heap.extractMinimum();\\n\\n    if (node) {\\n      nodes.push(node);\\n    } // extract nodes from heap (ordered)\\n\\n\\n    while (node && node.key <= to) {\\n      // check it is in range\\n      if (node.key >= from) {\\n        // check value is not zero\\n        if (!equalScalar(node.value, 0)) {\\n          // invoke callback\\n          callback(node.key, node.value, this);\\n        }\\n      } // extract next node, save it\\n\\n\\n      node = heap.extractMinimum();\\n\\n      if (node) {\\n        nodes.push(node);\\n      }\\n    } // reinsert all nodes in heap\\n\\n\\n    for (var i = 0; i < nodes.length; i++) {\\n      // current node\\n      var n = nodes[i]; // insert node in heap\\n\\n      node = heap.insert(n.key, n.value); // update values\\n\\n      values[node.key] = node;\\n    }\\n  };\\n\\n  Spa.prototype.swap = function (i, j) {\\n    // node @ i and j\\n    var nodei = this._values[i];\\n    var nodej = this._values[j]; // check we need to insert indeces\\n\\n    if (!nodei && nodej) {\\n      // insert in heap\\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\\n\\n      this._heap.remove(nodej); // set values\\n\\n\\n      this._values[i] = nodei;\\n      this._values[j] = undefined;\\n    } else if (nodei && !nodej) {\\n      // insert in heap\\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\\n\\n      this._heap.remove(nodei); // set values\\n\\n\\n      this._values[j] = nodej;\\n      this._values[i] = undefined;\\n    } else if (nodei && nodej) {\\n      // swap values\\n      var v = nodei.value;\\n      nodei.value = nodej.value;\\n      nodej.value = v;\\n    }\\n  };\\n\\n  return Spa;\\n}, {\\n  isClass: true\\n});\\nexports.createSpaClass = createSpaClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSpaClass\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"Spa\",\"SyntaxError\",\"_values\",\"_heap\",\"FibonacciHeap\",\"addScalar\",\"equalScalar\",\"prototype\",\"type\",\"isSpa\",\"set\",\"Spa.prototype.set\",\"i\",\"v\",\"node\",\"insert\",\"get\",\"Spa.prototype.get\",\"accumulate\",\"Spa.prototype.accumulate\",\"forEach\",\"Spa.prototype.forEach\",\"from\",\"to\",\"callback\",\"heap\",\"values\",\"nodes\",\"extractMinimum\",\"push\",\"key\",\"length\",\"n\",\"swap\",\"Spa.prototype.swap\",\"j\",\"nodei\",\"nodej\",\"remove\",\"undefined\",\"isClass\"]\n}\n"]