["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/solver/lusolve.js"],"~:js","shadow$provide[297]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createLusolve=void 0;var q=b(14);c=b(25);var f=b(172),u=b(296);b=(0,c.factory)(\"lusolve\",\"typed matrix lup slu usolve lsolve DenseMatrix\".split(\" \"),function(k){function t(C){if((0,q.isMatrix)(C))return C;if((0,q.isArray)(C))return d(C);throw new TypeError(\"Invalid Matrix LU decomposition\");}function p(C,z,w,B,x){C=t(C);z=t(z);w&&(x=v(C,x,!0),x._data=(0,u.csIpvec)(w,x._data));C=r(C,x);z=n(z,C);B&&(z._data=(0,\nu.csIpvec)(B,z._data));return z}var g=k.typed,d=k.matrix,l=k.lup,h=k.slu,n=k.usolve,r=k.lsolve;k=k.DenseMatrix;var v=(0,f.createSolveValidation)({DenseMatrix:k});return g(\"lusolve\",{\"Array, Array | Matrix\":function(C,z){C=d(C);C=l(C);return p(C.L,C.U,C.p,null,z).valueOf()},\"DenseMatrix, Array | Matrix\":function(C,z){C=l(C);return p(C.L,C.U,C.p,null,z)},\"SparseMatrix, Array | Matrix\":function(C,z){C=l(C);return p(C.L,C.U,C.p,null,z)},\"SparseMatrix, Array | Matrix, number, number\":function(C,z,w,B){C=\nh(C,w,B);return p(C.L,C.U,C.p,C.q,z)},\"Object, Array | Matrix\":function(C,z){return p(C.L,C.U,C.p,C.q,z)}})});a.createLusolve=b}","~:source","shadow$provide[297] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLusolve = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar _csIpvec = require(\"../sparse/csIpvec.js\");\n\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nvar createLusolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      lup = _ref.lup,\n      slu = _ref.slu,\n      usolve = _ref.usolve,\n      lsolve = _ref.lsolve,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  return typed(name, {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      a = matrix(a);\n      var d = lup(a);\n\n      var x = _lusolve(d.L, d.U, d.p, null, b);\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      var d = slu(a, order, threshold);\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  function _toMatrix(a) {\n    if ((0, _is.isMatrix)(a)) {\n      return a;\n    }\n\n    if ((0, _is.isArray)(a)) {\n      return matrix(a);\n    }\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n\n  function _lusolve(l, u, p, q, b) {\n    // verify decomposition\n    l = _toMatrix(l);\n    u = _toMatrix(u); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b = solveValidation(l, b, true);\n      b._data = (0, _csIpvec.csIpvec)(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = (0, _csIpvec.csIpvec)(q, x._data);\n    }\n\n    return x;\n  }\n});\nexports.createLusolve = createLusolve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csIpvec"]],"~:properties",["^5",["DenseMatrix","__esModule","_data","value","createLusolve"]],"~:compiled-at",1619135723981,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$lusolve.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/solver/lusolve.js\"],\n\"sourcesContent\":[\"shadow$provide[297] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createLusolve = void 0;\\n\\nvar _is = require(\\\"../../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _solveValidation = require(\\\"./utils/solveValidation.js\\\");\\n\\nvar _csIpvec = require(\\\"../sparse/csIpvec.js\\\");\\n\\nvar name = 'lusolve';\\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\\nvar createLusolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      lup = _ref.lup,\\n      slu = _ref.slu,\\n      usolve = _ref.usolve,\\n      lsolve = _ref.lsolve,\\n      DenseMatrix = _ref.DenseMatrix;\\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\\n    DenseMatrix: DenseMatrix\\n  });\\n  /**\\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\\n   *\\n   * Syntax:\\n   *\\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\\n   *\\n   * Examples:\\n   *\\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\\n   *\\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\\n   *\\n   *    const f = math.lup(m)\\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\\n   *\\n   *    const a = [[-2, 3], [2, 1]]\\n   *    const b = [11, 9]\\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\\n   *\\n   * See also:\\n   *\\n   *    lup, slu, lsolve, usolve\\n   *\\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\\n   * @param {Matrix | Array} b               Column Vector\\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\\n   *\\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\\n   */\\n\\n  return typed(name, {\\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\\n      a = matrix(a);\\n      var d = lup(a);\\n\\n      var x = _lusolve(d.L, d.U, d.p, null, b);\\n\\n      return x.valueOf();\\n    },\\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\\n      var d = lup(a);\\n      return _lusolve(d.L, d.U, d.p, null, b);\\n    },\\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\\n      var d = lup(a);\\n      return _lusolve(d.L, d.U, d.p, null, b);\\n    },\\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\\n      var d = slu(a, order, threshold);\\n      return _lusolve(d.L, d.U, d.p, d.q, b);\\n    },\\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\\n      return _lusolve(d.L, d.U, d.p, d.q, b);\\n    }\\n  });\\n\\n  function _toMatrix(a) {\\n    if ((0, _is.isMatrix)(a)) {\\n      return a;\\n    }\\n\\n    if ((0, _is.isArray)(a)) {\\n      return matrix(a);\\n    }\\n\\n    throw new TypeError('Invalid Matrix LU decomposition');\\n  }\\n\\n  function _lusolve(l, u, p, q, b) {\\n    // verify decomposition\\n    l = _toMatrix(l);\\n    u = _toMatrix(u); // apply row permutations if needed (b is a DenseMatrix)\\n\\n    if (p) {\\n      b = solveValidation(l, b, true);\\n      b._data = (0, _csIpvec.csIpvec)(p, b._data);\\n    } // use forward substitution to resolve L * y = b\\n\\n\\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\\n\\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\\n\\n    if (q) {\\n      x._data = (0, _csIpvec.csIpvec)(q, x._data);\\n    }\\n\\n    return x;\\n  }\\n});\\nexports.createLusolve = createLusolve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createLusolve\",\"_is\",\"_factory\",\"_solveValidation\",\"_csIpvec\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_toMatrix\",\"a\",\"isMatrix\",\"isArray\",\"matrix\",\"TypeError\",\"_lusolve\",\"l\",\"u\",\"p\",\"q\",\"b\",\"solveValidation\",\"_data\",\"csIpvec\",\"y\",\"lsolve\",\"x\",\"usolve\",\"typed\",\"lup\",\"slu\",\"DenseMatrix\",\"createSolveValidation\",\"ArrayArrayMatrix\",\"d\",\"L\",\"U\",\"valueOf\",\"DenseMatrixArrayMatrix\",\"SparseMatrixArrayMatrix\",\"SparseMatrixArrayMatrixNumberNumber\",\"order\",\"threshold\",\"ObjectArrayMatrix\"]\n}\n"]