["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/Node.js"],"~:js","shadow$provide[249]=function(c,b,y,a){function q(t){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(p){return typeof p}:function(p){return p&&\"function\"===typeof Symbol&&p.constructor===Symbol&&p!==Symbol.prototype?\"symbol\":typeof p};return q(t)}Object.defineProperty(a,\"__esModule\",{value:!0});a.createNode=void 0;var f=b(14),u=b(248),k=b(15);c=b(25);c=(0,c.factory)(\"Node\",[\"mathWithTransform\"],function(t){function p(){if(!(this instanceof p))throw new SyntaxError(\"Constructor must be called with the new operator\");\n}var g=t.mathWithTransform;p.prototype.evaluate=function(d){return this.compile().evaluate(d)};p.prototype.type=\"Node\";p.prototype.isNode=!0;p.prototype.comment=\"\";p.prototype.compile=function(){var d=this._compile(g,{}),l={};return{evaluate:function(h){h=h||{};for(var n in h)if((0,k.hasOwnProperty)(h,n)&&n in u.keywords)throw Error('Scope contains an illegal symbol, \"'+n+'\" is a reserved keyword');return d(h,l,null)}}};p.prototype._compile=function(d,l){throw Error(\"Method _compile should be implemented by type \"+\nthis.type);};p.prototype.forEach=function(d){throw Error(\"Cannot run forEach on a Node interface\");};p.prototype.map=function(d){throw Error(\"Cannot run map on a Node interface\");};p.prototype._ifNode=function(d){if(!(0,f.isNode)(d))throw new TypeError(\"Callback function must return a Node\");return d};p.prototype.traverse=function(d){function l(h,n){h.forEach(function(r,v,C){n(r,v,C);l(r,n)})}d(this,null,null);l(this,d)};p.prototype.transform=function(d){function l(h,n,r){n=d(h,n,r);return n!==h?\nn:h.map(l)}return l(this,null,null)};p.prototype.filter=function(d){var l=[];this.traverse(function(h,n,r){d(h,n,r)&&l.push(h)});return l};p.prototype.clone=function(){throw Error(\"Cannot clone a Node interface\");};p.prototype.cloneDeep=function(){return this.map(function(d){return d.cloneDeep()})};p.prototype.equals=function(d){return d?(0,k.deepStrictEqual)(this,d):!1};p.prototype.toString=function(d){var l=this._getCustomString(d);return\"undefined\"!==typeof l?l:this._toString(d)};p.prototype.toJSON=\nfunction(){throw Error(\"Cannot serialize object: toJSON not implemented by \"+this.type);};p.prototype.toHTML=function(d){var l=this._getCustomString(d);return\"undefined\"!==typeof l?l:this.toHTML(d)};p.prototype._toString=function(){throw Error(\"_toString not implemented for \"+this.type);};p.prototype.toTex=function(d){var l=this._getCustomString(d);return\"undefined\"!==typeof l?l:this._toTex(d)};p.prototype._toTex=function(d){throw Error(\"_toTex not implemented for \"+this.type);};p.prototype._getCustomString=\nfunction(d){if(d&&\"object\"===q(d))switch(q(d.handler)){case \"object\":case \"undefined\":break;case \"function\":return d.handler(this,d);default:throw new TypeError(\"Object or function expected as callback\");}};p.prototype.getIdentifier=function(){return this.type};p.prototype.getContent=function(){return this};return p},{isClass:!0,isNode:!0});a.createNode=c}","~:source","shadow$provide[249] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _keywords = require(\"../keywords.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nvar createNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n\n  /**\n   * Node\n   */\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\n   * Compile the node into an optimized, evauatable JavaScript function\n   * @return {{evaluate: function([Object])}} object\n   *                Returns an object with a function 'evaluate',\n   *                which can be invoked as expr.evaluate([scope: Object]),\n   *                where scope is an optional object with\n   *                variables.\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n\n    var args = {};\n    var context = null;\n\n    function evaluate(scope) {\n      var s = scope || {};\n\n      _validateScope(s);\n\n      return expr(s, args, context);\n    }\n\n    return {\n      evaluate: evaluate\n    };\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n\n\n  Node.prototype._ifNode = function (node) {\n    if (!(0, _is.isNode)(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    // eslint-disable-next-line\n    callback(this, null, null); // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     const res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n   *         return new ConstantNode(2)\n   *       }\n   *       else {\n   *         return node\n   *       }\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n\n      return child.map(_transform);\n    }\n\n    return _transform(this, null, null);\n  };\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     const results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n\n\n  Node.prototype.equals = function (other) {\n    return other ? (0, _object.deepStrictEqual)(this, other) : false;\n  };\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toString = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n   * implementations of Node\n   * @returns {Object}\n   */\n\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toHTML = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toTex = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toTex(options);\n  };\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\n   * Helper used by `to...` functions.\n   */\n\n\n  Node.prototype._getCustomString = function (options) {\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          return;\n\n        case 'function':\n          return options.handler(this, options);\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n\n  function _validateScope(scope) {\n    for (var symbol in scope) {\n      if ((0, _object.hasOwnProperty)(scope, symbol)) {\n        if (symbol in _keywords.keywords) {\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n        }\n      }\n    }\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createNode = createNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$expression$keywords","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","forEach","isClass","toHTML","_toString","isNode","_toTex","__esModule","_getCustomString","transform","toString","value","traverse","evaluate","getIdentifier","cloneDeep","toTex","filter","compile","createNode","type","_ifNode","clone","comment","_compile","equals","getContent","toJSON"]],"~:compiled-at",1619135723954,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$Node.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/Node.js\"],\n\"sourcesContent\":[\"shadow$provide[249] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _keywords = require(\\\"../keywords.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nvar name = 'Node';\\nvar dependencies = ['mathWithTransform'];\\nvar createNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var mathWithTransform = _ref.mathWithTransform;\\n\\n  /**\\n   * Node\\n   */\\n  function Node() {\\n    if (!(this instanceof Node)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n  }\\n  /**\\n   * Evaluate the node\\n   * @param {Object} [scope]  Scope to read/write variables\\n   * @return {*}              Returns the result\\n   */\\n\\n\\n  Node.prototype.evaluate = function (scope) {\\n    return this.compile().evaluate(scope);\\n  };\\n\\n  Node.prototype.type = 'Node';\\n  Node.prototype.isNode = true;\\n  Node.prototype.comment = '';\\n  /**\\n   * Compile the node into an optimized, evauatable JavaScript function\\n   * @return {{evaluate: function([Object])}} object\\n   *                Returns an object with a function 'evaluate',\\n   *                which can be invoked as expr.evaluate([scope: Object]),\\n   *                where scope is an optional object with\\n   *                variables.\\n   */\\n\\n  Node.prototype.compile = function () {\\n    var expr = this._compile(mathWithTransform, {});\\n\\n    var args = {};\\n    var context = null;\\n\\n    function evaluate(scope) {\\n      var s = scope || {};\\n\\n      _validateScope(s);\\n\\n      return expr(s, args, context);\\n    }\\n\\n    return {\\n      evaluate: evaluate\\n    };\\n  };\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n\\n  Node.prototype._compile = function (math, argNames) {\\n    throw new Error('Method _compile should be implemented by type ' + this.type);\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  Node.prototype.forEach = function (callback) {\\n    // must be implemented by each of the Node implementations\\n    throw new Error('Cannot run forEach on a Node interface');\\n  };\\n  /**\\n   * Create a new Node having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {OperatorNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  Node.prototype.map = function (callback) {\\n    // must be implemented by each of the Node implementations\\n    throw new Error('Cannot run map on a Node interface');\\n  };\\n  /**\\n   * Validate whether an object is a Node, for use with map\\n   * @param {Node} node\\n   * @returns {Node} Returns the input if it's a node, else throws an Error\\n   * @protected\\n   */\\n\\n\\n  Node.prototype._ifNode = function (node) {\\n    if (!(0, _is.isNode)(node)) {\\n      throw new TypeError('Callback function must return a Node');\\n    }\\n\\n    return node;\\n  };\\n  /**\\n   * Recursively traverse all nodes in a node tree. Executes given callback for\\n   * this node and each of its child nodes.\\n   * @param {function(node: Node, path: string, parent: Node)} callback\\n   *          A callback called for every node in the node tree.\\n   */\\n\\n\\n  Node.prototype.traverse = function (callback) {\\n    // execute callback for itself\\n    // eslint-disable-next-line\\n    callback(this, null, null); // recursively traverse over all childs of a node\\n\\n    function _traverse(node, callback) {\\n      node.forEach(function (child, path, parent) {\\n        callback(child, path, parent);\\n\\n        _traverse(child, callback);\\n      });\\n    }\\n\\n    _traverse(this, callback);\\n  };\\n  /**\\n   * Recursively transform a node tree via a transform function.\\n   *\\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\\n   * ConstantNode with value 2:\\n   *\\n   *     const res = Node.transform(function (node, path, parent) {\\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\\n   *         return new ConstantNode(2)\\n   *       }\\n   *       else {\\n   *         return node\\n   *       }\\n   *     })\\n   *\\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\\n   *          A mapping function accepting a node, and returning\\n   *          a replacement for the node or the original node.\\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\\n   * @return {Node} Returns the original node or its replacement\\n   */\\n\\n\\n  Node.prototype.transform = function (callback) {\\n    function _transform(child, path, parent) {\\n      var replacement = callback(child, path, parent);\\n\\n      if (replacement !== child) {\\n        // stop iterating when the node is replaced\\n        return replacement;\\n      }\\n\\n      return child.map(_transform);\\n    }\\n\\n    return _transform(this, null, null);\\n  };\\n  /**\\n   * Find any node in the node tree matching given filter function. For example, to\\n   * find all nodes of type SymbolNode having name 'x':\\n   *\\n   *     const results = Node.filter(function (node) {\\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\\n   *     })\\n   *\\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\\n   *            A test function returning true when a node matches, and false\\n   *            otherwise. Function signature:\\n   *            callback(node: Node, index: string, parent: Node) : boolean\\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\\n   */\\n\\n\\n  Node.prototype.filter = function (callback) {\\n    var nodes = [];\\n    this.traverse(function (node, path, parent) {\\n      if (callback(node, path, parent)) {\\n        nodes.push(node);\\n      }\\n    });\\n    return nodes;\\n  };\\n  /**\\n   * Create a shallow clone of this node\\n   * @return {Node}\\n   */\\n\\n\\n  Node.prototype.clone = function () {\\n    // must be implemented by each of the Node implementations\\n    throw new Error('Cannot clone a Node interface');\\n  };\\n  /**\\n   * Create a deep clone of this node\\n   * @return {Node}\\n   */\\n\\n\\n  Node.prototype.cloneDeep = function () {\\n    return this.map(function (node) {\\n      return node.cloneDeep();\\n    });\\n  };\\n  /**\\n   * Deep compare this node with another node.\\n   * @param {Node} other\\n   * @return {boolean} Returns true when both nodes are of the same type and\\n   *                   contain the same values (as do their childs)\\n   */\\n\\n\\n  Node.prototype.equals = function (other) {\\n    return other ? (0, _object.deepStrictEqual)(this, other) : false;\\n  };\\n  /**\\n   * Get string representation. (wrapper function)\\n   *\\n   * This function can get an object of the following form:\\n   * {\\n   *    handler: //This can be a callback function of the form\\n   *             // \\\"function callback(node, options)\\\"or\\n   *             // a map that maps function names (used in FunctionNodes)\\n   *             // to callbacks\\n   *    parenthesis: \\\"keep\\\" //the parenthesis option (This is optional)\\n   * }\\n   *\\n   * @param {Object} [options]\\n   * @return {string}\\n   */\\n\\n\\n  Node.prototype.toString = function (options) {\\n    var customString = this._getCustomString(options);\\n\\n    if (typeof customString !== 'undefined') {\\n      return customString;\\n    }\\n\\n    return this._toString(options);\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\\n   * implementations of Node\\n   * @returns {Object}\\n   */\\n\\n\\n  Node.prototype.toJSON = function () {\\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\\n  };\\n  /**\\n   * Get HTML representation. (wrapper function)\\n   *\\n   * This function can get an object of the following form:\\n   * {\\n   *    handler: //This can be a callback function of the form\\n   *             // \\\"function callback(node, options)\\\" or\\n   *             // a map that maps function names (used in FunctionNodes)\\n   *             // to callbacks\\n   *    parenthesis: \\\"keep\\\" //the parenthesis option (This is optional)\\n   * }\\n   *\\n   * @param {Object} [options]\\n   * @return {string}\\n   */\\n\\n\\n  Node.prototype.toHTML = function (options) {\\n    var customString = this._getCustomString(options);\\n\\n    if (typeof customString !== 'undefined') {\\n      return customString;\\n    }\\n\\n    return this.toHTML(options);\\n  };\\n  /**\\n   * Internal function to generate the string output.\\n   * This has to be implemented by every Node\\n   *\\n   * @throws {Error}\\n   */\\n\\n\\n  Node.prototype._toString = function () {\\n    // must be implemented by each of the Node implementations\\n    throw new Error('_toString not implemented for ' + this.type);\\n  };\\n  /**\\n   * Get LaTeX representation. (wrapper function)\\n   *\\n   * This function can get an object of the following form:\\n   * {\\n   *    handler: //This can be a callback function of the form\\n   *             // \\\"function callback(node, options)\\\"or\\n   *             // a map that maps function names (used in FunctionNodes)\\n   *             // to callbacks\\n   *    parenthesis: \\\"keep\\\" //the parenthesis option (This is optional)\\n   * }\\n   *\\n   * @param {Object} [options]\\n   * @return {string}\\n   */\\n\\n\\n  Node.prototype.toTex = function (options) {\\n    var customString = this._getCustomString(options);\\n\\n    if (typeof customString !== 'undefined') {\\n      return customString;\\n    }\\n\\n    return this._toTex(options);\\n  };\\n  /**\\n   * Internal function to generate the LaTeX output.\\n   * This has to be implemented by every Node\\n   *\\n   * @param {Object} [options]\\n   * @throws {Error}\\n   */\\n\\n\\n  Node.prototype._toTex = function (options) {\\n    // must be implemented by each of the Node implementations\\n    throw new Error('_toTex not implemented for ' + this.type);\\n  };\\n  /**\\n   * Helper used by `to...` functions.\\n   */\\n\\n\\n  Node.prototype._getCustomString = function (options) {\\n    if (options && _typeof(options) === 'object') {\\n      switch (_typeof(options.handler)) {\\n        case 'object':\\n        case 'undefined':\\n          return;\\n\\n        case 'function':\\n          return options.handler(this, options);\\n\\n        default:\\n          throw new TypeError('Object or function expected as callback');\\n      }\\n    }\\n  };\\n  /**\\n   * Get identifier.\\n   * @return {string}\\n   */\\n\\n\\n  Node.prototype.getIdentifier = function () {\\n    return this.type;\\n  };\\n  /**\\n   * Get the content of the current Node.\\n   * @return {Node} node\\n   **/\\n\\n\\n  Node.prototype.getContent = function () {\\n    return this;\\n  };\\n  /**\\n   * Validate the symbol names of a scope.\\n   * Throws an error when the scope contains an illegal symbol.\\n   * @param {Object} scope\\n   */\\n\\n\\n  function _validateScope(scope) {\\n    for (var symbol in scope) {\\n      if ((0, _object.hasOwnProperty)(scope, symbol)) {\\n        if (symbol in _keywords.keywords) {\\n          throw new Error('Scope contains an illegal symbol, \\\"' + symbol + '\\\" is a reserved keyword');\\n        }\\n      }\\n    }\\n  }\\n\\n  return Node;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createNode = createNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"Object\",\"defineProperty\",\"value\",\"createNode\",\"_is\",\"_keywords\",\"_object\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"Node\",\"SyntaxError\",\"mathWithTransform\",\"evaluate\",\"Node.prototype.evaluate\",\"scope\",\"compile\",\"type\",\"isNode\",\"comment\",\"Node.prototype.compile\",\"expr\",\"_compile\",\"args\",\"s\",\"symbol\",\"hasOwnProperty\",\"keywords\",\"Error\",\"context\",\"Node.prototype._compile\",\"math\",\"argNames\",\"forEach\",\"Node.prototype.forEach\",\"callback\",\"map\",\"Node.prototype.map\",\"_ifNode\",\"Node.prototype._ifNode\",\"node\",\"TypeError\",\"traverse\",\"Node.prototype.traverse\",\"_traverse\",\"child\",\"path\",\"parent\",\"transform\",\"Node.prototype.transform\",\"_transform\",\"replacement\",\"filter\",\"Node.prototype.filter\",\"nodes\",\"push\",\"clone\",\"Node.prototype.clone\",\"cloneDeep\",\"Node.prototype.cloneDeep\",\"equals\",\"Node.prototype.equals\",\"other\",\"deepStrictEqual\",\"toString\",\"Node.prototype.toString\",\"options\",\"customString\",\"_getCustomString\",\"_toString\",\"toJSON\",\"Node.prototype.toJSON\",\"toHTML\",\"Node.prototype.toHTML\",\"Node.prototype._toString\",\"toTex\",\"Node.prototype.toTex\",\"_toTex\",\"Node.prototype._toTex\",\"Node.prototype._getCustomString\",\"handler\",\"getIdentifier\",\"Node.prototype.getIdentifier\",\"getContent\",\"Node.prototype.getContent\",\"isClass\"]\n}\n"]