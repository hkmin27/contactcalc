["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/simplify.js"],"~:js","shadow$provide[566]=function(c,b,y,a){function q(d){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(l){return typeof l}:function(l){return l&&\"function\"===typeof Symbol&&l.constructor===Symbol&&l!==Symbol.prototype?\"symbol\":typeof l};return q(d)}Object.defineProperty(a,\"__esModule\",{value:!0});a.createSimplify=void 0;var f=b(14);c=b(25);var u=b(562),k=b(563),t=b(564),p=b(565),g=b(15);b=(0,c.factory)(\"simplify\",\"config typed parse add subtract multiply divide pow isZero equal ?fraction ?bignumber mathWithTransform ConstantNode FunctionNode OperatorNode ParenthesisNode SymbolNode\".split(\" \"),\nfunction(d){function l(va){return va.transform(function(da,ja,na){return(0,f.isParenthesisNode)(da)?l(da.content):da})}function h(va,da){var ja={placeholders:{}};if(va.placeholders||da.placeholders){if(!va.placeholders)return da;if(!da.placeholders)return va}else return ja;for(var na in va.placeholders)if((0,g.hasOwnProperty)(va.placeholders,na)&&(ja.placeholders[na]=va.placeholders[na],(0,g.hasOwnProperty)(da.placeholders,na)&&!v(va.placeholders[na],da.placeholders[na])))return null;for(var la in da.placeholders)(0,\ng.hasOwnProperty)(da.placeholders,la)&&(ja.placeholders[la]=da.placeholders[la]);return ja}function n(va,da){var ja=[];if(0===va.length||0===da.length)return ja;for(var na,la=0;la<va.length;la++)for(var ta=0;ta<da.length;ta++)(na=h(va[la],da[ta]))&&ja.push(na);return ja}function r(va,da,ja){var na=[{placeholders:{}}];if(va instanceof ba&&da instanceof ba||va instanceof R&&da instanceof R){if(va instanceof ba){if(va.op!==da.op||va.fn!==da.fn)return[]}else if(va instanceof R&&va.name!==da.name)return[];\nif(1===da.args.length&&1===va.args.length||!ka(da)&&da.args.length===va.args.length||ja){ja=[];for(na=0;na<va.args.length;na++){var la=r(va.args[na],da.args[na]);if(0===la.length)return[];ja.push(la)}if(0===ja.length)na=ja;else{va=ja.reduce(n);da=[];ja={};for(na=0;na<va.length;na++)la=JSON.stringify(va[na]),ja[la]||(ja[la]=!0,da.push(va[na]));na=da}}else{if(2<=da.args.length&&2===va.args.length){la=va.context;ja=[];na=Ha(da);if(ca(da,la))for(la=0;la<da.args.length;la++){var ta=da.args.slice(0);ta.splice(la,\n1);ta=1===ta.length?ta[0]:na(ta);ja.push(na([da.args[la],ta]))}else ta=da.args.slice(1),ta=1===ta.length?ta[0]:na(ta),ja.push(na([da.args[0],ta]));da=[];for(na=0;na<ja.length;na++)la=r(va,ja[na],!0),da=da.concat(la);return da}if(2<va.args.length)throw Error(\"Unexpected non-binary associative function: \"+va.toString());return[]}}else if(va instanceof T){if(0===va.name.length)throw Error(\"Symbol in rule has 0 length...!?\");if(oa[va.name]){if(va.name!==da.name)return[]}else if(\"n\"===va.name[0]||\"_p\"===\nva.name.substring(0,2))na[0].placeholders[va.name]=da;else if(\"v\"===va.name[0]){if((0,f.isConstantNode)(da))return[];na[0].placeholders[va.name]=da}else if(\"c\"===va.name[0])if(da instanceof P)na[0].placeholders[va.name]=da;else return[];else throw Error(\"Invalid symbol in rule: \"+va.name);}else if(va instanceof P){if(!I(va.value,da.value))return[]}else return[];return na}function v(va,da){if(va instanceof P&&da instanceof P){if(!I(va.value,da.value))return!1}else if(va instanceof T&&da instanceof\nT){if(va.name!==da.name)return!1}else if(va instanceof ba&&da instanceof ba||va instanceof R&&da instanceof R){if(va instanceof ba){if(va.op!==da.op||va.fn!==da.fn)return!1}else if(va instanceof R&&va.name!==da.name)return!1;if(va.args.length!==da.args.length)return!1;for(var ja=0;ja<va.args.length;ja++)if(!v(va.args[ja],da.args[ja]))return!1}else return!1;return!0}var C=d.config,z=d.typed,w=d.parse,B=d.add,x=d.subtract,D=d.multiply,F=d.divide,E=d.pow,G=d.isZero,I=d.equal,L=d.fraction,M=d.bignumber,\nS=d.mathWithTransform,P=d.ConstantNode,R=d.FunctionNode,ba=d.OperatorNode,Q=d.ParenthesisNode,T=d.SymbolNode;d=(0,t.createSimplifyConstant)({typed:z,config:C,mathWithTransform:S,fraction:L,bignumber:M,ConstantNode:P,OperatorNode:ba,FunctionNode:R,SymbolNode:T});B=(0,k.createSimplifyCore)({equal:I,isZero:G,add:B,subtract:x,multiply:D,divide:F,pow:E,ConstantNode:P,OperatorNode:ba,FunctionNode:R,ParenthesisNode:Q});var Y=(0,p.createResolve)({parse:w,FunctionNode:R,OperatorNode:ba,ParenthesisNode:Q});\nx=(0,u.createUtil)({FunctionNode:R,OperatorNode:ba,SymbolNode:T});var ca=x.isCommutative,ka=x.isAssociative,ha=x.flatten,wa=x.unflattenr,Ia=x.unflattenl,Ha=x.createMakeNodeFunction;x=z(\"simplify\",{string:function(va){return this(w(va),this.rules,{},{})},\"string, Object\":function(va,da){return this(w(va),this.rules,da,{})},\"string, Object, Object\":function(va,da,ja){return this(w(va),this.rules,da,ja)},\"string, Array\":function(va,da){return this(w(va),da,{},{})},\"string, Array, Object\":function(va,\nda,ja){return this(w(va),da,ja,{})},\"string, Array, Object, Object\":function(va,da,ja,na){return this(w(va),da,ja,na)},\"Node, Object\":function(va,da){return this(va,this.rules,da,{})},\"Node, Object, Object\":function(va,da,ja){return this(va,this.rules,da,ja)},Node:function(va){return this(va,this.rules,{},{})},\"Node, Array\":function(va,da){return this(va,da,{},{})},\"Node, Array, Object\":function(va,da,ja){return this(va,da,ja,{})},\"Node, Array, Object, Object\":function(va,da,ja,na){for(var la=[],\nta=0;ta<da.length;ta++){var Fa=da[ta];var Sa=q(Fa);switch(Sa){case \"string\":if(Sa=Fa.split(\"-\\x3e\"),2===Sa.length)Fa={l:Sa[0],r:Sa[1]};else throw SyntaxError(\"Could not parse rule: \"+Fa);case \"object\":Sa={l:l(w(Fa.l)),r:l(w(Fa.r))};Fa.context&&(Sa.evaluate=Fa.context);Fa.evaluate&&(Sa.evaluate=w(Fa.evaluate));if(ka(Sa.l)){Fa=Ha(Sa.l);var Qa=new T(\"_p\"+Ka++);Sa.expanded={};Sa.expanded.l=Fa([Sa.l.clone(),Qa]);ha(Sa.expanded.l);wa(Sa.expanded.l);Sa.expanded.r=Fa([Sa.r,Qa])}break;case \"function\":Sa=Fa;\nbreak;default:throw TypeError(\"Unsupported type of rule: \"+Sa);}la.push(Sa)}da=la;va=Y(va,ja);va=l(va);ja={};for(la=va.toString({parenthesis:\"all\"});!ja[la];){ja[la]=!0;for(la=Ka=0;la<da.length;la++)\"function\"===typeof da[la]?va=da[la](va,na):(ha(va),va=fa(va,da[la])),Ia(va);la=va.toString({parenthesis:\"all\"})}return va}});x.simplifyCore=B;x.resolve=Y;var oa={\"true\":!0,\"false\":!0,e:!0,i:!0,Infinity:!0,LN2:!0,LN10:!0,LOG2E:!0,LOG10E:!0,NaN:!0,phi:!0,pi:!0,SQRT1_2:!0,SQRT2:!0,tau:!0};x.rules=[B,{l:\"log(e)\",\nr:\"1\"},{l:\"n-n1\",r:\"n+-n1\"},{l:\"-(c*v)\",r:\"(-c) * v\"},{l:\"-v\",r:\"(-1) * v\"},{l:\"n/n1^n2\",r:\"n*n1^-n2\"},{l:\"n/n1\",r:\"n*n1^-1\"},{l:\"(n ^ n1) ^ n2\",r:\"n ^ (n1 * n2)\"},{l:\"n*n\",r:\"n^2\"},{l:\"n * n^n1\",r:\"n^(n1+1)\"},{l:\"n^n1 * n^n2\",r:\"n^(n1+n2)\"},{l:\"n+n\",r:\"2*n\"},{l:\"n+-n\",r:\"0\"},{l:\"n1*n2 + n2\",r:\"(n1+1)*n2\"},{l:\"n1*n3 + n2*n3\",r:\"(n1+n2)*n3\"},{l:\"n1 + -1 * (n2 + n3)\",r:\"n1 + -1 * n2 + -1 * n3\"},d,{l:\"(-n)*n1\",r:\"-(n*n1)\"},{l:\"c+v\",r:\"v+c\",context:{add:{commutative:!1}}},{l:\"v*c\",r:\"c*v\",context:{multiply:{commutative:!1}}},\n{l:\"n+-n1\",r:\"n-n1\"},{l:\"n*(n1^-1)\",r:\"n/n1\"},{l:\"n*n1^-n2\",r:\"n/n1^n2\"},{l:\"n1^-1\",r:\"1/n1\"},{l:\"n*(n1/n2)\",r:\"(n*n1)/n2\"},{l:\"n-(n1+n2)\",r:\"n-n1-n2\"},{l:\"1*n\",r:\"n\"},{l:\"n1/(n2/n3)\",r:\"(n1*n3)/n2\"}];var Ka=0,fa=z(\"applyRule\",{\"Node, Object\":function(va,da){if(va instanceof ba||va instanceof R){if(va.args)for(var ja=0;ja<va.args.length;ja++)va.args[ja]=fa(va.args[ja],da)}else va instanceof Q&&va.content&&(va.content=fa(va.content,da));ja=da.r;var na=r(da.l,va)[0];!na&&da.expanded&&(ja=da.expanded.r,\nna=r(da.expanded.l,va)[0]);na&&(da=va.implicit,va=ja.clone(),da&&\"implicit\"in ja&&(va.implicit=!0),va=va.transform(function(la){return la.isSymbolNode&&(0,g.hasOwnProperty)(na.placeholders,la.name)?na.placeholders[la.name].clone():la}));return va}});return x});a.createSimplify=b}","~:source","shadow$provide[566] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _util = require(\"./simplify/util.js\");\n\nvar _simplifyCore = require(\"./simplify/simplifyCore.js\");\n\nvar _simplifyConstant = require(\"./simplify/simplifyConstant.js\");\n\nvar _resolve = require(\"./simplify/resolve.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = (0, _resolve.createResolve)({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available:\n   *  - `exactFractions`: a boolean which is `true` by default.\n   *  - `fractionsLimit`: when `exactFractions` is true, a fraction will be returned\n   *    only when both numerator and denominator are smaller than `fractionsLimit`.\n   *    Default value is 10000.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, {}, {});\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Object, Object': function stringObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, {}, {});\n    },\n    'string, Array, Object': function stringArrayObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Object': function NodeObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Object, Object': function NodeObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, {}, {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, {}, {});\n    },\n    'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  }, // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n\n      var ruleType = _typeof(rule);\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});\nexports.createSimplify = createSimplify;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util","~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyCore","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$resolve"]],"~:properties",["^5",["NaN","LOG10E","FunctionNode","typed","string","resolve","LN2","isZero","config","e","multiply","simplifyCore","ConstantNode","__esModule","SymbolNode","implicit","pow","parenthesis","fraction","Infinity","pi","value","evaluate","rules","OperatorNode","context","subtract","createSimplify","ParenthesisNode","LN10","commutative","tau","bignumber","content","mathWithTransform","SQRT1_2","i","r","divide","LOG2E","l","parse","add","equal","SQRT2","placeholders","expanded","Node","phi"]],"~:compiled-at",1619135724036,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/simplify.js\"],\n\"sourcesContent\":[\"shadow$provide[566] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSimplify = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _util = require(\\\"./simplify/util.js\\\");\\n\\nvar _simplifyCore = require(\\\"./simplify/simplifyCore.js\\\");\\n\\nvar _simplifyConstant = require(\\\"./simplify/simplifyConstant.js\\\");\\n\\nvar _resolve = require(\\\"./simplify/resolve.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nvar name = 'simplify';\\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var config = _ref.config,\\n      typed = _ref.typed,\\n      parse = _ref.parse,\\n      add = _ref.add,\\n      subtract = _ref.subtract,\\n      multiply = _ref.multiply,\\n      divide = _ref.divide,\\n      pow = _ref.pow,\\n      isZero = _ref.isZero,\\n      equal = _ref.equal,\\n      fraction = _ref.fraction,\\n      bignumber = _ref.bignumber,\\n      mathWithTransform = _ref.mathWithTransform,\\n      ConstantNode = _ref.ConstantNode,\\n      FunctionNode = _ref.FunctionNode,\\n      OperatorNode = _ref.OperatorNode,\\n      ParenthesisNode = _ref.ParenthesisNode,\\n      SymbolNode = _ref.SymbolNode;\\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\\n    typed: typed,\\n    config: config,\\n    mathWithTransform: mathWithTransform,\\n    fraction: fraction,\\n    bignumber: bignumber,\\n    ConstantNode: ConstantNode,\\n    OperatorNode: OperatorNode,\\n    FunctionNode: FunctionNode,\\n    SymbolNode: SymbolNode\\n  });\\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\\n    equal: equal,\\n    isZero: isZero,\\n    add: add,\\n    subtract: subtract,\\n    multiply: multiply,\\n    divide: divide,\\n    pow: pow,\\n    ConstantNode: ConstantNode,\\n    OperatorNode: OperatorNode,\\n    FunctionNode: FunctionNode,\\n    ParenthesisNode: ParenthesisNode\\n  });\\n  var resolve = (0, _resolve.createResolve)({\\n    parse: parse,\\n    FunctionNode: FunctionNode,\\n    OperatorNode: OperatorNode,\\n    ParenthesisNode: ParenthesisNode\\n  });\\n\\n  var _createUtil = (0, _util.createUtil)({\\n    FunctionNode: FunctionNode,\\n    OperatorNode: OperatorNode,\\n    SymbolNode: SymbolNode\\n  }),\\n      isCommutative = _createUtil.isCommutative,\\n      isAssociative = _createUtil.isAssociative,\\n      flatten = _createUtil.flatten,\\n      unflattenr = _createUtil.unflattenr,\\n      unflattenl = _createUtil.unflattenl,\\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\\n  /**\\n   * Simplify an expression tree.\\n   *\\n   * A list of rules are applied to an expression, repeating over the list until\\n   * no further changes are made.\\n   * It's possible to pass a custom set of rules to the function as second\\n   * argument. A rule can be specified as an object, string, or function:\\n   *\\n   *     const rules = [\\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\\n   *       function (node) {\\n   *         // ... return a new node or return the node unchanged\\n   *         return node\\n   *       }\\n   *     ]\\n   *\\n   * String and object rules consist of a left and right pattern. The left is\\n   * used to match against the expression and the right determines what matches\\n   * are replaced with. The main difference between a pattern and a normal\\n   * expression is that variables starting with the following characters are\\n   * interpreted as wildcards:\\n   *\\n   * - 'n' - matches any Node\\n   * - 'c' - matches any ConstantNode\\n   * - 'v' - matches any Node that is not a ConstantNode\\n   *\\n   * The default list of rules is exposed on the function as `simplify.rules`\\n   * and can be used as a basis to built a set of custom rules.\\n   *\\n   * For more details on the theory, see:\\n   *\\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\\n   *\\n   *  An optional `options` argument can be passed as last argument of `simplify`.\\n   *  There is currently one option available:\\n   *  - `exactFractions`: a boolean which is `true` by default.\\n   *  - `fractionsLimit`: when `exactFractions` is true, a fraction will be returned\\n   *    only when both numerator and denominator are smaller than `fractionsLimit`.\\n   *    Default value is 10000.\\n   *\\n   * Syntax:\\n   *\\n   *     simplify(expr)\\n   *     simplify(expr, rules)\\n   *     simplify(expr, rules)\\n   *     simplify(expr, rules, scope)\\n   *     simplify(expr, rules, scope, options)\\n   *     simplify(expr, scope)\\n   *     simplify(expr, scope, options)\\n   *\\n   * Examples:\\n   *\\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \\\"2 * x\\\"\\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \\\"24\\\"\\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\\n   *     math.simplify(f)                          // Node \\\"2 * x\\\"\\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \\\"x * 2 / 5\\\"\\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \\\"0.4 * x\\\"\\n   *\\n   * See also:\\n   *\\n   *     derivative, parse, evaluate, rationalize\\n   *\\n   * @param {Node | string} expr\\n   *            The expression to be simplified\\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\\n   *            Optional list with custom rules\\n   * @return {Node} Returns the simplified form of `expr`\\n   */\\n\\n\\n  var simplify = typed('simplify', {\\n    string: function string(expr) {\\n      return this(parse(expr), this.rules, {}, {});\\n    },\\n    'string, Object': function stringObject(expr, scope) {\\n      return this(parse(expr), this.rules, scope, {});\\n    },\\n    'string, Object, Object': function stringObjectObject(expr, scope, options) {\\n      return this(parse(expr), this.rules, scope, options);\\n    },\\n    'string, Array': function stringArray(expr, rules) {\\n      return this(parse(expr), rules, {}, {});\\n    },\\n    'string, Array, Object': function stringArrayObject(expr, rules, scope) {\\n      return this(parse(expr), rules, scope, {});\\n    },\\n    'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {\\n      return this(parse(expr), rules, scope, options);\\n    },\\n    'Node, Object': function NodeObject(expr, scope) {\\n      return this(expr, this.rules, scope, {});\\n    },\\n    'Node, Object, Object': function NodeObjectObject(expr, scope, options) {\\n      return this(expr, this.rules, scope, options);\\n    },\\n    Node: function Node(expr) {\\n      return this(expr, this.rules, {}, {});\\n    },\\n    'Node, Array': function NodeArray(expr, rules) {\\n      return this(expr, rules, {}, {});\\n    },\\n    'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {\\n      return this(expr, rules, scope, {});\\n    },\\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\\n      rules = _buildRules(rules);\\n      var res = resolve(expr, scope);\\n      res = removeParens(res);\\n      var visited = {};\\n      var str = res.toString({\\n        parenthesis: 'all'\\n      });\\n\\n      while (!visited[str]) {\\n        visited[str] = true;\\n        _lastsym = 0; // counter for placeholder symbols\\n\\n        for (var i = 0; i < rules.length; i++) {\\n          if (typeof rules[i] === 'function') {\\n            res = rules[i](res, options);\\n          } else {\\n            flatten(res);\\n            res = applyRule(res, rules[i]);\\n          }\\n\\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\\n        }\\n\\n        str = res.toString({\\n          parenthesis: 'all'\\n        });\\n      }\\n\\n      return res;\\n    }\\n  });\\n  simplify.simplifyCore = simplifyCore;\\n  simplify.resolve = resolve;\\n\\n  function removeParens(node) {\\n    return node.transform(function (node, path, parent) {\\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\\n    });\\n  } // All constants that are allowed in rules\\n\\n\\n  var SUPPORTED_CONSTANTS = {\\n    \\\"true\\\": true,\\n    \\\"false\\\": true,\\n    e: true,\\n    i: true,\\n    Infinity: true,\\n    LN2: true,\\n    LN10: true,\\n    LOG2E: true,\\n    LOG10E: true,\\n    NaN: true,\\n    phi: true,\\n    pi: true,\\n    SQRT1_2: true,\\n    SQRT2: true,\\n    tau: true // null: false,\\n    // undefined: false,\\n    // version: false,\\n\\n  }; // Array of strings, used to build the ruleSet.\\n  // Each l (left side) and r (right side) are parsed by\\n  // the expression parser into a node tree.\\n  // Left hand sides are matched to subtrees within the\\n  // expression to be parsed and replaced with the right\\n  // hand side.\\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\\n  // It is possible to get into an infinite loop with conflicting rules\\n\\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\\n  // { l: 'n^0', r: '1' },     // simplifyCore\\n  // { l: '0*n', r: '0' },     // simplifyCore\\n  // { l: 'n/n', r: '1'},      // simplifyCore\\n  // { l: 'n^1', r: 'n' },     // simplifyCore\\n  // { l: '+n1', r:'n1' },     // simplifyCore\\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\\n  {\\n    l: 'log(e)',\\n    r: '1'\\n  }, // temporary rules\\n  {\\n    l: 'n-n1',\\n    r: 'n+-n1'\\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\\n  {\\n    l: '-(c*v)',\\n    r: '(-c) * v'\\n  }, // make non-constant terms positive\\n  {\\n    l: '-v',\\n    r: '(-1) * v'\\n  }, {\\n    l: 'n/n1^n2',\\n    r: 'n*n1^-n2'\\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\\n  {\\n    l: 'n/n1',\\n    r: 'n*n1^-1'\\n  }, // expand nested exponentiation\\n  {\\n    l: '(n ^ n1) ^ n2',\\n    r: 'n ^ (n1 * n2)'\\n  }, // collect like factors\\n  {\\n    l: 'n*n',\\n    r: 'n^2'\\n  }, {\\n    l: 'n * n^n1',\\n    r: 'n^(n1+1)'\\n  }, {\\n    l: 'n^n1 * n^n2',\\n    r: 'n^(n1+n2)'\\n  }, // collect like terms\\n  {\\n    l: 'n+n',\\n    r: '2*n'\\n  }, {\\n    l: 'n+-n',\\n    r: '0'\\n  }, {\\n    l: 'n1*n2 + n2',\\n    r: '(n1+1)*n2'\\n  }, {\\n    l: 'n1*n3 + n2*n3',\\n    r: '(n1+n2)*n3'\\n  }, // remove parenthesis in the case of negating a quantitiy\\n  {\\n    l: 'n1 + -1 * (n2 + n3)',\\n    r: 'n1 + -1 * n2 + -1 * n3'\\n  }, simplifyConstant, {\\n    l: '(-n)*n1',\\n    r: '-(n*n1)'\\n  }, // make factors positive (and undo 'make non-constant terms positive')\\n  // ordering of constants\\n  {\\n    l: 'c+v',\\n    r: 'v+c',\\n    context: {\\n      add: {\\n        commutative: false\\n      }\\n    }\\n  }, {\\n    l: 'v*c',\\n    r: 'c*v',\\n    context: {\\n      multiply: {\\n        commutative: false\\n      }\\n    }\\n  }, // undo temporary rules\\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\\n  {\\n    l: 'n+-n1',\\n    r: 'n-n1'\\n  }, // undo replace 'subtract'\\n  {\\n    l: 'n*(n1^-1)',\\n    r: 'n/n1'\\n  }, // undo replace 'divide'\\n  {\\n    l: 'n*n1^-n2',\\n    r: 'n/n1^n2'\\n  }, {\\n    l: 'n1^-1',\\n    r: '1/n1'\\n  }, {\\n    l: 'n*(n1/n2)',\\n    r: '(n*n1)/n2'\\n  }, // '*' before '/'\\n  {\\n    l: 'n-(n1+n2)',\\n    r: 'n-n1-n2'\\n  }, // '-' before '+'\\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\\n  {\\n    l: '1*n',\\n    r: 'n'\\n  }, // this pattern can be produced by simplifyConstant\\n  {\\n    l: 'n1/(n2/n3)',\\n    r: '(n1*n3)/n2'\\n  }];\\n  /**\\n   * Parse the string array of rules into nodes\\n   *\\n   * Example syntax for rules:\\n   *\\n   * Position constants to the left in a product:\\n   * { l: 'n1 * c1', r: 'c1 * n1' }\\n   * n1 is any Node, and c1 is a ConstantNode.\\n   *\\n   * Apply difference of squares formula:\\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\\n   * n1, n2 mean any Node.\\n   *\\n   * Short hand notation:\\n   * 'n1 * c1 -> c1 * n1'\\n   */\\n\\n  function _buildRules(rules) {\\n    // Array of rules to be used to simplify expressions\\n    var ruleSet = [];\\n\\n    for (var i = 0; i < rules.length; i++) {\\n      var rule = rules[i];\\n      var newRule = void 0;\\n\\n      var ruleType = _typeof(rule);\\n\\n      switch (ruleType) {\\n        case 'string':\\n          {\\n            var lr = rule.split('->');\\n\\n            if (lr.length === 2) {\\n              rule = {\\n                l: lr[0],\\n                r: lr[1]\\n              };\\n            } else {\\n              throw SyntaxError('Could not parse rule: ' + rule);\\n            }\\n          }\\n\\n        /* falls through */\\n\\n        case 'object':\\n          newRule = {\\n            l: removeParens(parse(rule.l)),\\n            r: removeParens(parse(rule.r))\\n          };\\n\\n          if (rule.context) {\\n            newRule.evaluate = rule.context;\\n          }\\n\\n          if (rule.evaluate) {\\n            newRule.evaluate = parse(rule.evaluate);\\n          }\\n\\n          if (isAssociative(newRule.l)) {\\n            var makeNode = createMakeNodeFunction(newRule.l);\\n\\n            var expandsym = _getExpandPlaceholderSymbol();\\n\\n            newRule.expanded = {};\\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\\n            // This helps to match the newRule against nodes returned from getSplits() later on.\\n\\n            flatten(newRule.expanded.l);\\n            unflattenr(newRule.expanded.l);\\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\\n          }\\n\\n          break;\\n\\n        case 'function':\\n          newRule = rule;\\n          break;\\n\\n        default:\\n          throw TypeError('Unsupported type of rule: ' + ruleType);\\n      } // console.log('Adding rule: ' + rules[i])\\n      // console.log(newRule)\\n\\n\\n      ruleSet.push(newRule);\\n    }\\n\\n    return ruleSet;\\n  }\\n\\n  var _lastsym = 0;\\n\\n  function _getExpandPlaceholderSymbol() {\\n    return new SymbolNode('_p' + _lastsym++);\\n  }\\n  /**\\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\\n   *\\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\\n   */\\n\\n\\n  var applyRule = typed('applyRule', {\\n    'Node, Object': function NodeObject(node, rule) {\\n      // console.log('Entering applyRule(' + node.toString() + ')')\\n      // Do not clone node unless we find a match\\n      var res = node; // First replace our child nodes with their simplified versions\\n      // If a child could not be simplified, the assignments will have\\n      // no effect since the node is returned unchanged\\n\\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\\n        if (res.args) {\\n          for (var i = 0; i < res.args.length; i++) {\\n            res.args[i] = applyRule(res.args[i], rule);\\n          }\\n        }\\n      } else if (res instanceof ParenthesisNode) {\\n        if (res.content) {\\n          res.content = applyRule(res.content, rule);\\n        }\\n      } // Try to match a rule against this node\\n\\n\\n      var repl = rule.r;\\n\\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\\n\\n\\n      if (!matches && rule.expanded) {\\n        repl = rule.expanded.r;\\n        matches = _ruleMatch(rule.expanded.l, res)[0];\\n      }\\n\\n      if (matches) {\\n        // const before = res.toString({parenthesis: 'all'})\\n        // Create a new node by cloning the rhs of the matched rule\\n        // we keep any implicit multiplication state if relevant\\n        var implicit = res.implicit;\\n        res = repl.clone();\\n\\n        if (implicit && 'implicit' in repl) {\\n          res.implicit = true;\\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\\n\\n\\n        res = res.transform(function (node) {\\n          if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\\n            return matches.placeholders[node.name].clone();\\n          } else {\\n            return node;\\n          }\\n        }); // const after = res.toString({parenthesis: 'all'})\\n        // console.log('Simplified ' + before + ' to ' + after)\\n      }\\n\\n      return res;\\n    }\\n  });\\n  /**\\n   * Get (binary) combinations of a flattened binary node\\n   * e.g. +(node1, node2, node3) -> [\\n   *        +(node1,  +(node2, node3)),\\n   *        +(node2,  +(node1, node3)),\\n   *        +(node3,  +(node1, node2))]\\n   *\\n   */\\n\\n  function getSplits(node, context) {\\n    var res = [];\\n    var right, rightArgs;\\n    var makeNode = createMakeNodeFunction(node);\\n\\n    if (isCommutative(node, context)) {\\n      for (var i = 0; i < node.args.length; i++) {\\n        rightArgs = node.args.slice(0);\\n        rightArgs.splice(i, 1);\\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\\n        res.push(makeNode([node.args[i], right]));\\n      }\\n    } else {\\n      rightArgs = node.args.slice(1);\\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\\n      res.push(makeNode([node.args[0], right]));\\n    }\\n\\n    return res;\\n  }\\n  /**\\n   * Returns the set union of two match-placeholders or null if there is a conflict.\\n   */\\n\\n\\n  function mergeMatch(match1, match2) {\\n    var res = {\\n      placeholders: {}\\n    }; // Some matches may not have placeholders; this is OK\\n\\n    if (!match1.placeholders && !match2.placeholders) {\\n      return res;\\n    } else if (!match1.placeholders) {\\n      return match2;\\n    } else if (!match2.placeholders) {\\n      return match1;\\n    } // Placeholders with the same key must match exactly\\n\\n\\n    for (var key in match1.placeholders) {\\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\\n        res.placeholders[key] = match1.placeholders[key];\\n\\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\\n            return null;\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var _key in match2.placeholders) {\\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\\n        res.placeholders[_key] = match2.placeholders[_key];\\n      }\\n    }\\n\\n    return res;\\n  }\\n  /**\\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\\n   * Each list represents matches found in one child of a node.\\n   */\\n\\n\\n  function combineChildMatches(list1, list2) {\\n    var res = [];\\n\\n    if (list1.length === 0 || list2.length === 0) {\\n      return res;\\n    }\\n\\n    var merged;\\n\\n    for (var i1 = 0; i1 < list1.length; i1++) {\\n      for (var i2 = 0; i2 < list2.length; i2++) {\\n        merged = mergeMatch(list1[i1], list2[i2]);\\n\\n        if (merged) {\\n          res.push(merged);\\n        }\\n      }\\n    }\\n\\n    return res;\\n  }\\n  /**\\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\\n   * Each list represents matches found in one child of a node.\\n   * Returns a list of unique matches.\\n   */\\n\\n\\n  function mergeChildMatches(childMatches) {\\n    if (childMatches.length === 0) {\\n      return childMatches;\\n    }\\n\\n    var sets = childMatches.reduce(combineChildMatches);\\n    var uniqueSets = [];\\n    var unique = {};\\n\\n    for (var i = 0; i < sets.length; i++) {\\n      var s = JSON.stringify(sets[i]);\\n\\n      if (!unique[s]) {\\n        unique[s] = true;\\n        uniqueSets.push(sets[i]);\\n      }\\n    }\\n\\n    return uniqueSets;\\n  }\\n  /**\\n   * Determines whether node matches rule.\\n   *\\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\\n   * @return {Object} Information about the match, if it exists.\\n   */\\n\\n\\n  function _ruleMatch(rule, node, isSplit) {\\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\\n    //    console.log('rule = ' + rule)\\n    //    console.log('node = ' + node)\\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\\n    var res = [{\\n      placeholders: {}\\n    }];\\n\\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\\n      if (rule instanceof OperatorNode) {\\n        if (rule.op !== node.op || rule.fn !== node.fn) {\\n          return [];\\n        }\\n      } else if (rule instanceof FunctionNode) {\\n        if (rule.name !== node.name) {\\n          return [];\\n        }\\n      } // rule and node match. Search the children of rule and node.\\n\\n\\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\\n        // Expect non-associative operators to match exactly\\n        var childMatches = [];\\n\\n        for (var i = 0; i < rule.args.length; i++) {\\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\\n\\n          if (childMatch.length === 0) {\\n            // Child did not match, so stop searching immediately\\n            return [];\\n          } // The child matched, so add the information returned from the child to our result\\n\\n\\n          childMatches.push(childMatch);\\n        }\\n\\n        res = mergeChildMatches(childMatches);\\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\\n        // node is flattened, rule is not\\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\\n        // them and return their union.\\n        var splits = getSplits(node, rule.context);\\n        var splitMatches = [];\\n\\n        for (var _i = 0; _i < splits.length; _i++) {\\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\\n\\n\\n          splitMatches = splitMatches.concat(matchSet);\\n        }\\n\\n        return splitMatches;\\n      } else if (rule.args.length > 2) {\\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\\n      } else {\\n        // Incorrect number of arguments in rule and node, so no match\\n        return [];\\n      }\\n    } else if (rule instanceof SymbolNode) {\\n      // If the rule is a SymbolNode, then it carries a special meaning\\n      // according to the first character of the symbol node name.\\n      // c.* matches a ConstantNode\\n      // n.* matches any node\\n      if (rule.name.length === 0) {\\n        throw new Error('Symbol in rule has 0 length...!?');\\n      }\\n\\n      if (SUPPORTED_CONSTANTS[rule.name]) {\\n        // built-in constant must match exactly\\n        if (rule.name !== node.name) {\\n          return [];\\n        }\\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\\n        // rule matches _anything_, so assign this node to the rule.name placeholder\\n        // Assign node to the rule.name placeholder.\\n        // Our parent will check for matches among placeholders.\\n        res[0].placeholders[rule.name] = node;\\n      } else if (rule.name[0] === 'v') {\\n        // rule matches any variable thing (not a ConstantNode)\\n        if (!(0, _is.isConstantNode)(node)) {\\n          res[0].placeholders[rule.name] = node;\\n        } else {\\n          // Mis-match: rule was expecting something other than a ConstantNode\\n          return [];\\n        }\\n      } else if (rule.name[0] === 'c') {\\n        // rule matches any ConstantNode\\n        if (node instanceof ConstantNode) {\\n          res[0].placeholders[rule.name] = node;\\n        } else {\\n          // Mis-match: rule was expecting a ConstantNode\\n          return [];\\n        }\\n      } else {\\n        throw new Error('Invalid symbol in rule: ' + rule.name);\\n      }\\n    } else if (rule instanceof ConstantNode) {\\n      // Literal constant must match exactly\\n      if (!equal(rule.value, node.value)) {\\n        return [];\\n      }\\n    } else {\\n      // Some other node was encountered which we aren't prepared for, so no match\\n      return [];\\n    } // It's a match!\\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\\n\\n\\n    return res;\\n  }\\n  /**\\n   * Determines whether p and q (and all their children nodes) are identical.\\n   *\\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\\n   * @return {Object} Information about the match, if it exists.\\n   */\\n\\n\\n  function _exactMatch(p, q) {\\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\\n      if (!equal(p.value, q.value)) {\\n        return false;\\n      }\\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\\n      if (p.name !== q.name) {\\n        return false;\\n      }\\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\\n      if (p instanceof OperatorNode) {\\n        if (p.op !== q.op || p.fn !== q.fn) {\\n          return false;\\n        }\\n      } else if (p instanceof FunctionNode) {\\n        if (p.name !== q.name) {\\n          return false;\\n        }\\n      }\\n\\n      if (p.args.length !== q.args.length) {\\n        return false;\\n      }\\n\\n      for (var i = 0; i < p.args.length; i++) {\\n        if (!_exactMatch(p.args[i], q.args[i])) {\\n          return false;\\n        }\\n      }\\n    } else {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  return simplify;\\n});\\nexports.createSimplify = createSimplify;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"Object\",\"defineProperty\",\"value\",\"createSimplify\",\"_is\",\"_factory\",\"_util\",\"_simplifyCore\",\"_simplifyConstant\",\"_resolve\",\"_object\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"removeParens\",\"node\",\"transform\",\"path\",\"parent\",\"isParenthesisNode\",\"content\",\"mergeMatch\",\"match1\",\"match2\",\"res\",\"placeholders\",\"key\",\"hasOwnProperty\",\"_exactMatch\",\"_key\",\"combineChildMatches\",\"list1\",\"list2\",\"length\",\"merged\",\"i1\",\"i2\",\"push\",\"_ruleMatch\",\"rule\",\"isSplit\",\"OperatorNode\",\"FunctionNode\",\"op\",\"fn\",\"args\",\"isAssociative\",\"childMatches\",\"i\",\"childMatch\",\"sets\",\"reduce\",\"uniqueSets\",\"unique\",\"s\",\"JSON\",\"stringify\",\"context\",\"makeNode\",\"createMakeNodeFunction\",\"isCommutative\",\"rightArgs\",\"slice\",\"splice\",\"right\",\"splitMatches\",\"_i\",\"matchSet\",\"concat\",\"Error\",\"toString\",\"SymbolNode\",\"SUPPORTED_CONSTANTS\",\"substring\",\"isConstantNode\",\"ConstantNode\",\"equal\",\"p\",\"q\",\"config\",\"typed\",\"parse\",\"add\",\"subtract\",\"multiply\",\"divide\",\"pow\",\"isZero\",\"fraction\",\"bignumber\",\"mathWithTransform\",\"ParenthesisNode\",\"simplifyConstant\",\"createSimplifyConstant\",\"simplifyCore\",\"createSimplifyCore\",\"resolve\",\"createResolve\",\"_createUtil\",\"createUtil\",\"flatten\",\"unflattenr\",\"unflattenl\",\"simplify\",\"string\",\"expr\",\"rules\",\"stringObject\",\"scope\",\"stringObjectObject\",\"options\",\"stringArray\",\"stringArrayObject\",\"stringArrayObjectObject\",\"NodeObject\",\"NodeObjectObject\",\"Node\",\"NodeArray\",\"NodeArrayObject\",\"NodeArrayObjectObject\",\"ruleSet\",\"ruleType\",\"lr\",\"split\",\"l\",\"r\",\"SyntaxError\",\"newRule\",\"evaluate\",\"expandsym\",\"_lastsym\",\"expanded\",\"clone\",\"TypeError\",\"visited\",\"str\",\"parenthesis\",\"applyRule\",\"e\",\"Infinity\",\"LN2\",\"LN10\",\"LOG2E\",\"LOG10E\",\"NaN\",\"phi\",\"pi\",\"SQRT1_2\",\"SQRT2\",\"tau\",\"commutative\",\"repl\",\"matches\",\"implicit\",\"isSymbolNode\"]\n}\n"]