["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/core/function/import.js"],"~:js","shadow$provide[932]=function(c,b,y,a){function q(d,l,h){l in d?Object.defineProperty(d,l,{value:h,enumerable:!0,configurable:!0,writable:!0}):d[l]=h;return d}function f(d){\"@babel/helpers - typeof\";f=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(l){return typeof l}:function(l){return l&&\"function\"===typeof Symbol&&l.constructor===Symbol&&l!==Symbol.prototype?\"symbol\":typeof l};return f(d)}Object.defineProperty(a,\"__esModule\",{value:!0});a.importFactory=function(d,l,h,n){function r(I,\nL,M){M.wrap&&\"function\"===typeof L&&(L=z(L));\"function\"===typeof L&&\"string\"===typeof L.signature&&(L=d(I,q({},L.signature,L)));if(x(h[I])&&x(L))L=M.override?d(I,L.signatures):d(h[I],L),h[I]=L,delete n[I],v(I,L),h.emit(\"import\",I,function(){return L});else if(void 0===h[I]||M.override)h[I]=L,delete n[I],v(I,L),h.emit(\"import\",I,function(){return L});else if(!M.silent)throw Error('Cannot import \"'+I+'\": already exists');}function v(I,L){L&&\"function\"===typeof L.transform?(h.expression.transform[I]=\nL.transform,D(I)&&(h.expression.mathWithTransform[I]=L.transform)):(delete h.expression.transform[I],D(I)&&(h.expression.mathWithTransform[I]=L))}function C(I){delete h.expression.transform[I];D(I)?h.expression.mathWithTransform[I]=h[I]:delete h.expression.mathWithTransform[I]}function z(I){var L=function(){for(var M=[],S=0,P=arguments.length;S<P;S++){var R=arguments[S];M[S]=R&&R.valueOf()}return I.apply(h,M)};I.transform&&(L.transform=I.transform);return L}function w(I,L){var M=2<arguments.length&&\nvoid 0!==arguments[2]?arguments[2]:I.fn;if((0,p.contains)(M,\".\"))throw Error(\"Factory name should not contain a nested path. Name: \"+JSON.stringify(M));var S=E(I)?h.expression.transform:h,P=M in h.expression.transform,R=(0,t.hasOwnProperty)(S,M)?S[M]:void 0,ba=function(){var Q={};I.dependencies.map(k.stripOptionalNotation).forEach(function(Y){if((0,p.contains)(Y,\".\"))throw Error(\"Factory dependency should not contain a nested path. Name: \"+JSON.stringify(Y));\"math\"===Y?Q.math=h:\"mathWithTransform\"===\nY?Q.mathWithTransform=h.expression.mathWithTransform:\"classes\"===Y?Q.classes=h:Q[Y]=h[Y]});var T=I(Q);if(T&&\"function\"===typeof T.transform)throw Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path\\x3d\"expression.transform\"');if(void 0===R||L.override)return T;if(x(R)&&x(T))return d(R,T);if(L.silent)return R;throw Error('Cannot import \"'+M+'\": already exists');};I.meta&&!1===I.meta.lazy?S[M]=ba():(0,t.lazy)(S,M,ba);R&&P?C(M):(E(I)||\nF(I))&&(0,t.lazy)(h.expression.mathWithTransform,M,function(){return S[M]});n[M]=I;h.emit(\"import\",M,ba)}function B(I){return\"function\"===typeof I||\"number\"===typeof I||\"string\"===typeof I||\"boolean\"===typeof I||null===I||(0,u.isUnit)(I)||(0,u.isComplex)(I)||(0,u.isBigNumber)(I)||(0,u.isFraction)(I)||(0,u.isMatrix)(I)||Array.isArray(I)}function x(I){return\"function\"===typeof I&&\"object\"===f(I.signatures)}function D(I){return!(0,t.hasOwnProperty)(G,I)}function F(I){return-1===I.fn.indexOf(\".\")&&!(0,\nt.hasOwnProperty)(G,I.fn)&&(!I.meta||!I.meta.isClass)}function E(I){return void 0!==I&&void 0!==I.meta&&!0===I.meta.isTransformFunction||!1}var G={expression:!0,type:!0,docs:!0,error:!0,json:!0,chain:!0};return function(I,L){function M(ba,Q,T){if(Array.isArray(Q))Q.forEach(function(ca){return M(ba,ca)});else if(\"object\"===f(Q))for(var Y in Q)(0,t.hasOwnProperty)(Q,Y)&&M(ba,Q[Y],Y);else if((0,k.isFactory)(Q)||void 0!==T){T=(0,k.isFactory)(Q)?E(Q)?Q.fn+\".transform\":Q.fn:T;if((0,t.hasOwnProperty)(ba,\nT)&&ba[T]!==Q&&!L.silent)throw Error('Cannot import \"'+T+'\" twice');ba[T]=Q}else if(!L.silent)throw new TypeError(\"Factory, Object, or Array expected\");}var S=arguments.length;if(1!==S&&2!==S)throw new g.ArgumentsError(\"import\",S,1,2);L||(L={});S={};M(S,I);for(var P in S)if((0,t.hasOwnProperty)(S,P)){var R=S[P];if((0,k.isFactory)(R))w(R,L);else if(B(R))r(P,R,L);else if(!L.silent)throw new TypeError(\"Factory, Object, or Array expected\");}}};var u=b(14),k=b(25),t=b(15),p=b(24),g=b(140)}","~:source","shadow$provide[932] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importFactory = importFactory;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _ArgumentsError = require(\"../../error/ArgumentsError.js\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new _ArgumentsError.ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (_typeof(value) === 'object') {\n        for (var _name in value) {\n          if ((0, _object.hasOwnProperty)(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if ((0, _factory.isFactory)(value) || name !== undefined) {\n        var flatName = (0, _factory.isFactory)(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if ((0, _object.hasOwnProperty)(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if ((0, _object.hasOwnProperty)(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if ((0, _factory.isFactory)(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if ((0, _array.contains)(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = (0, _object.hasOwnProperty)(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(_factory.stripOptionalNotation).forEach(function (dependency) {\n        if ((0, _array.contains)(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      (0, _object.lazy)(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !(0, _object.hasOwnProperty)(unsafe, name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !(0, _object.hasOwnProperty)(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$error$ArgumentsError","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["json","__esModule","error","transform","expression","configurable","math","value","enumerable","writable","classes","mathWithTransform","type","importFactory","docs","chain"]],"~:compiled-at",1619135724113,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$core$function$import.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/core/function/import.js\"],\n\"sourcesContent\":[\"shadow$provide[932] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.importFactory = importFactory;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _ArgumentsError = require(\\\"../../error/ArgumentsError.js\\\");\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction importFactory(typed, load, math, importedFactories) {\\n  /**\\n   * Import functions from an object or a module.\\n   *\\n   * This function is only available on a mathjs instance created using `create`.\\n   *\\n   * Syntax:\\n   *\\n   *    math.import(functions)\\n   *    math.import(functions, options)\\n   *\\n   * Where:\\n   *\\n   * - `functions: Object`\\n   *   An object with functions or factories to be imported.\\n   * - `options: Object` An object with import options. Available options:\\n   *   - `override: boolean`\\n   *     If true, existing functions will be overwritten. False by default.\\n   *   - `silent: boolean`\\n   *     If true, the function will not throw errors on duplicates or invalid\\n   *     types. False by default.\\n   *   - `wrap: boolean`\\n   *     If true, the functions will be wrapped in a wrapper function\\n   *     which converts data types like Matrix to primitive data types like Array.\\n   *     The wrapper is needed when extending math.js with libraries which do not\\n   *     support these data type. False by default.\\n   *\\n   * Examples:\\n   *\\n   *    import { create, all } from 'mathjs'\\n   *    import * as numbers from 'numbers'\\n   *\\n   *    // create a mathjs instance\\n   *    const math = create(all)\\n   *\\n   *    // define new functions and variables\\n   *    math.import({\\n   *      myvalue: 42,\\n   *      hello: function (name) {\\n   *        return 'hello, ' + name + '!'\\n   *      }\\n   *    })\\n   *\\n   *    // use the imported function and variable\\n   *    math.myvalue * 2               // 84\\n   *    math.hello('user')             // 'hello, user!'\\n   *\\n   *    // import the npm module 'numbers'\\n   *    // (must be installed first with `npm install numbers`)\\n   *    math.import(numbers, {wrap: true})\\n   *\\n   *    math.fibonacci(7) // returns 13\\n   *\\n   * @param {Object | Array} functions  Object with functions to be imported.\\n   * @param {Object} [options]          Import options.\\n   */\\n  function mathImport(functions, options) {\\n    var num = arguments.length;\\n\\n    if (num !== 1 && num !== 2) {\\n      throw new _ArgumentsError.ArgumentsError('import', num, 1, 2);\\n    }\\n\\n    if (!options) {\\n      options = {};\\n    }\\n\\n    function flattenImports(flatValues, value, name) {\\n      if (Array.isArray(value)) {\\n        value.forEach(function (item) {\\n          return flattenImports(flatValues, item);\\n        });\\n      } else if (_typeof(value) === 'object') {\\n        for (var _name in value) {\\n          if ((0, _object.hasOwnProperty)(value, _name)) {\\n            flattenImports(flatValues, value[_name], _name);\\n          }\\n        }\\n      } else if ((0, _factory.isFactory)(value) || name !== undefined) {\\n        var flatName = (0, _factory.isFactory)(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\\n\\n        if ((0, _object.hasOwnProperty)(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\\n          throw new Error('Cannot import \\\"' + flatName + '\\\" twice');\\n        }\\n\\n        flatValues[flatName] = value;\\n      } else {\\n        if (!options.silent) {\\n          throw new TypeError('Factory, Object, or Array expected');\\n        }\\n      }\\n    }\\n\\n    var flatValues = {};\\n    flattenImports(flatValues, functions);\\n\\n    for (var name in flatValues) {\\n      if ((0, _object.hasOwnProperty)(flatValues, name)) {\\n        // console.log('import', name)\\n        var value = flatValues[name];\\n\\n        if ((0, _factory.isFactory)(value)) {\\n          // we ignore name here and enforce the name of the factory\\n          // maybe at some point we do want to allow overriding it\\n          // in that case we can implement an option overrideFactoryNames: true\\n          _importFactory(value, options);\\n        } else if (isSupportedType(value)) {\\n          _import(name, value, options);\\n        } else {\\n          if (!options.silent) {\\n            throw new TypeError('Factory, Object, or Array expected');\\n          }\\n        }\\n      }\\n    }\\n  }\\n  /**\\n   * Add a property to the math namespace\\n   * @param {string} name\\n   * @param {*} value\\n   * @param {Object} options  See import for a description of the options\\n   * @private\\n   */\\n\\n\\n  function _import(name, value, options) {\\n    // TODO: refactor this function, it's to complicated and contains duplicate code\\n    if (options.wrap && typeof value === 'function') {\\n      // create a wrapper around the function\\n      value = _wrap(value);\\n    } // turn a plain function with a typed-function signature into a typed-function\\n\\n\\n    if (hasTypedFunctionSignature(value)) {\\n      value = typed(name, _defineProperty({}, value.signature, value));\\n    }\\n\\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\\n      if (options.override) {\\n        // give the typed function the right name\\n        value = typed(name, value.signatures);\\n      } else {\\n        // merge the existing and typed function\\n        value = typed(math[name], value);\\n      }\\n\\n      math[name] = value;\\n      delete importedFactories[name];\\n\\n      _importTransform(name, value);\\n\\n      math.emit('import', name, function resolver() {\\n        return value;\\n      });\\n      return;\\n    }\\n\\n    if (math[name] === undefined || options.override) {\\n      math[name] = value;\\n      delete importedFactories[name];\\n\\n      _importTransform(name, value);\\n\\n      math.emit('import', name, function resolver() {\\n        return value;\\n      });\\n      return;\\n    }\\n\\n    if (!options.silent) {\\n      throw new Error('Cannot import \\\"' + name + '\\\": already exists');\\n    }\\n  }\\n\\n  function _importTransform(name, value) {\\n    if (value && typeof value.transform === 'function') {\\n      math.expression.transform[name] = value.transform;\\n\\n      if (allowedInExpressions(name)) {\\n        math.expression.mathWithTransform[name] = value.transform;\\n      }\\n    } else {\\n      // remove existing transform\\n      delete math.expression.transform[name];\\n\\n      if (allowedInExpressions(name)) {\\n        math.expression.mathWithTransform[name] = value;\\n      }\\n    }\\n  }\\n\\n  function _deleteTransform(name) {\\n    delete math.expression.transform[name];\\n\\n    if (allowedInExpressions(name)) {\\n      math.expression.mathWithTransform[name] = math[name];\\n    } else {\\n      delete math.expression.mathWithTransform[name];\\n    }\\n  }\\n  /**\\n   * Create a wrapper a round an function which converts the arguments\\n   * to their primitive values (like convert a Matrix to Array)\\n   * @param {Function} fn\\n   * @return {Function} Returns the wrapped function\\n   * @private\\n   */\\n\\n\\n  function _wrap(fn) {\\n    var wrapper = function wrapper() {\\n      var args = [];\\n\\n      for (var i = 0, len = arguments.length; i < len; i++) {\\n        var arg = arguments[i];\\n        args[i] = arg && arg.valueOf();\\n      }\\n\\n      return fn.apply(math, args);\\n    };\\n\\n    if (fn.transform) {\\n      wrapper.transform = fn.transform;\\n    }\\n\\n    return wrapper;\\n  }\\n  /**\\n   * Import an instance of a factory into math.js\\n   * @param {function(scope: object)} factory\\n   * @param {Object} options  See import for a description of the options\\n   * @param {string} [name=factory.name] Optional custom name\\n   * @private\\n   */\\n\\n\\n  function _importFactory(factory, options) {\\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\\n\\n    if ((0, _array.contains)(name, '.')) {\\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\\n    }\\n\\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\\n    var existingTransform = (name in math.expression.transform);\\n    var existing = (0, _object.hasOwnProperty)(namespace, name) ? namespace[name] : undefined;\\n\\n    var resolver = function resolver() {\\n      // collect all dependencies, handle finding both functions and classes and other special cases\\n      var dependencies = {};\\n      factory.dependencies.map(_factory.stripOptionalNotation).forEach(function (dependency) {\\n        if ((0, _array.contains)(dependency, '.')) {\\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\\n        }\\n\\n        if (dependency === 'math') {\\n          dependencies.math = math;\\n        } else if (dependency === 'mathWithTransform') {\\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\\n        } else if (dependency === 'classes') {\\n          // special case for json reviver\\n          dependencies.classes = math;\\n        } else {\\n          dependencies[dependency] = math[dependency];\\n        }\\n      });\\n      var instance = /* #__PURE__ */factory(dependencies);\\n\\n      if (instance && typeof instance.transform === 'function') {\\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\\\"expression.transform\\\"');\\n      }\\n\\n      if (existing === undefined || options.override) {\\n        return instance;\\n      }\\n\\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\\n        // merge the existing and new typed function\\n        return typed(existing, instance);\\n      }\\n\\n      if (options.silent) {\\n        // keep existing, ignore imported function\\n        return existing;\\n      } else {\\n        throw new Error('Cannot import \\\"' + name + '\\\": already exists');\\n      }\\n    }; // TODO: add unit test with non-lazy factory\\n\\n\\n    if (!factory.meta || factory.meta.lazy !== false) {\\n      (0, _object.lazy)(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\\n\\n      if (existing && existingTransform) {\\n        _deleteTransform(name);\\n      } else {\\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\\n            return namespace[name];\\n          });\\n        }\\n      }\\n    } else {\\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\\n\\n      if (existing && existingTransform) {\\n        _deleteTransform(name);\\n      } else {\\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\\n            return namespace[name];\\n          });\\n        }\\n      }\\n    } // TODO: improve factories, store a list with imports instead which can be re-played\\n\\n\\n    importedFactories[name] = factory;\\n    math.emit('import', name, resolver);\\n  }\\n  /**\\n   * Check whether given object is a type which can be imported\\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\\n   * @return {boolean}\\n   * @private\\n   */\\n\\n\\n  function isSupportedType(object) {\\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);\\n  }\\n  /**\\n   * Test whether a given thing is a typed-function\\n   * @param {*} fn\\n   * @return {boolean} Returns true when `fn` is a typed-function\\n   */\\n\\n\\n  function isTypedFunction(fn) {\\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\\n  }\\n\\n  function hasTypedFunctionSignature(fn) {\\n    return typeof fn === 'function' && typeof fn.signature === 'string';\\n  }\\n\\n  function allowedInExpressions(name) {\\n    return !(0, _object.hasOwnProperty)(unsafe, name);\\n  }\\n\\n  function factoryAllowedInExpressions(factory) {\\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\\n    !(0, _object.hasOwnProperty)(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\\n  }\\n\\n  function isTransformFunctionFactory(factory) {\\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\\n  } // namespaces and functions not available in the parser for safety reasons\\n\\n\\n  var unsafe = {\\n    expression: true,\\n    type: true,\\n    docs: true,\\n    error: true,\\n    json: true,\\n    chain: true // chain method not supported. Note that there is a unit chain too.\\n\\n  };\\n  return mathImport;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperty\",\"obj\",\"key\",\"value\",\"Object\",\"defineProperty\",\"enumerable\",\"configurable\",\"writable\",\"_typeof\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"importFactory\",\"typed\",\"load\",\"math\",\"importedFactories\",\"_import\",\"name\",\"options\",\"wrap\",\"_wrap\",\"signature\",\"isTypedFunction\",\"override\",\"signatures\",\"_importTransform\",\"emit\",\"resolver\",\"undefined\",\"silent\",\"Error\",\"transform\",\"expression\",\"allowedInExpressions\",\"mathWithTransform\",\"_deleteTransform\",\"fn\",\"wrapper\",\"args\",\"i\",\"len\",\"arguments\",\"length\",\"arg\",\"valueOf\",\"apply\",\"_importFactory\",\"factory\",\"_array\",\"contains\",\"JSON\",\"stringify\",\"namespace\",\"isTransformFunctionFactory\",\"existingTransform\",\"existing\",\"_object\",\"hasOwnProperty\",\"dependencies\",\"map\",\"_factory\",\"stripOptionalNotation\",\"forEach\",\"dependency\",\"classes\",\"instance\",\"meta\",\"lazy\",\"factoryAllowedInExpressions\",\"isSupportedType\",\"object\",\"_is\",\"isUnit\",\"isComplex\",\"isBigNumber\",\"isFraction\",\"isMatrix\",\"Array\",\"isArray\",\"unsafe\",\"indexOf\",\"isClass\",\"isTransformFunction\",\"type\",\"docs\",\"error\",\"json\",\"chain\",\"mathImport\",\"functions\",\"flattenImports\",\"flatValues\",\"item\",\"_name\",\"isFactory\",\"flatName\",\"TypeError\",\"num\",\"_ArgumentsError\",\"ArgumentsError\"]\n}\n"]