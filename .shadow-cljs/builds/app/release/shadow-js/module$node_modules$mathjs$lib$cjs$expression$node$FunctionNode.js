["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js"],"~:js","shadow$provide[270]=function(c,b,y,a){function q(l){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(h){return typeof h}:function(h){return h&&\"function\"===typeof Symbol&&h.constructor===Symbol&&h!==Symbol.prototype?\"symbol\":typeof h};return q(l)}function f(){f=Object.assign||function(l){for(var h=1;h<arguments.length;h++){var n=arguments[h],r;for(r in n)Object.prototype.hasOwnProperty.call(n,r)&&(l[r]=n[r])}return l};return f.apply(this,arguments)}\nObject.defineProperty(a,\"__esModule\",{value:!0});a.createFunctionNode=void 0;var u=b(14),k=b(21),t=b(15),p=b(24),g=b(147);c=b(25);var d=b(260);b=(0,c.factory)(\"FunctionNode\",[\"math\",\"Node\",\"SymbolNode\"],function(l){function h(w,B){if(!(this instanceof h))throw new SyntaxError(\"Constructor must be called with the new operator\");\"string\"===typeof w&&(w=new v(w));if(!(0,u.isNode)(w))throw new TypeError('Node expected as parameter \"fn\"');if(!Array.isArray(B)||!B.every(u.isNode))throw new TypeError('Array containing Nodes expected for parameter \"args\"');\nthis.fn=w;this.args=B||[];Object.defineProperty(this,\"name\",{get:function(){return this.fn.name||\"\"}.bind(this),set:function(){throw Error(\"Cannot assign a new name, name is read-only\");}})}function n(w,B,x){for(var D=\"\",F=/\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi,E=0,G;null!==(G=F.exec(w));)if(D+=w.substring(E,G.index),E=G.index,\"$$\"===G[0])D+=\"$\",E++;else{E+=G[0].length;var I=B[G[1]];if(!I)throw new ReferenceError(\"Template: Property \"+G[1]+\" does not exist.\");if(void 0===G[2])switch(q(I)){case \"string\":D+=\nI;break;case \"object\":if((0,u.isNode)(I))D+=I.toTex(x);else if(Array.isArray(I))D+=I.map(function(L,M){if((0,u.isNode)(L))return L.toTex(x);throw new TypeError(\"Template: \"+G[1]+\"[\"+M+\"] is not a Node.\");}).join(\",\");else throw new TypeError(\"Template: \"+G[1]+\" has to be a Node, String or array of Nodes\");break;default:throw new TypeError(\"Template: \"+G[1]+\" has to be a Node, String or array of Nodes\");}else if((0,u.isNode)(I[G[2]]&&I[G[2]]))D+=I[G[2]].toTex(x);else throw new TypeError(\"Template: \"+\nG[1]+\"[\"+G[2]+\"] is not a Node.\");}return D+=w.slice(E)}var r=l.math,v=l.SymbolNode;h.prototype=new l.Node;h.prototype.type=\"FunctionNode\";h.prototype.isFunctionNode=!0;h.prototype._compile=function(w,B){if(!(this instanceof h))throw new TypeError(\"No valid FunctionNode\");var x=(0,p.map)(this.args,function(T){return T._compile(w,B)});if((0,u.isSymbolNode)(this.fn)){var D=function(T){return F in T?(0,g.getSafeProperty)(T,F):F in w?(0,g.getSafeProperty)(w,F):h.onUndefinedFunction(F)},F=this.fn.name,\nE=F in w?(0,g.getSafeProperty)(w,F):void 0;if(\"function\"===typeof E&&!0===E.rawArgs){var G=this.args;return function(T,Y,ca){return D(T)(G,w,f({},T,Y))}}if(1===x.length){var I=x[0];return function(T,Y,ca){return D(T)(I(T,Y,ca))}}if(2===x.length){var L=x[0],M=x[1];return function(T,Y,ca){return D(T)(L(T,Y,ca),M(T,Y,ca))}}return function(T,Y,ca){return D(T).apply(null,(0,p.map)(x,function(ka){return ka(T,Y,ca)}))}}if((0,u.isAccessorNode)(this.fn)&&(0,u.isIndexNode)(this.fn.index)&&this.fn.index.isObjectProperty()){var S=\nthis.fn.object._compile(w,B),P=this.fn.index.getObjectProperty(),R=this.args;return function(T,Y,ca){var ka=S(T,Y,ca);(0,g.validateSafeMethod)(ka,P);return ka[P]&&ka[P].rawArgs?ka[P](R,w,f({},T,Y)):ka[P].apply(ka,(0,p.map)(x,function(ha){return ha(T,Y,ca)}))}}var ba=this.fn._compile(w,B),Q=this.args;return function(T,Y,ca){var ka=ba(T,Y,ca);return ka&&ka.rawArgs?ka(Q,w,f({},T,Y)):ka.apply(ka,(0,p.map)(x,function(ha){return ha(T,Y,ca)}))}};h.prototype.forEach=function(w){w(this.fn,\"fn\",this);for(var B=\n0;B<this.args.length;B++)w(this.args[B],\"args[\"+B+\"]\",this)};h.prototype.map=function(w){for(var B=this._ifNode(w(this.fn,\"fn\",this)),x=[],D=0;D<this.args.length;D++)x[D]=this._ifNode(w(this.args[D],\"args[\"+D+\"]\",this));return new h(B,x)};h.prototype.clone=function(){return new h(this.fn,this.args.slice(0))};h.onUndefinedFunction=function(w){throw Error(\"Undefined function \"+w);};var C=h.prototype.toString;h.prototype.toString=function(w){var B,x=this.fn.toString(w);w&&\"object\"===q(w.handler)&&(0,\nt.hasOwnProperty)(w.handler,x)&&(B=w.handler[x](this,w));return\"undefined\"!==typeof B?B:C.call(this,w)};h.prototype._toString=function(w){var B=this.args.map(function(x){return x.toString(w)});return((0,u.isFunctionAssignmentNode)(this.fn)?\"(\"+this.fn.toString(w)+\")\":this.fn.toString(w))+\"(\"+B.join(\", \")+\")\"};h.prototype.toJSON=function(){return{mathjs:\"FunctionNode\",fn:this.fn,args:this.args}};h.fromJSON=function(w){return new h(w.fn,w.args)};h.prototype.toHTML=function(w){var B=this.args.map(function(x){return x.toHTML(w)});\nreturn'\\x3cspan class\\x3d\"math-function\"\\x3e'+(0,k.escape)(this.fn)+'\\x3c/span\\x3e\\x3cspan class\\x3d\"math-paranthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+B.join('\\x3cspan class\\x3d\"math-separator\"\\x3e,\\x3c/span\\x3e')+'\\x3cspan class\\x3d\"math-paranthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e'};var z=h.prototype.toTex;h.prototype.toTex=function(w){var B;w&&\"object\"===q(w.handler)&&(0,t.hasOwnProperty)(w.handler,this.name)&&(B=w.handler[this.name](this,w));return\"undefined\"!==typeof B?B:z.call(this,\nw)};h.prototype._toTex=function(w){var B=this.args.map(function(F){return F.toTex(w)}),x;d.latexFunctions[this.name]&&(x=d.latexFunctions[this.name]);!r[this.name]||\"function\"!==typeof r[this.name].toTex&&\"object\"!==q(r[this.name].toTex)&&\"string\"!==typeof r[this.name].toTex||(x=r[this.name].toTex);switch(q(x)){case \"function\":var D=x(this,w);break;case \"string\":D=n(x,this,w);break;case \"object\":switch(q(x[B.length])){case \"function\":D=x[B.length](this,w);break;case \"string\":D=n(x[B.length],this,\nw)}}return\"undefined\"!==typeof D?D:n(d.defaultTemplate,this,w)};h.prototype.getIdentifier=function(){return this.type+\":\"+this.name};return h},{isClass:!0,isNode:!0});a.createFunctionNode=b}","~:source","shadow$provide[270] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nvar createFunctionNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if ((0, _is.isSymbolNode)(this.fn)) {\n      var resolveFn = function resolveFn(scope) {\n        return _name in scope ? (0, _customs.getSafeProperty)(scope, _name) : _name in math ? (0, _customs.getSafeProperty)(math, _name) : FunctionNode.onUndefinedFunction(_name);\n      };\n\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? (0, _customs.getSafeProperty)(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = resolveFn(scope);\n          return fn(rawArgs, math, _extends({}, scope, args));\n        };\n      } else {\n        // \"regular\" evaluation\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n    } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        (0, _customs.validateSafeMethod)(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : object[prop].apply(object, (0, _array.map)(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : fn.apply(fn, (0, _array.map)(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (_typeof(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if ((0, _is.isNode)(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if ((0, _is.isNode)(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (_latex.latexFunctions[this.name]) {\n      latexConverter = _latex.latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (_typeof(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (_typeof(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(_latex.defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionNode = createFunctionNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$latex","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","onUndefinedFunction","forEach","fromJSON","isClass","toHTML","prototype","args","_toString","isNode","_toTex","__esModule","fn","toString","name","value","getIdentifier","toTex","isFunctionNode","mathjs","type","createFunctionNode","clone","set","_compile","get","toJSON"]],"~:compiled-at",1619135723970,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$FunctionNode.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js\"],\n\"sourcesContent\":[\"shadow$provide[270] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createFunctionNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _latex = require(\\\"../../utils/latex.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\\n\\nvar name = 'FunctionNode';\\nvar dependencies = ['math', 'Node', 'SymbolNode'];\\nvar createFunctionNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var math = _ref.math,\\n      Node = _ref.Node,\\n      SymbolNode = _ref.SymbolNode;\\n\\n  /**\\n   * @constructor FunctionNode\\n   * @extends {./Node}\\n   * invoke a list with arguments on a node\\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\\n   *                             the arguments, typically a SymboNode or AccessorNode\\n   * @param {./Node[]} args\\n   */\\n  function FunctionNode(fn, args) {\\n    if (!(this instanceof FunctionNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if (typeof fn === 'string') {\\n      fn = new SymbolNode(fn);\\n    } // validate input\\n\\n\\n    if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter \\\"fn\\\"');\\n\\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\\n      throw new TypeError('Array containing Nodes expected for parameter \\\"args\\\"');\\n    }\\n\\n    this.fn = fn;\\n    this.args = args || []; // readonly property name\\n\\n    Object.defineProperty(this, 'name', {\\n      get: function () {\\n        return this.fn.name || '';\\n      }.bind(this),\\n      set: function set() {\\n        throw new Error('Cannot assign a new name, name is read-only');\\n      }\\n    });\\n  }\\n\\n  FunctionNode.prototype = new Node();\\n  FunctionNode.prototype.type = 'FunctionNode';\\n  FunctionNode.prototype.isFunctionNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  FunctionNode.prototype._compile = function (math, argNames) {\\n    if (!(this instanceof FunctionNode)) {\\n      throw new TypeError('No valid FunctionNode');\\n    } // compile arguments\\n\\n\\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\\n      return arg._compile(math, argNames);\\n    });\\n\\n    if ((0, _is.isSymbolNode)(this.fn)) {\\n      var resolveFn = function resolveFn(scope) {\\n        return _name in scope ? (0, _customs.getSafeProperty)(scope, _name) : _name in math ? (0, _customs.getSafeProperty)(math, _name) : FunctionNode.onUndefinedFunction(_name);\\n      };\\n\\n      // we can statically determine whether the function has an rawArgs property\\n      var _name = this.fn.name;\\n      var fn = _name in math ? (0, _customs.getSafeProperty)(math, _name) : undefined;\\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\\n\\n      if (isRaw) {\\n        // pass unevaluated parameters (nodes) to the function\\n        // \\\"raw\\\" evaluation\\n        var rawArgs = this.args;\\n        return function evalFunctionNode(scope, args, context) {\\n          var fn = resolveFn(scope);\\n          return fn(rawArgs, math, _extends({}, scope, args));\\n        };\\n      } else {\\n        // \\\"regular\\\" evaluation\\n        if (evalArgs.length === 1) {\\n          var evalArg0 = evalArgs[0];\\n          return function evalFunctionNode(scope, args, context) {\\n            var fn = resolveFn(scope);\\n            return fn(evalArg0(scope, args, context));\\n          };\\n        } else if (evalArgs.length === 2) {\\n          var _evalArg = evalArgs[0];\\n          var evalArg1 = evalArgs[1];\\n          return function evalFunctionNode(scope, args, context) {\\n            var fn = resolveFn(scope);\\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\\n          };\\n        } else {\\n          return function evalFunctionNode(scope, args, context) {\\n            var fn = resolveFn(scope);\\n            return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\\n              return evalArg(scope, args, context);\\n            }));\\n          };\\n        }\\n      }\\n    } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {\\n      // execute the function with the right context: the object of the AccessorNode\\n      var evalObject = this.fn.object._compile(math, argNames);\\n\\n      var prop = this.fn.index.getObjectProperty();\\n      var _rawArgs = this.args;\\n      return function evalFunctionNode(scope, args, context) {\\n        var object = evalObject(scope, args, context);\\n        (0, _customs.validateSafeMethod)(object, prop);\\n        var isRaw = object[prop] && object[prop].rawArgs;\\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \\\"raw\\\" evaluation\\n        : object[prop].apply(object, (0, _array.map)(evalArgs, function (evalArg) {\\n          // \\\"regular\\\" evaluation\\n          return evalArg(scope, args, context);\\n        }));\\n      };\\n    } else {\\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\\n      // we have to dynamically determine whether the function has a rawArgs property\\n      var evalFn = this.fn._compile(math, argNames);\\n\\n      var _rawArgs2 = this.args;\\n      return function evalFunctionNode(scope, args, context) {\\n        var fn = evalFn(scope, args, context);\\n        var isRaw = fn && fn.rawArgs;\\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \\\"raw\\\" evaluation\\n        : fn.apply(fn, (0, _array.map)(evalArgs, function (evalArg) {\\n          // \\\"regular\\\" evaluation\\n          return evalArg(scope, args, context);\\n        }));\\n      };\\n    }\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  FunctionNode.prototype.forEach = function (callback) {\\n    callback(this.fn, 'fn', this);\\n\\n    for (var i = 0; i < this.args.length; i++) {\\n      callback(this.args[i], 'args[' + i + ']', this);\\n    }\\n  };\\n  /**\\n   * Create a new FunctionNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {FunctionNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  FunctionNode.prototype.map = function (callback) {\\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\\n\\n    var args = [];\\n\\n    for (var i = 0; i < this.args.length; i++) {\\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\\n    }\\n\\n    return new FunctionNode(fn, args);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {FunctionNode}\\n   */\\n\\n\\n  FunctionNode.prototype.clone = function () {\\n    return new FunctionNode(this.fn, this.args.slice(0));\\n  };\\n  /**\\n   * Throws an error 'Undefined function {name}'\\n   * @param {string} name\\n   */\\n\\n\\n  FunctionNode.onUndefinedFunction = function (name) {\\n    throw new Error('Undefined function ' + name);\\n  }; // backup Node's toString function\\n  // @private\\n\\n\\n  var nodeToString = FunctionNode.prototype.toString;\\n  /**\\n   * Get string representation. (wrapper function)\\n   * This overrides parts of Node's toString function.\\n   * If callback is an object containing callbacks, it\\n   * calls the correct callback for the current node,\\n   * otherwise it falls back to calling Node's toString\\n   * function.\\n   *\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n  FunctionNode.prototype.toString = function (options) {\\n    var customString;\\n    var name = this.fn.toString(options);\\n\\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, name)) {\\n      // callback is a map of callback functions\\n      customString = options.handler[name](this, options);\\n    }\\n\\n    if (typeof customString !== 'undefined') {\\n      return customString;\\n    } // fall back to Node's toString\\n\\n\\n    return nodeToString.call(this, options);\\n  };\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionNode.prototype._toString = function (options) {\\n    var args = this.args.map(function (arg) {\\n      return arg.toString(options);\\n    });\\n    var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \\\"add(2, 4.2)\\\"\\n\\n    return fn + '(' + args.join(', ') + ')';\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  FunctionNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'FunctionNode',\\n      fn: this.fn,\\n      args: this.args\\n    };\\n  };\\n  /**\\n   * Instantiate an AssignmentNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"FunctionNode\\\", fn: ..., args: ...}`,\\n   *                       where mathjs is optional\\n   * @returns {FunctionNode}\\n   */\\n\\n\\n  FunctionNode.fromJSON = function (json) {\\n    return new FunctionNode(json.fn, json.args);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionNode.prototype.toHTML = function (options) {\\n    var args = this.args.map(function (arg) {\\n      return arg.toHTML(options);\\n    }); // format the arguments like \\\"add(2, 4.2)\\\"\\n\\n    return '<span class=\\\"math-function\\\">' + (0, _string.escape)(this.fn) + '</span><span class=\\\"math-paranthesis math-round-parenthesis\\\">(</span>' + args.join('<span class=\\\"math-separator\\\">,</span>') + '<span class=\\\"math-paranthesis math-round-parenthesis\\\">)</span>';\\n  };\\n  /*\\n   * Expand a LaTeX template\\n   *\\n   * @param {string} template\\n   * @param {Node} node\\n   * @param {Object} options\\n   * @private\\n   **/\\n\\n\\n  function expandTemplate(template, node, options) {\\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\\n    // while submatching identifier and 2 (in the second case)\\n\\n    var regex = /\\\\$(?:\\\\{([a-z_][a-z_0-9]*)(?:\\\\[([0-9]+)\\\\])?\\\\}|\\\\$)/gi;\\n    var inputPos = 0; // position in the input string\\n\\n    var match;\\n\\n    while ((match = regex.exec(template)) !== null) {\\n      // go through all matches\\n      // add everything in front of the match to the LaTeX string\\n      latex += template.substring(inputPos, match.index);\\n      inputPos = match.index;\\n\\n      if (match[0] === '$$') {\\n        // escaped dollar sign\\n        latex += '$';\\n        inputPos++;\\n      } else {\\n        // template parameter\\n        inputPos += match[0].length;\\n        var property = node[match[1]];\\n\\n        if (!property) {\\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\\n        }\\n\\n        if (match[2] === undefined) {\\n          // no square brackets\\n          switch (_typeof(property)) {\\n            case 'string':\\n              latex += property;\\n              break;\\n\\n            case 'object':\\n              if ((0, _is.isNode)(property)) {\\n                latex += property.toTex(options);\\n              } else if (Array.isArray(property)) {\\n                // make array of Nodes into comma separated list\\n                latex += property.map(function (arg, index) {\\n                  if ((0, _is.isNode)(arg)) {\\n                    return arg.toTex(options);\\n                  }\\n\\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\\n                }).join(',');\\n              } else {\\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\\n              }\\n\\n              break;\\n\\n            default:\\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\\n          }\\n        } else {\\n          // with square brackets\\n          if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {\\n            latex += property[match[2]].toTex(options);\\n          } else {\\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\\n          }\\n        }\\n      }\\n    }\\n\\n    latex += template.slice(inputPos); // append rest of the template\\n\\n    return latex;\\n  } // backup Node's toTex function\\n  // @private\\n\\n\\n  var nodeToTex = FunctionNode.prototype.toTex;\\n  /**\\n   * Get LaTeX representation. (wrapper function)\\n   * This overrides parts of Node's toTex function.\\n   * If callback is an object containing callbacks, it\\n   * calls the correct callback for the current node,\\n   * otherwise it falls back to calling Node's toTex\\n   * function.\\n   *\\n   * @param {Object} options\\n   * @return {string}\\n   */\\n\\n  FunctionNode.prototype.toTex = function (options) {\\n    var customTex;\\n\\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, this.name)) {\\n      // callback is a map of callback functions\\n      customTex = options.handler[this.name](this, options);\\n    }\\n\\n    if (typeof customTex !== 'undefined') {\\n      return customTex;\\n    } // fall back to Node's toTex\\n\\n\\n    return nodeToTex.call(this, options);\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionNode.prototype._toTex = function (options) {\\n    var args = this.args.map(function (arg) {\\n      // get LaTeX of the arguments\\n      return arg.toTex(options);\\n    });\\n    var latexConverter;\\n\\n    if (_latex.latexFunctions[this.name]) {\\n      latexConverter = _latex.latexFunctions[this.name];\\n    } // toTex property on the function itself\\n\\n\\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\\n      // .toTex is a callback function\\n      latexConverter = math[this.name].toTex;\\n    }\\n\\n    var customToTex;\\n\\n    switch (_typeof(latexConverter)) {\\n      case 'function':\\n        // a callback function\\n        customToTex = latexConverter(this, options);\\n        break;\\n\\n      case 'string':\\n        // a template string\\n        customToTex = expandTemplate(latexConverter, this, options);\\n        break;\\n\\n      case 'object':\\n        // an object with different \\\"converters\\\" for different numbers of arguments\\n        switch (_typeof(latexConverter[args.length])) {\\n          case 'function':\\n            customToTex = latexConverter[args.length](this, options);\\n            break;\\n\\n          case 'string':\\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\\n            break;\\n        }\\n\\n    }\\n\\n    if (typeof customToTex !== 'undefined') {\\n      return customToTex;\\n    }\\n\\n    return expandTemplate(_latex.defaultTemplate, this, options);\\n  };\\n  /**\\n   * Get identifier.\\n   * @return {string}\\n   */\\n\\n\\n  FunctionNode.prototype.getIdentifier = function () {\\n    return this.type + ':' + this.name;\\n  };\\n\\n  return FunctionNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createFunctionNode = createFunctionNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_extends\",\"Object\",\"assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"hasOwnProperty\",\"call\",\"apply\",\"defineProperty\",\"value\",\"createFunctionNode\",\"_is\",\"_string\",\"_object\",\"_array\",\"_customs\",\"_factory\",\"_latex\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"FunctionNode\",\"fn\",\"args\",\"SyntaxError\",\"SymbolNode\",\"isNode\",\"TypeError\",\"Array\",\"isArray\",\"every\",\"get\",\"bind\",\"set\",\"Error\",\"expandTemplate\",\"template\",\"node\",\"options\",\"latex\",\"regex\",\"inputPos\",\"match\",\"exec\",\"substring\",\"index\",\"property\",\"ReferenceError\",\"undefined\",\"toTex\",\"map\",\"arg\",\"join\",\"slice\",\"math\",\"Node\",\"type\",\"isFunctionNode\",\"_compile\",\"FunctionNode.prototype._compile\",\"argNames\",\"evalArgs\",\"isSymbolNode\",\"resolveFn\",\"scope\",\"_name\",\"getSafeProperty\",\"onUndefinedFunction\",\"rawArgs\",\"evalFunctionNode\",\"context\",\"evalArg0\",\"_evalArg\",\"evalArg1\",\"evalArg\",\"isAccessorNode\",\"isIndexNode\",\"isObjectProperty\",\"evalObject\",\"object\",\"prop\",\"getObjectProperty\",\"_rawArgs\",\"validateSafeMethod\",\"evalFn\",\"_rawArgs2\",\"forEach\",\"FunctionNode.prototype.forEach\",\"callback\",\"FunctionNode.prototype.map\",\"_ifNode\",\"clone\",\"FunctionNode.prototype.clone\",\"FunctionNode.onUndefinedFunction\",\"nodeToString\",\"toString\",\"FunctionNode.prototype.toString\",\"customString\",\"handler\",\"_toString\",\"FunctionNode.prototype._toString\",\"isFunctionAssignmentNode\",\"toJSON\",\"FunctionNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"FunctionNode.fromJSON\",\"json\",\"toHTML\",\"FunctionNode.prototype.toHTML\",\"escape\",\"nodeToTex\",\"FunctionNode.prototype.toTex\",\"customTex\",\"_toTex\",\"FunctionNode.prototype._toTex\",\"latexConverter\",\"latexFunctions\",\"customToTex\",\"defaultTemplate\",\"getIdentifier\",\"FunctionNode.prototype.getIdentifier\",\"isClass\"]\n}\n"]