["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/solver/lsolveAll.js"],"~:js","shadow$provide[175]=function(c,b,y,a){function q(k){var t=Array.isArray(k)?f(k):void 0;t||(t=\"undefined\"!==typeof Symbol&&Symbol.iterator in Object(k)?Array.from(k):void 0);if(!t)a:{if(k){if(\"string\"===typeof k){t=f(k,void 0);break a}t=Object.prototype.toString.call(k).slice(8,-1);\"Object\"===t&&k.constructor&&(t=k.constructor.name);if(\"Map\"===t||\"Set\"===t){t=Array.from(k);break a}if(\"Arguments\"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)){t=f(k,void 0);break a}}t=void 0}if(!(k=t))throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\nreturn k}function f(k,t){if(null==t||t>k.length)t=k.length;for(var p=0,g=Array(t);p<t;p++)g[p]=k[p];return g}Object.defineProperty(a,\"__esModule\",{value:!0});a.createLsolveAll=void 0;c=b(25);var u=b(172);b=(0,c.factory)(\"lsolveAll\",\"typed matrix divideScalar multiplyScalar subtract equalScalar DenseMatrix\".split(\" \"),function(k){function t(z,w){w=[C(z,w,!0)._data.map(function(L){return L[0]})];var B=z._data,x=z._size[0];z=z._size[1];for(var D=0;D<z;D++)for(var F=w.length,E=0;E<F;E++){var G=w[E];if(!r(B[D][D],\n0)){G[D]=l(G[D],B[D][D]);for(var I=D+1;I<z;I++)G[I]=n(G[I],h(G[D],B[I][D]))}else if(!r(G[D],0)){if(0===E)return[];w.splice(E,1);--E;--F}else if(0===E){G=q(G);G[D]=1;for(I=D+1;I<z;I++)G[I]=n(G[I],B[I][D]);w.push(G)}}return w.map(function(L){return new v({data:L.map(function(M){return[M]}),size:[x,1]})})}function p(z,w){w=[C(z,w,!0)._data.map(function(T){return T[0]})];var B=z._size[0],x=z._size[1],D=z._values,F=z._index;z=z._ptr;for(var E=0;E<x;E++)for(var G=w.length,I=0;I<G;I++){for(var L=w[I],M=\n[],S=[],P=z[E+1],R=0,ba=z[E];ba<P;ba++){var Q=F[ba];Q===E?R=D[ba]:Q>E&&(M.push(D[ba]),S.push(Q))}if(!r(R,0))for(L[E]=l(L[E],R),P=0,R=S.length;P<R;P++)ba=S[P],L[ba]=n(L[ba],h(L[E],M[P]));else if(!r(L[E],0)){if(0===I)return[];w.splice(I,1);--I;--G}else if(0===I){L=q(L);L[E]=1;P=0;for(R=S.length;P<R;P++)ba=S[P],L[ba]=n(L[ba],M[P]);w.push(L)}}return w.map(function(T){return new v({data:T.map(function(Y){return[Y]}),size:[B,1]})})}var g=k.typed,d=k.matrix,l=k.divideScalar,h=k.multiplyScalar,n=k.subtract,\nr=k.equalScalar,v=k.DenseMatrix,C=(0,u.createSolveValidation)({DenseMatrix:v});return g(\"lsolveAll\",{\"SparseMatrix, Array | Matrix\":function(z,w){return p(z,w)},\"DenseMatrix, Array | Matrix\":function(z,w){return t(z,w)},\"Array, Array | Matrix\":function(z,w){z=d(z);return t(z,w).map(function(B){return B.valueOf()})}})});a.createLsolveAll=b}","~:source","shadow$provide[175] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLsolveAll = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar name = 'lsolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createLsolveAll = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolveAll(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\n   *\n   * See also:\n   *\n   *    lsolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var R = _denseForwardSubstitution(m, b);\n\n      return R.map(function (r) {\n        return r.valueOf();\n      });\n    }\n  });\n\n  function _denseForwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // loop columns\n\n    for (var i = 0; i < columns; i++) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], M[i][i]);\n\n          for (var j = i + 1; j < columns; j++) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1;\n\n          for (var _j = i + 1; _j < columns; _j++) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // loop columns\n\n    for (var i = 0; i < columns; i++) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k]; // values & indices (column i)\n\n        var iValues = [];\n        var iIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1]; // find the value at [i, i]\n\n        var Mii = 0;\n\n        for (var j = firstIndex; j < lastIndex; j++) {\n          var J = index[j]; // check row\n\n          if (J === i) {\n            Mii = values[j];\n          } else if (J > i) {\n            // store lower triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], Mii);\n\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1;\n\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n});\nexports.createLsolveAll = createLsolveAll;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["DenseMatrix","__esModule","value","createLsolveAll","size","data"]],"~:compiled-at",1619135723902,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$lsolveAll.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/solver/lsolveAll.js\"],\n\"sourcesContent\":[\"shadow$provide[175] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createLsolveAll = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _solveValidation = require(\\\"./utils/solveValidation.js\\\");\\n\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError(\\\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _iterableToArray(iter) { if (typeof Symbol !== \\\"undefined\\\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nvar name = 'lsolveAll';\\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\\nvar createLsolveAll = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divideScalar = _ref.divideScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      subtract = _ref.subtract,\\n      equalScalar = _ref.equalScalar,\\n      DenseMatrix = _ref.DenseMatrix;\\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\\n    DenseMatrix: DenseMatrix\\n  });\\n  /**\\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\\n   *\\n   * `L * x = b`\\n   *\\n   * Syntax:\\n   *\\n   *    math.lsolveAll(L, b)\\n   *\\n   * Examples:\\n   *\\n   *    const a = [[-2, 3], [2, 1]]\\n   *    const b = [11, 9]\\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\\n   *\\n   * See also:\\n   *\\n   *    lsolve, lup, slu, usolve, lusolve\\n   *\\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\\n   * @param {Matrix, Array} b       A column vector with the b values\\n   *\\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\\n   */\\n\\n  return typed(name, {\\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\\n      return _sparseForwardSubstitution(m, b);\\n    },\\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\\n      return _denseForwardSubstitution(m, b);\\n    },\\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\\n      var m = matrix(a);\\n\\n      var R = _denseForwardSubstitution(m, b);\\n\\n      return R.map(function (r) {\\n        return r.valueOf();\\n      });\\n    }\\n  });\\n\\n  function _denseForwardSubstitution(m, b_) {\\n    // the algorithm is derived from\\n    // https://www.overleaf.com/read/csvgqdxggyjv\\n    // array of right-hand sides\\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\\n      return e[0];\\n    })];\\n    var M = m._data;\\n    var rows = m._size[0];\\n    var columns = m._size[1]; // loop columns\\n\\n    for (var i = 0; i < columns; i++) {\\n      var L = B.length; // loop right-hand sides\\n\\n      for (var k = 0; k < L; k++) {\\n        var b = B[k];\\n\\n        if (!equalScalar(M[i][i], 0)) {\\n          // non-singular row\\n          b[i] = divideScalar(b[i], M[i][i]);\\n\\n          for (var j = i + 1; j < columns; j++) {\\n            // b[j] -= b[i] * M[j,i]\\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\\n          }\\n        } else if (!equalScalar(b[i], 0)) {\\n          // singular row, nonzero RHS\\n          if (k === 0) {\\n            // There is no valid solution\\n            return [];\\n          } else {\\n            // This RHS is invalid but other solutions may still exist\\n            B.splice(k, 1);\\n            k -= 1;\\n            L -= 1;\\n          }\\n        } else if (k === 0) {\\n          // singular row, RHS is zero\\n          var bNew = _toConsumableArray(b);\\n\\n          bNew[i] = 1;\\n\\n          for (var _j = i + 1; _j < columns; _j++) {\\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\\n          }\\n\\n          B.push(bNew);\\n        }\\n      }\\n    }\\n\\n    return B.map(function (x) {\\n      return new DenseMatrix({\\n        data: x.map(function (e) {\\n          return [e];\\n        }),\\n        size: [rows, 1]\\n      });\\n    });\\n  }\\n\\n  function _sparseForwardSubstitution(m, b_) {\\n    // array of right-hand sides\\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\\n      return e[0];\\n    })];\\n    var rows = m._size[0];\\n    var columns = m._size[1];\\n    var values = m._values;\\n    var index = m._index;\\n    var ptr = m._ptr; // loop columns\\n\\n    for (var i = 0; i < columns; i++) {\\n      var L = B.length; // loop right-hand sides\\n\\n      for (var k = 0; k < L; k++) {\\n        var b = B[k]; // values & indices (column i)\\n\\n        var iValues = [];\\n        var iIndices = []; // first & last indeces in column\\n\\n        var firstIndex = ptr[i];\\n        var lastIndex = ptr[i + 1]; // find the value at [i, i]\\n\\n        var Mii = 0;\\n\\n        for (var j = firstIndex; j < lastIndex; j++) {\\n          var J = index[j]; // check row\\n\\n          if (J === i) {\\n            Mii = values[j];\\n          } else if (J > i) {\\n            // store lower triangular\\n            iValues.push(values[j]);\\n            iIndices.push(J);\\n          }\\n        }\\n\\n        if (!equalScalar(Mii, 0)) {\\n          // non-singular row\\n          b[i] = divideScalar(b[i], Mii);\\n\\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\\n            var _J = iIndices[_j2];\\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\\n          }\\n        } else if (!equalScalar(b[i], 0)) {\\n          // singular row, nonzero RHS\\n          if (k === 0) {\\n            // There is no valid solution\\n            return [];\\n          } else {\\n            // This RHS is invalid but other solutions may still exist\\n            B.splice(k, 1);\\n            k -= 1;\\n            L -= 1;\\n          }\\n        } else if (k === 0) {\\n          // singular row, RHS is zero\\n          var bNew = _toConsumableArray(b);\\n\\n          bNew[i] = 1;\\n\\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\\n            var _J2 = iIndices[_j3];\\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\\n          }\\n\\n          B.push(bNew);\\n        }\\n      }\\n    }\\n\\n    return B.map(function (x) {\\n      return new DenseMatrix({\\n        data: x.map(function (e) {\\n          return [e];\\n        }),\\n        size: [rows, 1]\\n      });\\n    });\\n  }\\n});\\nexports.createLsolveAll = createLsolveAll;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_toConsumableArray\",\"arr\",\"Array\",\"isArray\",\"_arrayLikeToArray\",\"Symbol\",\"iterator\",\"Object\",\"iter\",\"from\",\"o\",\"minLen\",\"n\",\"prototype\",\"toString\",\"call\",\"slice\",\"constructor\",\"name\",\"test\",\"TypeError\",\"len\",\"length\",\"i\",\"arr2\",\"defineProperty\",\"value\",\"createLsolveAll\",\"_factory\",\"_solveValidation\",\"factory\",\"dependencies\",\"_ref\",\"_denseForwardSubstitution\",\"m\",\"b_\",\"B\",\"solveValidation\",\"_data\",\"map\",\"e\",\"M\",\"rows\",\"_size\",\"columns\",\"L\",\"k\",\"b\",\"equalScalar\",\"divideScalar\",\"j\",\"subtract\",\"multiplyScalar\",\"splice\",\"bNew\",\"_j\",\"push\",\"x\",\"DenseMatrix\",\"data\",\"size\",\"_sparseForwardSubstitution\",\"values\",\"_values\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"iValues\",\"iIndices\",\"lastIndex\",\"Mii\",\"firstIndex\",\"J\",\"_lastIndex\",\"_j2\",\"_J\",\"_j3\",\"_lastIndex2\",\"_J2\",\"typed\",\"matrix\",\"createSolveValidation\",\"SparseMatrixArrayMatrix\",\"DenseMatrixArrayMatrix\",\"ArrayArrayMatrix\",\"a\",\"R\",\"r\",\"valueOf\"]\n}\n"]