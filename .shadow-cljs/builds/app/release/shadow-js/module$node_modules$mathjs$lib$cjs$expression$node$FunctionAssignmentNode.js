["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js"],"~:js","shadow$provide[262]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createFunctionAssignmentNode=void 0;var q=b(14),f=b(248),u=b(21),k=b(24),t=b(260),p=b(255),g=b(147);c=b(25);c=(0,c.factory)(\"FunctionAssignmentNode\",[\"typed\",\"Node\"],function(d){function l(r,v,C){if(!(this instanceof l))throw new SyntaxError(\"Constructor must be called with the new operator\");if(\"string\"!==typeof r)throw new TypeError('String expected for parameter \"name\"');if(!Array.isArray(v))throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\nif(!(0,q.isNode)(C))throw new TypeError('Node expected for parameter \"expr\"');if(r in f.keywords)throw Error('Illegal function name, \"'+r+'\" is a reserved keyword');this.name=r;this.params=v.map(function(z){return z&&z.name||z});this.types=v.map(function(z){return z&&z.type||\"any\"});this.expr=C}function h(r,v){var C=(0,p.getPrecedence)(r,v);r=(0,p.getPrecedence)(r.expr,v);return\"all\"===v||null!==r&&r<=C}var n=d.typed;l.prototype=new d.Node;l.prototype.type=\"FunctionAssignmentNode\";l.prototype.isFunctionAssignmentNode=\n!0;l.prototype._compile=function(r,v){var C=Object.create(v);(0,k.forEach)(this.params,function(F){C[F]=!0});var z=this.expr._compile(r,C),w=this.name,B=this.params,x=(0,k.join)(this.types,\",\"),D=w+\"(\"+(0,k.join)(this.params,\", \")+\")\";return function(F,E,G){var I={};I[x]=function(){for(var L=Object.create(E),M=0;M<B.length;M++)L[B[M]]=arguments[M];return z(F,L,G)};I=n(w,I);I.syntax=D;(0,g.setSafeProperty)(F,w,I);return I}};l.prototype.forEach=function(r){r(this.expr,\"expr\",this)};l.prototype.map=\nfunction(r){r=this._ifNode(r(this.expr,\"expr\",this));return new l(this.name,this.params.slice(0),r)};l.prototype.clone=function(){return new l(this.name,this.params.slice(0),this.expr)};l.prototype._toString=function(r){var v=r&&r.parenthesis?r.parenthesis:\"keep\";r=this.expr.toString(r);h(this,v)&&(r=\"(\"+r+\")\");return this.name+\"(\"+this.params.join(\", \")+\") \\x3d \"+r};l.prototype.toJSON=function(){var r=this.types;return{mathjs:\"FunctionAssignmentNode\",name:this.name,params:this.params.map(function(v,\nC){return{name:v,type:r[C]}}),expr:this.expr}};l.fromJSON=function(r){return new l(r.name,r.params,r.expr)};l.prototype.toHTML=function(r){for(var v=r&&r.parenthesis?r.parenthesis:\"keep\",C=[],z=0;z<this.params.length;z++)C.push('\\x3cspan class\\x3d\"math-symbol math-parameter\"\\x3e'+(0,u.escape)(this.params[z])+\"\\x3c/span\\x3e\");r=this.expr.toHTML(r);h(this,v)&&(r='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+r+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e');\nreturn'\\x3cspan class\\x3d\"math-function\"\\x3e'+(0,u.escape)(this.name)+'\\x3c/span\\x3e\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+C.join('\\x3cspan class\\x3d\"math-separator\"\\x3e,\\x3c/span\\x3e')+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e\\x3cspan class\\x3d\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\"\\x3e\\x3d\\x3c/span\\x3e'+r};l.prototype._toTex=function(r){var v=r&&r.parenthesis?r.parenthesis:\n\"keep\";r=this.expr.toTex(r);h(this,v)&&(r=\"\\\\left(\".concat(r,\"\\\\right)\"));return\"\\\\mathrm{\"+this.name+\"}\\\\left(\"+this.params.map(t.toSymbol).join(\",\")+\"\\\\right):\\x3d\"+r};return l},{isClass:!0,isNode:!0});a.createFunctionAssignmentNode=c}","~:source","shadow$provide[262] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionAssignmentNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _keywords = require(\"../keywords.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      Node = _ref.Node;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!(0, _is.isNode)(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (name in _keywords.keywords) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    (0, _array.forEach)(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = (0, _array.join)(this.types, ',');\n    var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      (0, _customs.setSafeProperty)(scope, name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + (0, _string.escape)(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$module$node_modules$mathjs$lib$cjs$expression$operators","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$latex","~$module$node_modules$mathjs$lib$cjs$expression$keywords","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","expr","forEach","fromJSON","isClass","createFunctionAssignmentNode","toHTML","params","isFunctionAssignmentNode","prototype","_toString","isNode","_toTex","__esModule","types","name","value","mathjs","type","syntax","clone","_compile","toJSON"]],"~:compiled-at",1619135723963,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$FunctionAssignmentNode.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js\"],\n\"sourcesContent\":[\"shadow$provide[262] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createFunctionAssignmentNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _keywords = require(\\\"../keywords.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _latex = require(\\\"../../utils/latex.js\\\");\\n\\nvar _operators = require(\\\"../operators.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'FunctionAssignmentNode';\\nvar dependencies = ['typed', 'Node'];\\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      Node = _ref.Node;\\n\\n  /**\\n   * @constructor FunctionAssignmentNode\\n   * @extends {Node}\\n   * Function assignment\\n   *\\n   * @param {string} name           Function name\\n   * @param {string[] | Array.<{name: string, type: string}>} params\\n   *                                Array with function parameter names, or an\\n   *                                array with objects containing the name\\n   *                                and type of the parameter\\n   * @param {Node} expr             The function expression\\n   */\\n  function FunctionAssignmentNode(name, params, expr) {\\n    if (!(this instanceof FunctionAssignmentNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // validate input\\n\\n\\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \\\"name\\\"');\\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \\\"params\\\"');\\n    if (!(0, _is.isNode)(expr)) throw new TypeError('Node expected for parameter \\\"expr\\\"');\\n    if (name in _keywords.keywords) throw new Error('Illegal function name, \\\"' + name + '\\\" is a reserved keyword');\\n    this.name = name;\\n    this.params = params.map(function (param) {\\n      return param && param.name || param;\\n    });\\n    this.types = params.map(function (param) {\\n      return param && param.type || 'any';\\n    });\\n    this.expr = expr;\\n  }\\n\\n  FunctionAssignmentNode.prototype = new Node();\\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\\n    var childArgNames = Object.create(argNames);\\n    (0, _array.forEach)(this.params, function (param) {\\n      childArgNames[param] = true;\\n    }); // compile the function expression with the child args\\n\\n    var evalExpr = this.expr._compile(math, childArgNames);\\n\\n    var name = this.name;\\n    var params = this.params;\\n    var signature = (0, _array.join)(this.types, ',');\\n    var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\\n    return function evalFunctionAssignmentNode(scope, args, context) {\\n      var signatures = {};\\n\\n      signatures[signature] = function () {\\n        var childArgs = Object.create(args);\\n\\n        for (var i = 0; i < params.length; i++) {\\n          childArgs[params[i]] = arguments[i];\\n        }\\n\\n        return evalExpr(scope, childArgs, context);\\n      };\\n\\n      var fn = typed(name, signatures);\\n      fn.syntax = syntax;\\n      (0, _customs.setSafeProperty)(scope, name, fn);\\n      return fn;\\n    };\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\\n    callback(this.expr, 'expr', this);\\n  };\\n  /**\\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype.map = function (callback) {\\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\\n\\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {FunctionAssignmentNode}\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype.clone = function () {\\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\\n  };\\n  /**\\n   * Is parenthesis needed?\\n   * @param {Node} node\\n   * @param {Object} parenthesis\\n   * @private\\n   */\\n\\n\\n  function needParenthesis(node, parenthesis) {\\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis);\\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\\n  }\\n  /**\\n   * get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype._toString = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var expr = this.expr.toString(options);\\n\\n    if (needParenthesis(this, parenthesis)) {\\n      expr = '(' + expr + ')';\\n    }\\n\\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype.toJSON = function () {\\n    var types = this.types;\\n    return {\\n      mathjs: 'FunctionAssignmentNode',\\n      name: this.name,\\n      params: this.params.map(function (param, index) {\\n        return {\\n          name: param,\\n          type: types[index]\\n        };\\n      }),\\n      expr: this.expr\\n    };\\n  };\\n  /**\\n   * Instantiate an FunctionAssignmentNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"FunctionAssignmentNode\\\", name: ..., params: ..., expr: ...}`,\\n   *                       where mathjs is optional\\n   * @returns {FunctionAssignmentNode}\\n   */\\n\\n\\n  FunctionAssignmentNode.fromJSON = function (json) {\\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\\n  };\\n  /**\\n   * get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var params = [];\\n\\n    for (var i = 0; i < this.params.length; i++) {\\n      params.push('<span class=\\\"math-symbol math-parameter\\\">' + (0, _string.escape)(this.params[i]) + '</span>');\\n    }\\n\\n    var expr = this.expr.toHTML(options);\\n\\n    if (needParenthesis(this, parenthesis)) {\\n      expr = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + expr + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    return '<span class=\\\"math-function\\\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + params.join('<span class=\\\"math-separator\\\">,</span>') + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span><span class=\\\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\\\">=</span>' + expr;\\n  };\\n  /**\\n   * get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  FunctionAssignmentNode.prototype._toTex = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var expr = this.expr.toTex(options);\\n\\n    if (needParenthesis(this, parenthesis)) {\\n      expr = \\\"\\\\\\\\left(\\\".concat(expr, \\\"\\\\\\\\right)\\\");\\n    }\\n\\n    return '\\\\\\\\mathrm{' + this.name + '}\\\\\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\\\\\right):=' + expr;\\n  };\\n\\n  return FunctionAssignmentNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createFunctionAssignmentNode\",\"_is\",\"_keywords\",\"_string\",\"_array\",\"_latex\",\"_operators\",\"_customs\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"FunctionAssignmentNode\",\"params\",\"expr\",\"SyntaxError\",\"TypeError\",\"Array\",\"isArray\",\"isNode\",\"keywords\",\"Error\",\"map\",\"param\",\"types\",\"type\",\"needParenthesis\",\"node\",\"parenthesis\",\"precedence\",\"getPrecedence\",\"exprPrecedence\",\"typed\",\"prototype\",\"Node\",\"isFunctionAssignmentNode\",\"_compile\",\"FunctionAssignmentNode.prototype._compile\",\"math\",\"argNames\",\"childArgNames\",\"create\",\"forEach\",\"evalExpr\",\"signature\",\"join\",\"syntax\",\"evalFunctionAssignmentNode\",\"scope\",\"args\",\"context\",\"signatures\",\"childArgs\",\"i\",\"length\",\"arguments\",\"fn\",\"setSafeProperty\",\"FunctionAssignmentNode.prototype.forEach\",\"callback\",\"FunctionAssignmentNode.prototype.map\",\"_ifNode\",\"slice\",\"clone\",\"FunctionAssignmentNode.prototype.clone\",\"_toString\",\"FunctionAssignmentNode.prototype._toString\",\"options\",\"toString\",\"toJSON\",\"FunctionAssignmentNode.prototype.toJSON\",\"mathjs\",\"index\",\"fromJSON\",\"FunctionAssignmentNode.fromJSON\",\"json\",\"toHTML\",\"FunctionAssignmentNode.prototype.toHTML\",\"push\",\"escape\",\"_toTex\",\"FunctionAssignmentNode.prototype._toTex\",\"toTex\",\"concat\",\"toSymbol\",\"isClass\"]\n}\n"]