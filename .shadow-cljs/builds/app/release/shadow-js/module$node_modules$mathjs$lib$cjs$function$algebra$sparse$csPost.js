["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csPost.js"],"~:js","shadow$provide[280]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.csPost=function(f,u){if(!f)return null;var k=0,t,p=[],g=[],d=2*u;for(t=0;t<u;t++)g[0+t]=-1;for(t=u-1;0<=t;t--)-1!==f[t]&&(g[u+t]=g[0+f[t]],g[0+f[t]]=t);for(t=0;t<u;t++)-1===f[t]&&(k=(0,q.csTdfs)(t,k,g,0,u,p,d));return p};var q=b(279)}","~:source","shadow$provide[280] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csPost = csPost;\n\nvar _csTdfs = require(\"./csTdfs.js\");\n\n/**\n * Post order a tree of forest\n *\n * @param {Array}   parent          The tree or forest\n * @param {Number}  n               Number of columns\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csPost(parent, n) {\n  // check inputs\n  if (!parent) {\n    return null;\n  } // vars\n\n\n  var k = 0;\n  var j; // allocate result\n\n  var post = []; // (n)\n  // workspace, head: first n entries, next: next n entries, stack: last n entries\n\n  var w = []; // (3 * n)\n\n  var head = 0;\n  var next = n;\n  var stack = 2 * n; // initialize workspace\n\n  for (j = 0; j < n; j++) {\n    // empty linked lists\n    w[head + j] = -1;\n  } // traverse nodes in reverse order\n\n\n  for (j = n - 1; j >= 0; j--) {\n    // check j is a root\n    if (parent[j] === -1) {\n      continue;\n    } // add j to list of its parent\n\n\n    w[next + j] = w[head + parent[j]];\n    w[head + parent[j]] = j;\n  } // loop nodes\n\n\n  for (j = 0; j < n; j++) {\n    // skip j if it is not a root\n    if (parent[j] !== -1) {\n      continue;\n    } // depth-first search\n\n\n    k = (0, _csTdfs.csTdfs)(j, k, w, head, next, post, stack);\n  }\n\n  return post;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csTdfs","~$shadow.js"]],"~:properties",["^5",["csPost","__esModule","value"]],"~:compiled-at",1619135723976,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPost.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,MAAR,CAYAA,QAAe,CAACC,CAAD,CAASC,CAAT,CAAY,CAEzB,GAAI,CAACD,CAAL,CACE,MAAO,KAIT,KAAIE,EAAI,CAAR,CACIC,CADJ,CAGIC,EAAO,EAHX,CAMIC,EAAI,EANR,CAUIC,EAAQ,CAARA,CAAYL,CAEhB,KAAKE,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBF,CAAhB,CAAmBE,CAAA,EAAnB,CAEEE,CAAA,CANSE,CAMT,CAASJ,CAAT,CAAA,CAAc,EAIhB,KAAKA,CAAL,CAASF,CAAT,CAAa,CAAb,CAAqB,CAArB,EAAgBE,CAAhB,CAAwBA,CAAA,EAAxB,CAEoB,EAAlB,GAAIH,CAAA,CAAOG,CAAP,CAAJ,GAKAE,CAAA,CAhBSJ,CAgBT,CAASE,CAAT,CACA,CADcE,CAAA,CAjBLE,CAiBK,CAASP,CAAA,CAAOG,CAAP,CAAT,CACd,CAAAE,CAAA,CAlBSE,CAkBT,CAASP,CAAA,CAAOG,CAAP,CAAT,CAAA,CAAsBA,CANtB,CAUF,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBF,CAAhB,CAAmBE,CAAA,EAAnB,CAEoB,EAAlB,GAAIH,CAAA,CAAOG,CAAP,CAAJ,GAKAD,CALA,CAKI,CAAC,CAAA,CAAGM,CAAQC,CAAAA,MAAZ,EAAoBN,CAApB,CAAuBD,CAAvB,CAA0BG,CAA1B,CA7BKE,CA6BL,CA5BKN,CA4BL,CAAyCG,CAAzC,CAA+CE,CAA/C,CALJ,CAQF,OAAOF,EA/CkB,CAV3B,KAAII,EAAUf,CAAA,CAAQ,GAAR,CARgD;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csPost.js\"],\n\"sourcesContent\":[\"shadow$provide[280] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.csPost = csPost;\\n\\nvar _csTdfs = require(\\\"./csTdfs.js\\\");\\n\\n/**\\n * Post order a tree of forest\\n *\\n * @param {Array}   parent          The tree or forest\\n * @param {Number}  n               Number of columns\\n *\\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n */\\nfunction csPost(parent, n) {\\n  // check inputs\\n  if (!parent) {\\n    return null;\\n  } // vars\\n\\n\\n  var k = 0;\\n  var j; // allocate result\\n\\n  var post = []; // (n)\\n  // workspace, head: first n entries, next: next n entries, stack: last n entries\\n\\n  var w = []; // (3 * n)\\n\\n  var head = 0;\\n  var next = n;\\n  var stack = 2 * n; // initialize workspace\\n\\n  for (j = 0; j < n; j++) {\\n    // empty linked lists\\n    w[head + j] = -1;\\n  } // traverse nodes in reverse order\\n\\n\\n  for (j = n - 1; j >= 0; j--) {\\n    // check j is a root\\n    if (parent[j] === -1) {\\n      continue;\\n    } // add j to list of its parent\\n\\n\\n    w[next + j] = w[head + parent[j]];\\n    w[head + parent[j]] = j;\\n  } // loop nodes\\n\\n\\n  for (j = 0; j < n; j++) {\\n    // skip j if it is not a root\\n    if (parent[j] !== -1) {\\n      continue;\\n    } // depth-first search\\n\\n\\n    k = (0, _csTdfs.csTdfs)(j, k, w, head, next, post, stack);\\n  }\\n\\n  return post;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"csPost\",\"parent\",\"n\",\"k\",\"j\",\"post\",\"w\",\"stack\",\"head\",\"_csTdfs\",\"csTdfs\"]\n}\n"]