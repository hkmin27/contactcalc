["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js"],"~:js","shadow$provide[258]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createConditionalNode=void 0;var q=b(14);c=b(25);var f=b(255);b=(0,c.factory)(\"ConditionalNode\",[\"Node\"],function(u){function k(p,g,d){if(!(this instanceof k))throw new SyntaxError(\"Constructor must be called with the new operator\");if(!(0,q.isNode)(p))throw new TypeError(\"Parameter condition must be a Node\");if(!(0,q.isNode)(g))throw new TypeError(\"Parameter trueExpr must be a Node\");if(!(0,q.isNode)(d))throw new TypeError(\"Parameter falseExpr must be a Node\");\nthis.condition=p;this.trueExpr=g;this.falseExpr=d}function t(p){if(\"number\"===typeof p||\"boolean\"===typeof p||\"string\"===typeof p)return!!p;if(p){if((0,q.isBigNumber)(p))return!p.isZero();if((0,q.isComplex)(p))return!(!p.re&&!p.im);if((0,q.isUnit)(p))return!!p.value}if(null===p||void 0===p)return!1;throw new TypeError('Unsupported type of condition \"'+(0,q.typeOf)(p)+'\"');}k.prototype=new u.Node;k.prototype.type=\"ConditionalNode\";k.prototype.isConditionalNode=!0;k.prototype._compile=function(p,g){var d=\nthis.condition._compile(p,g),l=this.trueExpr._compile(p,g),h=this.falseExpr._compile(p,g);return function(n,r,v){return t(d(n,r,v))?l(n,r,v):h(n,r,v)}};k.prototype.forEach=function(p){p(this.condition,\"condition\",this);p(this.trueExpr,\"trueExpr\",this);p(this.falseExpr,\"falseExpr\",this)};k.prototype.map=function(p){return new k(this._ifNode(p(this.condition,\"condition\",this)),this._ifNode(p(this.trueExpr,\"trueExpr\",this)),this._ifNode(p(this.falseExpr,\"falseExpr\",this)))};k.prototype.clone=function(){return new k(this.condition,\nthis.trueExpr,this.falseExpr)};k.prototype._toString=function(p){var g=p&&p.parenthesis?p.parenthesis:\"keep\",d=(0,f.getPrecedence)(this,g),l=this.condition.toString(p),h=(0,f.getPrecedence)(this.condition,g);if(\"all\"===g||\"OperatorNode\"===this.condition.type||null!==h&&h<=d)l=\"(\"+l+\")\";h=this.trueExpr.toString(p);var n=(0,f.getPrecedence)(this.trueExpr,g);if(\"all\"===g||\"OperatorNode\"===this.trueExpr.type||null!==n&&n<=d)h=\"(\"+h+\")\";p=this.falseExpr.toString(p);n=(0,f.getPrecedence)(this.falseExpr,\ng);if(\"all\"===g||\"OperatorNode\"===this.falseExpr.type||null!==n&&n<=d)p=\"(\"+p+\")\";return l+\" ? \"+h+\" : \"+p};k.prototype.toJSON=function(){return{mathjs:\"ConditionalNode\",condition:this.condition,trueExpr:this.trueExpr,falseExpr:this.falseExpr}};k.fromJSON=function(p){return new k(p.condition,p.trueExpr,p.falseExpr)};k.prototype.toHTML=function(p){var g=p&&p.parenthesis?p.parenthesis:\"keep\",d=(0,f.getPrecedence)(this,g),l=this.condition.toHTML(p),h=(0,f.getPrecedence)(this.condition,g);if(\"all\"===\ng||\"OperatorNode\"===this.condition.type||null!==h&&h<=d)l='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+l+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e';h=this.trueExpr.toHTML(p);var n=(0,f.getPrecedence)(this.trueExpr,g);if(\"all\"===g||\"OperatorNode\"===this.trueExpr.type||null!==n&&n<=d)h='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+h+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e';\np=this.falseExpr.toHTML(p);n=(0,f.getPrecedence)(this.falseExpr,g);if(\"all\"===g||\"OperatorNode\"===this.falseExpr.type||null!==n&&n<=d)p='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+p+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e';return l+'\\x3cspan class\\x3d\"math-operator math-conditional-operator\"\\x3e?\\x3c/span\\x3e'+h+'\\x3cspan class\\x3d\"math-operator math-conditional-operator\"\\x3e:\\x3c/span\\x3e'+p};k.prototype._toTex=function(p){return\"\\\\begin{cases} {\"+\nthis.trueExpr.toTex(p)+\"}, \\x26\\\\quad{\\\\text{if }\\\\;\"+this.condition.toTex(p)+\"}\\\\\\\\{\"+this.falseExpr.toTex(p)+\"}, \\x26\\\\quad{\\\\text{otherwise}}\\\\end{cases}\"};return k},{isClass:!0,isNode:!0});a.createConditionalNode=b}","~:source","shadow$provide[258] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!(0, _is.isNode)(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!(0, _is.isNode)(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!(0, _is.isNode)(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$expression$operators","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","falseExpr","forEach","fromJSON","isClass","toHTML","prototype","_toString","isNode","_toTex","__esModule","condition","createConditionalNode","value","trueExpr","mathjs","type","clone","isConditionalNode","_compile","toJSON"]],"~:compiled-at",1619135723958,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$ConditionalNode.js\",\n\"lineCount\":8,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,qBAAR,CAAgC,IAAK,EAErC,KAAIC,EAAMP,CAAA,CAAQ,EAAR,CAENQ,EAAAA,CAAWR,CAAA,CAAQ,EAAR,CAEf,KAAIS,EAAaT,CAAA,CAAQ,GAAR,CAIbM,EAAAA,CAAuC,CAAC,CAAA,CAAGE,CAASE,CAAAA,OAAb,EAFhCC,iBAEgC,CADxBC,CAAC,MAADA,CACwB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAanGC,QAASA,EAAe,CAACC,CAAD,CAAYC,CAAZ,CAAsBC,CAAtB,CAAiC,CACvD,GAAI,EAAE,IAAF,WAAkBH,EAAlB,CAAJ,CACE,KAAM,KAAII,WAAJ,CAAgB,kDAAhB,CAAN,CAGF,GAAI,CAAC,CAAC,CAAA,CAAGX,CAAIY,CAAAA,MAAR,EAAgBJ,CAAhB,CAAL,CAAiC,KAAM,KAAIK,SAAJ,CAAc,oCAAd,CAAN,CACjC,GAAI,CAAC,CAAC,CAAA,CAAGb,CAAIY,CAAAA,MAAR,EAAgBH,CAAhB,CAAL,CAAgC,KAAM,KAAII,SAAJ,CAAc,mCAAd,CAAN,CAChC,GAAI,CAAC,CAAC,CAAA,CAAGb,CAAIY,CAAAA,MAAR,EAAgBF,CAAhB,CAAL,CAAiC,KAAM,KAAIG,SAAJ,CAAc,oCAAd,CAAN;AACjC,IAAKL,CAAAA,SAAL,CAAiBA,CACjB,KAAKC,CAAAA,QAAL,CAAgBA,CAChB,KAAKC,CAAAA,SAAL,CAAiBA,CAVsC,CA6LzDI,QAASA,EAAa,CAACN,CAAD,CAAY,CAChC,GAAyB,QAAzB,GAAI,MAAOA,EAAX,EAA0D,SAA1D,GAAqC,MAAOA,EAA5C,EAA4F,QAA5F,GAAuE,MAAOA,EAA9E,CACE,MAAO,CAAC,CAACA,CAGX,IAAIA,CAAJ,CAAe,CACb,GAAI,CAAC,CAAA,CAAGR,CAAIe,CAAAA,WAAR,EAAqBP,CAArB,CAAJ,CACE,MAAO,CAACA,CAAUQ,CAAAA,MAAV,EAGV,IAAI,CAAC,CAAA,CAAGhB,CAAIiB,CAAAA,SAAR,EAAmBT,CAAnB,CAAJ,CACE,MAAO,EAAaU,CAAVV,CAAUU,CAAAA,EAAb,EAA6BC,CAAVX,CAAUW,CAAAA,EAA7B,CAGT,IAAI,CAAC,CAAA,CAAGnB,CAAIoB,CAAAA,MAAR,EAAgBZ,CAAhB,CAAJ,CACE,MAAO,CAAC,CAACA,CAAUV,CAAAA,KAVR,CAcf,GAAkB,IAAlB,GAAIU,CAAJ,EAAwCa,IAAAA,EAAxC,GAA0Bb,CAA1B,CACE,MAAO,CAAA,CAGT,MAAM,KAAIK,SAAJ,CAAc,iCAAd,CAAkD,CAAC,CAAA,CAAGb,CAAIsB,CAAAA,MAAR,EAAgBd,CAAhB,CAAlD,CAA+E,GAA/E,CAAN,CAvBgC,CAhLlCD,CAAgBgB,CAAAA,SAAhB,CAA4B,IAzBjBjB,CAAKkB,CAAAA,IA0BhBjB,EAAgBgB,CAAAA,SAAUE,CAAAA,IAA1B,CAAiC,iBACjClB,EAAgBgB,CAAAA,SAAUG,CAAAA,iBAA1B,CAA8C,CAAA,CAe9CnB,EAAgBgB,CAAAA,SAAUI,CAAAA,QAA1B,CAAqCC,QAAS,CAACC,CAAD,CAAOC,CAAP,CAAiB,CAC7D,IAAIC;AAAgB,IAAKvB,CAAAA,SAAUmB,CAAAA,QAAf,CAAwBE,CAAxB,CAA8BC,CAA9B,CAApB,CAEIE,EAAe,IAAKvB,CAAAA,QAASkB,CAAAA,QAAd,CAAuBE,CAAvB,CAA6BC,CAA7B,CAFnB,CAIIG,EAAgB,IAAKvB,CAAAA,SAAUiB,CAAAA,QAAf,CAAwBE,CAAxB,CAA8BC,CAA9B,CAEpB,OAAOI,SAA4B,CAACC,CAAD,CAAQC,CAAR,CAAcC,CAAd,CAAuB,CACxD,MAAOvB,EAAA,CAAciB,CAAA,CAAcI,CAAd,CAAqBC,CAArB,CAA2BC,CAA3B,CAAd,CAAA,CAAqDL,CAAA,CAAaG,CAAb,CAAoBC,CAApB,CAA0BC,CAA1B,CAArD,CAA0FJ,CAAA,CAAcE,CAAd,CAAqBC,CAArB,CAA2BC,CAA3B,CADzC,CAPG,CAiB/D9B,EAAgBgB,CAAAA,SAAUe,CAAAA,OAA1B,CAAoCC,QAAS,CAACC,CAAD,CAAW,CACtDA,CAAA,CAAS,IAAKhC,CAAAA,SAAd,CAAyB,WAAzB,CAAsC,IAAtC,CACAgC,EAAA,CAAS,IAAK/B,CAAAA,QAAd,CAAwB,UAAxB,CAAoC,IAApC,CACA+B,EAAA,CAAS,IAAK9B,CAAAA,SAAd,CAAyB,WAAzB,CAAsC,IAAtC,CAHsD,CAaxDH,EAAgBgB,CAAAA,SAAUkB,CAAAA,GAA1B,CAAgCC,QAAS,CAACF,CAAD,CAAW,CAClD,MAAO,KAAIjC,CAAJ,CAAoB,IAAKoC,CAAAA,OAAL,CAAaH,CAAA,CAAS,IAAKhC,CAAAA,SAAd,CAAyB,WAAzB,CAAsC,IAAtC,CAAb,CAApB,CAA+E,IAAKmC,CAAAA,OAAL,CAAaH,CAAA,CAAS,IAAK/B,CAAAA,QAAd,CAAwB,UAAxB,CAAoC,IAApC,CAAb,CAA/E,CAAwI,IAAKkC,CAAAA,OAAL,CAAaH,CAAA,CAAS,IAAK9B,CAAAA,SAAd,CAAyB,WAAzB,CAAsC,IAAtC,CAAb,CAAxI,CAD2C,CASpDH,EAAgBgB,CAAAA,SAAUqB,CAAAA,KAA1B,CAAkCC,QAAS,EAAG,CAC5C,MAAO,KAAItC,CAAJ,CAAoB,IAAKC,CAAAA,SAAzB;AAAoC,IAAKC,CAAAA,QAAzC,CAAmD,IAAKC,CAAAA,SAAxD,CADqC,CAU9CH,EAAgBgB,CAAAA,SAAUuB,CAAAA,SAA1B,CAAsCC,QAAS,CAACC,CAAD,CAAU,CACvD,IAAIC,EAAcD,CAAA,EAAWA,CAAQC,CAAAA,WAAnB,CAAiCD,CAAQC,CAAAA,WAAzC,CAAuD,MAAzE,CACIC,EAAa,CAAC,CAAA,CAAGhD,CAAWiD,CAAAA,aAAf,EAA8B,IAA9B,CAAoCF,CAApC,CADjB,CAMIzC,EAAY,IAAKA,CAAAA,SAAU4C,CAAAA,QAAf,CAAwBJ,CAAxB,CANhB,CAOIK,EAAsB,CAAC,CAAA,CAAGnD,CAAWiD,CAAAA,aAAf,EAA8B,IAAK3C,CAAAA,SAAnC,CAA8CyC,CAA9C,CAE1B,IAAoB,KAApB,GAAIA,CAAJ,EAAqD,cAArD,GAA6B,IAAKzC,CAAAA,SAAUiB,CAAAA,IAA5C,EAA+F,IAA/F,GAAuE4B,CAAvE,EAAuGA,CAAvG,EAA8HH,CAA9H,CACE1C,CAAA,CAAY,GAAZ,CAAkBA,CAAlB,CAA8B,GAG5BC,EAAAA,CAAW,IAAKA,CAAAA,QAAS2C,CAAAA,QAAd,CAAuBJ,CAAvB,CACf,KAAIM,EAAiB,CAAC,CAAA,CAAGpD,CAAWiD,CAAAA,aAAf,EAA8B,IAAK1C,CAAAA,QAAnC,CAA6CwC,CAA7C,CAErB,IAAoB,KAApB,GAAIA,CAAJ,EAAoD,cAApD,GAA6B,IAAKxC,CAAAA,QAASgB,CAAAA,IAA3C,EAAyF,IAAzF,GAAsE6B,CAAtE,EAAiGA,CAAjG,EAAmHJ,CAAnH,CACEzC,CAAA,CAAW,GAAX,CAAiBA,CAAjB,CAA4B,GAG1BC,EAAAA,CAAY,IAAKA,CAAAA,SAAU0C,CAAAA,QAAf,CAAwBJ,CAAxB,CACZO,EAAAA,CAAkB,CAAC,CAAA,CAAGrD,CAAWiD,CAAAA,aAAf,EAA8B,IAAKzC,CAAAA,SAAnC;AAA8CuC,CAA9C,CAEtB,IAAoB,KAApB,GAAIA,CAAJ,EAAqD,cAArD,GAA6B,IAAKvC,CAAAA,SAAUe,CAAAA,IAA5C,EAA2F,IAA3F,GAAuE8B,CAAvE,EAAmGA,CAAnG,EAAsHL,CAAtH,CACExC,CAAA,CAAY,GAAZ,CAAkBA,CAAlB,CAA8B,GAGhC,OAAOF,EAAP,CAAmB,KAAnB,CAA2BC,CAA3B,CAAsC,KAAtC,CAA8CC,CA5BS,CAoCzDH,EAAgBgB,CAAAA,SAAUiC,CAAAA,MAA1B,CAAmCC,QAAS,EAAG,CAC7C,MAAO,CACLC,OAAQ,iBADH,CAELlD,UAAW,IAAKA,CAAAA,SAFX,CAGLC,SAAU,IAAKA,CAAAA,QAHV,CAILC,UAAW,IAAKA,CAAAA,SAJX,CADsC,CAiB/CH,EAAgBoD,CAAAA,QAAhB,CAA2BC,QAAS,CAACC,CAAD,CAAO,CACzC,MAAO,KAAItD,CAAJ,CAAoBsD,CAAKrD,CAAAA,SAAzB,CAAoCqD,CAAKpD,CAAAA,QAAzC,CAAmDoD,CAAKnD,CAAAA,SAAxD,CADkC,CAU3CH,EAAgBgB,CAAAA,SAAUuC,CAAAA,MAA1B,CAAmCC,QAAS,CAACf,CAAD,CAAU,CACpD,IAAIC,EAAcD,CAAA,EAAWA,CAAQC,CAAAA,WAAnB,CAAiCD,CAAQC,CAAAA,WAAzC,CAAuD,MAAzE,CACIC,EAAa,CAAC,CAAA,CAAGhD,CAAWiD,CAAAA,aAAf,EAA8B,IAA9B,CAAoCF,CAApC,CADjB,CAMIzC,EAAY,IAAKA,CAAAA,SAAUsD,CAAAA,MAAf,CAAsBd,CAAtB,CANhB,CAOIK,EAAsB,CAAC,CAAA,CAAGnD,CAAWiD,CAAAA,aAAf,EAA8B,IAAK3C,CAAAA,SAAnC,CAA8CyC,CAA9C,CAE1B,IAAoB,KAApB;AAAIA,CAAJ,EAAqD,cAArD,GAA6B,IAAKzC,CAAAA,SAAUiB,CAAAA,IAA5C,EAA+F,IAA/F,GAAuE4B,CAAvE,EAAuGA,CAAvG,EAA8HH,CAA9H,CACE1C,CAAA,CAAY,+EAAZ,CAA+EA,CAA/E,CAA2F,+EAGzFC,EAAAA,CAAW,IAAKA,CAAAA,QAASqD,CAAAA,MAAd,CAAqBd,CAArB,CACf,KAAIM,EAAiB,CAAC,CAAA,CAAGpD,CAAWiD,CAAAA,aAAf,EAA8B,IAAK1C,CAAAA,QAAnC,CAA6CwC,CAA7C,CAErB,IAAoB,KAApB,GAAIA,CAAJ,EAAoD,cAApD,GAA6B,IAAKxC,CAAAA,QAASgB,CAAAA,IAA3C,EAAyF,IAAzF,GAAsE6B,CAAtE,EAAiGA,CAAjG,EAAmHJ,CAAnH,CACEzC,CAAA,CAAW,+EAAX,CAA8EA,CAA9E,CAAyF,+EAGvFC;CAAAA,CAAY,IAAKA,CAAAA,SAAUoD,CAAAA,MAAf,CAAsBd,CAAtB,CACZO,EAAAA,CAAkB,CAAC,CAAA,CAAGrD,CAAWiD,CAAAA,aAAf,EAA8B,IAAKzC,CAAAA,SAAnC,CAA8CuC,CAA9C,CAEtB,IAAoB,KAApB,GAAIA,CAAJ,EAAqD,cAArD,GAA6B,IAAKvC,CAAAA,SAAUe,CAAAA,IAA5C,EAA2F,IAA3F,GAAuE8B,CAAvE,EAAmGA,CAAnG,EAAsHL,CAAtH,CACExC,CAAA,CAAY,+EAAZ,CAA+EA,CAA/E,CAA2F,+EAG7F,OAAOF,EAAP,CAAmB,+EAAnB,CAAsFC,CAAtF,CAAiG,+EAAjG,CAAoKC,CA5BhH,CAqCtDH,EAAgBgB,CAAAA,SAAUyC,CAAAA,MAA1B,CAAmCC,QAAS,CAACjB,CAAD,CAAU,CACpD,MAAO,kBAAP;AAA4B,IAAKvC,CAAAA,QAASyD,CAAAA,KAAd,CAAoBlB,CAApB,CAA5B,CAA2D,8BAA3D,CAAyF,IAAKxC,CAAAA,SAAU0D,CAAAA,KAAf,CAAqBlB,CAArB,CAAzF,CAAyH,QAAzH,CAAoI,IAAKtC,CAAAA,SAAUwD,CAAAA,KAAf,CAAqBlB,CAArB,CAApI,CAAoK,8CADhH,CAoCtD,OAAOzC,EApO4F,CAA1D,CAqOxC,CACD4D,QAAS,CAAA,CADR,CAEDvD,OAAQ,CAAA,CAFP,CArOwC,CAyO3CjB,EAAQI,CAAAA,qBAAR,CAAgCA,CAzP8B;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js\"],\n\"sourcesContent\":[\"shadow$provide[258] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createConditionalNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _operators = require(\\\"../operators.js\\\");\\n\\nvar name = 'ConditionalNode';\\nvar dependencies = ['Node'];\\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Node = _ref.Node;\\n\\n  /**\\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\\n   *\\n   * @param {Node} condition   Condition, must result in a boolean\\n   * @param {Node} trueExpr    Expression evaluated when condition is true\\n   * @param {Node} falseExpr   Expression evaluated when condition is true\\n   *\\n   * @constructor ConditionalNode\\n   * @extends {Node}\\n   */\\n  function ConditionalNode(condition, trueExpr, falseExpr) {\\n    if (!(this instanceof ConditionalNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if (!(0, _is.isNode)(condition)) throw new TypeError('Parameter condition must be a Node');\\n    if (!(0, _is.isNode)(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\\n    if (!(0, _is.isNode)(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\\n    this.condition = condition;\\n    this.trueExpr = trueExpr;\\n    this.falseExpr = falseExpr;\\n  }\\n\\n  ConditionalNode.prototype = new Node();\\n  ConditionalNode.prototype.type = 'ConditionalNode';\\n  ConditionalNode.prototype.isConditionalNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  ConditionalNode.prototype._compile = function (math, argNames) {\\n    var evalCondition = this.condition._compile(math, argNames);\\n\\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\\n\\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\\n\\n    return function evalConditionalNode(scope, args, context) {\\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\\n    };\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  ConditionalNode.prototype.forEach = function (callback) {\\n    callback(this.condition, 'condition', this);\\n    callback(this.trueExpr, 'trueExpr', this);\\n    callback(this.falseExpr, 'falseExpr', this);\\n  };\\n  /**\\n   * Create a new ConditionalNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {ConditionalNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  ConditionalNode.prototype.map = function (callback) {\\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {ConditionalNode}\\n   */\\n\\n\\n  ConditionalNode.prototype.clone = function () {\\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\\n  };\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  ConditionalNode.prototype._toString = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\\n    // or have lower or equal precedence\\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\\n    // purely based on aesthetics and readability\\n\\n    var condition = this.condition.toString(options);\\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\\n\\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\\n      condition = '(' + condition + ')';\\n    }\\n\\n    var trueExpr = this.trueExpr.toString(options);\\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\\n\\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\\n      trueExpr = '(' + trueExpr + ')';\\n    }\\n\\n    var falseExpr = this.falseExpr.toString(options);\\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\\n\\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\\n      falseExpr = '(' + falseExpr + ')';\\n    }\\n\\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  ConditionalNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'ConditionalNode',\\n      condition: this.condition,\\n      trueExpr: this.trueExpr,\\n      falseExpr: this.falseExpr\\n    };\\n  };\\n  /**\\n   * Instantiate an ConditionalNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"ConditionalNode\\\", \\\"condition\\\": ..., \\\"trueExpr\\\": ..., \\\"falseExpr\\\": ...}`,\\n   *                       where mathjs is optional\\n   * @returns {ConditionalNode}\\n   */\\n\\n\\n  ConditionalNode.fromJSON = function (json) {\\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  ConditionalNode.prototype.toHTML = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\\n    // or have lower or equal precedence\\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\\n    // purely based on aesthetics and readability\\n\\n    var condition = this.condition.toHTML(options);\\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\\n\\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\\n      condition = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + condition + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    var trueExpr = this.trueExpr.toHTML(options);\\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\\n\\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\\n      trueExpr = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + trueExpr + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    var falseExpr = this.falseExpr.toHTML(options);\\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\\n\\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\\n      falseExpr = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + falseExpr + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    return condition + '<span class=\\\"math-operator math-conditional-operator\\\">?</span>' + trueExpr + '<span class=\\\"math-operator math-conditional-operator\\\">:</span>' + falseExpr;\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  ConditionalNode.prototype._toTex = function (options) {\\n    return '\\\\\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\\\\\quad{\\\\\\\\text{if }\\\\\\\\;' + this.condition.toTex(options) + '}\\\\\\\\\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\\\\\quad{\\\\\\\\text{otherwise}}\\\\\\\\end{cases}';\\n  };\\n  /**\\n   * Test whether a condition is met\\n   * @param {*} condition\\n   * @returns {boolean} true if condition is true or non-zero, else false\\n   */\\n\\n\\n  function testCondition(condition) {\\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\\n      return !!condition;\\n    }\\n\\n    if (condition) {\\n      if ((0, _is.isBigNumber)(condition)) {\\n        return !condition.isZero();\\n      }\\n\\n      if ((0, _is.isComplex)(condition)) {\\n        return !!(condition.re || condition.im);\\n      }\\n\\n      if ((0, _is.isUnit)(condition)) {\\n        return !!condition.value;\\n      }\\n    }\\n\\n    if (condition === null || condition === undefined) {\\n      return false;\\n    }\\n\\n    throw new TypeError('Unsupported type of condition \\\"' + (0, _is.typeOf)(condition) + '\\\"');\\n  }\\n\\n  return ConditionalNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createConditionalNode = createConditionalNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createConditionalNode\",\"_is\",\"_factory\",\"_operators\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"ConditionalNode\",\"condition\",\"trueExpr\",\"falseExpr\",\"SyntaxError\",\"isNode\",\"TypeError\",\"testCondition\",\"isBigNumber\",\"isZero\",\"isComplex\",\"re\",\"im\",\"isUnit\",\"undefined\",\"typeOf\",\"prototype\",\"Node\",\"type\",\"isConditionalNode\",\"_compile\",\"ConditionalNode.prototype._compile\",\"math\",\"argNames\",\"evalCondition\",\"evalTrueExpr\",\"evalFalseExpr\",\"evalConditionalNode\",\"scope\",\"args\",\"context\",\"forEach\",\"ConditionalNode.prototype.forEach\",\"callback\",\"map\",\"ConditionalNode.prototype.map\",\"_ifNode\",\"clone\",\"ConditionalNode.prototype.clone\",\"_toString\",\"ConditionalNode.prototype._toString\",\"options\",\"parenthesis\",\"precedence\",\"getPrecedence\",\"toString\",\"conditionPrecedence\",\"truePrecedence\",\"falsePrecedence\",\"toJSON\",\"ConditionalNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"ConditionalNode.fromJSON\",\"json\",\"toHTML\",\"ConditionalNode.prototype.toHTML\",\"_toTex\",\"ConditionalNode.prototype._toTex\",\"toTex\",\"isClass\"]\n}\n"]