["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/probability/kldivergence.js"],"~:js","shadow$provide[541]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createKldivergence=void 0;c=b(25);c=(0,c.factory)(\"kldivergence\",\"typed matrix divide sum multiply dotDivide log isNumeric\".split(\" \"),function(q){function f(n,r){var v=r.size().length,C=n.size().length;if(1<v)throw Error(\"first object must be one dimensional\");if(1<C)throw Error(\"second object must be one dimensional\");if(v!==C)throw Error(\"Length of two vectors must be equal\");if(0===p(n))throw Error(\"Sum of elements in first object must be non zero\");\nif(0===p(r))throw Error(\"Sum of elements in second object must be non zero\");n=t(n,p(n));r=t(r,p(r));r=p(g(n,l(d(n,r))));return h(r)?r:Number.NaN}var u=q.typed,k=q.matrix,t=q.divide,p=q.sum,g=q.multiply,d=q.dotDivide,l=q.log,h=q.isNumeric;return u(\"kldivergence\",{\"Array, Array\":function(n,r){return f(k(n),k(r))},\"Matrix, Array\":function(n,r){return f(n,k(r))},\"Array, Matrix\":function(n,r){return f(k(n),r)},\"Matrix, Matrix\":function(n,r){return f(n,r)}})});a.createKldivergence=c}","~:source","shadow$provide[541] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createKldivergence = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\nvar createKldivergence = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divide = _ref.divide,\n      sum = _ref.sum,\n      multiply = _ref.multiply,\n      dotDivide = _ref.dotDivide,\n      log = _ref.log,\n      isNumeric = _ref.isNumeric;\n\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n\n    var sumq = sum(q);\n\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n\n    var sump = sum(p);\n\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\n\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});\nexports.createKldivergence = createKldivergence;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createKldivergence","__esModule","value"]],"~:compiled-at",1619135724026,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$probability$kldivergence.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,kBAAR,CAA6B,IAAK,EAE9BC,EAAAA,CAAWP,CAAA,CAAQ,EAAR,CAIXM,EAAAA,CAAoC,CAAC,CAAA,CAAGC,CAASC,CAAAA,OAAb,EAF7BC,cAE6B,CADrBC,0DAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CACqB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAyChGC,QAASA,EAAM,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACpB,IAAIC,EAAUD,CAAEE,CAAAA,IAAF,EAASC,CAAAA,MAAvB,CACIC,EAAUL,CAAEG,CAAAA,IAAF,EAASC,CAAAA,MAEvB,IAAc,CAAd,CAAIF,CAAJ,CACE,KAAUI,MAAJ,CAAU,sCAAV,CAAN,CAGF,GAAc,CAAd,CAAID,CAAJ,CACE,KAAUC,MAAJ,CAAU,uCAAV,CAAN,CAGF,GAAIJ,CAAJ,GAAgBG,CAAhB,CACE,KAAUC,MAAJ,CAAU,qCAAV,CAAN,CAMF,GAAa,CAAb,GAFWC,CAAAC,CAAIR,CAAJQ,CAEX,CACE,KAAUF,MAAJ,CAAU,kDAAV,CAAN;AAKF,GAAa,CAAb,GAFWC,CAAAE,CAAIR,CAAJQ,CAEX,CACE,KAAUH,MAAJ,CAAU,mDAAV,CAAN,CAGEI,CAAAA,CAAQC,CAAA,CAAOX,CAAP,CAAUO,CAAA,CAAIP,CAAJ,CAAV,CACRY,EAAAA,CAAQD,CAAA,CAAOV,CAAP,CAAUM,CAAA,CAAIN,CAAJ,CAAV,CACRY,EAAAA,CAASN,CAAA,CAAIO,CAAA,CAASJ,CAAT,CAAgBK,CAAA,CAAIC,CAAA,CAAUN,CAAV,CAAiBE,CAAjB,CAAJ,CAAhB,CAAJ,CAEb,OAAIK,EAAA,CAAUJ,CAAV,CAAJ,CACSA,CADT,CAGSK,MAAOC,CAAAA,GApCI,CAzC0E,IAC5FC,EAAQtB,CAAKsB,CAAAA,KAD+E,CAE5FC,EAASvB,CAAKuB,CAAAA,MAF8E,CAG5FV,EAASb,CAAKa,CAAAA,MAH8E,CAI5FJ,EAAMT,CAAKS,CAAAA,GAJiF,CAK5FO,EAAWhB,CAAKgB,CAAAA,QAL4E,CAM5FE,EAAYlB,CAAKkB,CAAAA,SAN2E,CAO5FD,EAAMjB,CAAKiB,CAAAA,GAPiF,CAQ5FE,EAAYnB,CAAKmB,CAAAA,SAkBrB,OAAOG,EAAA,CA5BExB,cA4BF,CAAY,CACjB,eAAgB0B,QAAmB,CAACtB,CAAD,CAAIC,CAAJ,CAAO,CACxC,MAAOF,EAAA,CAAOsB,CAAA,CAAOrB,CAAP,CAAP,CAAkBqB,CAAA,CAAOpB,CAAP,CAAlB,CADiC,CADzB,CAIjB,gBAAiBsB,QAAoB,CAACvB,CAAD,CAAIC,CAAJ,CAAO,CAC1C,MAAOF,EAAA,CAAOC,CAAP,CAAUqB,CAAA,CAAOpB,CAAP,CAAV,CADmC,CAJ3B,CAOjB,gBAAiBuB,QAAoB,CAACxB,CAAD,CAAIC,CAAJ,CAAO,CAC1C,MAAOF,EAAA,CAAOsB,CAAA,CAAOrB,CAAP,CAAP,CAAkBC,CAAlB,CADmC,CAP3B,CAUjB,iBAAkBwB,QAAqB,CAACzB,CAAD,CAAIC,CAAJ,CAAO,CAC5C,MAAOF,EAAA,CAAOC,CAAP,CAAUC,CAAV,CADqC,CAV7B,CAAZ,CA1ByF,CAA1D,CAiFxCZ,EAAQI,CAAAA,kBAAR,CAA6BA,CA7FiC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/probability/kldivergence.js\"],\n\"sourcesContent\":[\"shadow$provide[541] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createKldivergence = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'kldivergence';\\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\\nvar createKldivergence = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divide = _ref.divide,\\n      sum = _ref.sum,\\n      multiply = _ref.multiply,\\n      dotDivide = _ref.dotDivide,\\n      log = _ref.log,\\n      isNumeric = _ref.isNumeric;\\n\\n  /**\\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\\n     *\\n     * Syntax:\\n     *\\n     *     math.kldivergence(x, y)\\n     *\\n     * Examples:\\n     *\\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\\n     *\\n     *\\n     * @param  {Array | Matrix} q    First vector\\n     * @param  {Array | Matrix} p    Second vector\\n     * @return {number}              Returns distance between q and p\\n     */\\n  return typed(name, {\\n    'Array, Array': function ArrayArray(q, p) {\\n      return _kldiv(matrix(q), matrix(p));\\n    },\\n    'Matrix, Array': function MatrixArray(q, p) {\\n      return _kldiv(q, matrix(p));\\n    },\\n    'Array, Matrix': function ArrayMatrix(q, p) {\\n      return _kldiv(matrix(q), p);\\n    },\\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\\n      return _kldiv(q, p);\\n    }\\n  });\\n\\n  function _kldiv(q, p) {\\n    var plength = p.size().length;\\n    var qlength = q.size().length;\\n\\n    if (plength > 1) {\\n      throw new Error('first object must be one dimensional');\\n    }\\n\\n    if (qlength > 1) {\\n      throw new Error('second object must be one dimensional');\\n    }\\n\\n    if (plength !== qlength) {\\n      throw new Error('Length of two vectors must be equal');\\n    } // Before calculation, apply normalization\\n\\n\\n    var sumq = sum(q);\\n\\n    if (sumq === 0) {\\n      throw new Error('Sum of elements in first object must be non zero');\\n    }\\n\\n    var sump = sum(p);\\n\\n    if (sump === 0) {\\n      throw new Error('Sum of elements in second object must be non zero');\\n    }\\n\\n    var qnorm = divide(q, sum(q));\\n    var pnorm = divide(p, sum(p));\\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\\n\\n    if (isNumeric(result)) {\\n      return result;\\n    } else {\\n      return Number.NaN;\\n    }\\n  }\\n});\\nexports.createKldivergence = createKldivergence;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createKldivergence\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_kldiv\",\"q\",\"p\",\"plength\",\"size\",\"length\",\"qlength\",\"Error\",\"sum\",\"sumq\",\"sump\",\"qnorm\",\"divide\",\"pnorm\",\"result\",\"multiply\",\"log\",\"dotDivide\",\"isNumeric\",\"Number\",\"NaN\",\"typed\",\"matrix\",\"ArrayArray\",\"MatrixArray\",\"ArrayMatrix\",\"MatrixMatrix\"]\n}\n"]