["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/expm.js"],"~:js","shadow$provide[525]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createExpm=void 0;var q=b(14),f=b(21);c=b(25);c=(0,c.factory)(\"expm\",\"typed abs add identity inv multiply\".split(\" \"),function(u){var k=u.typed,t=u.abs,p=u.add,g=u.identity,d=u.inv,l=u.multiply;return k(\"expm\",{Matrix:function(h){var n=h.size();if(2!==n.length||n[0]!==n[1])throw new RangeError(\"Matrix must be square (size: \"+(0,f.format)(n)+\")\");n=n[0];for(var r,v=h.size()[0],C=r=0;C<v;C++){for(var z=0,w=0;w<\nv;w++)z+=t(h.get([C,w]));r=Math.max(z,r)}a:{for(C=0;30>C;C++)for(z=0;z<=C;z++){v=C-z;w=1;for(var B=2;B<=z;B++)w*=B;B=w;for(var x=z+1;x<=2*z;x++)B*=x;if(1E-15>8*Math.pow(r/Math.pow(2,v),2*z)*w*w/(B*B*(2*z+1)))break a}throw Error(\"Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)\");}r=z;C=l(h,Math.pow(2,-v));z=g(n);n=g(n);w=1;B=C;x=-1;for(var D=1;D<=r;D++)1<D&&(B=l(B,C),x=-x),w=w*(r-D+1)/((2*r-D+1)*D),z=p(z,l(w,B)),n=p(n,l(w*x,B));n=l(d(n),\nz);for(r=0;r<v;r++)n=l(n,n);return(0,q.isSparseMatrix)(h)?h.createSparseMatrix(n):n}})});a.createExpm=c}","~:source","shadow$provide[525] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createExpm = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nvar createExpm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      identity = _ref.identity,\n      inv = _ref.inv,\n      multiply = _ref.multiply;\n\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n\n      return (0, _is.isSparseMatrix)(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    var twoqfac = qfac;\n\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});\nexports.createExpm = createExpm;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createExpm","__esModule","value","Matrix"]],"~:compiled-at",1619135724019,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$expm.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/expm.js\"],\n\"sourcesContent\":[\"shadow$provide[525] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createExpm = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'expm';\\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\\nvar createExpm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      abs = _ref.abs,\\n      add = _ref.add,\\n      identity = _ref.identity,\\n      inv = _ref.inv,\\n      multiply = _ref.multiply;\\n\\n  /**\\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\\n   * Not to be confused with exp(a), which performs element-wise\\n   * exponentiation.\\n   *\\n   * The exponential is calculated using the Pad\\u00e9 approximant with scaling and\\n   * squaring; see \\\"Nineteen Dubious Ways to Compute the Exponential of a\\n   * Matrix,\\\" by Moler and Van Loan.\\n   *\\n   * Syntax:\\n   *\\n   *     math.expm(x)\\n   *\\n   * Examples:\\n   *\\n   *     const A = [[0,2],[0,0]]\\n   *     math.expm(A)        // returns [[1,2],[0,1]]\\n   *\\n   * See also:\\n   *\\n   *     exp\\n   *\\n   * @param {Matrix} x  A square Matrix\\n   * @return {Matrix}   The exponential of x\\n   */\\n  return typed(name, {\\n    Matrix: function Matrix(A) {\\n      // Check matrix size\\n      var size = A.size();\\n\\n      if (size.length !== 2 || size[0] !== size[1]) {\\n        throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n      }\\n\\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\\n      // will be affected by round-off error)\\n\\n      var eps = 1e-15; // The Pad\\u00e9 approximant is not so accurate when the values of A\\n      // are \\\"large\\\", so scale A by powers of two. Then compute the\\n      // exponential, and square the result repeatedly according to\\n      // the identity e^A = (e^(A/m))^m\\n      // Compute infinity-norm of A, ||A||, to see how \\\"big\\\" it is\\n\\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\\n      // Pad\\u00e9 approximant to reach the desired accuracy\\n\\n      var params = findParams(infNorm, eps);\\n      var q = params.q;\\n      var j = params.j; // The Pade approximation to e^A is:\\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\\n      // where\\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\\n      // Scale A by 1 / 2^j\\n\\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\\n\\n      var N = identity(n);\\n      var D = identity(n); // Initialization (i=0)\\n\\n      var factor = 1; // Initialization (i=1)\\n\\n      var AposToI = Apos; // Cloning not necessary\\n\\n      var alternate = -1;\\n\\n      for (var i = 1; i <= q; i++) {\\n        if (i > 1) {\\n          AposToI = multiply(AposToI, Apos);\\n          alternate = -alternate;\\n        }\\n\\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\\n        N = add(N, multiply(factor, AposToI));\\n        D = add(D, multiply(factor * alternate, AposToI));\\n      }\\n\\n      var R = multiply(inv(D), N); // Square j times\\n\\n      for (var _i = 0; _i < j; _i++) {\\n        R = multiply(R, R);\\n      }\\n\\n      return (0, _is.isSparseMatrix)(A) ? A.createSparseMatrix(R) : R;\\n    }\\n  });\\n\\n  function infinityNorm(A) {\\n    var n = A.size()[0];\\n    var infNorm = 0;\\n\\n    for (var i = 0; i < n; i++) {\\n      var rowSum = 0;\\n\\n      for (var j = 0; j < n; j++) {\\n        rowSum += abs(A.get([i, j]));\\n      }\\n\\n      infNorm = Math.max(rowSum, infNorm);\\n    }\\n\\n    return infNorm;\\n  }\\n  /**\\n   * Find the best parameters for the Pade approximant given\\n   * the matrix norm and desired accuracy. Returns the first acceptable\\n   * combination in order of increasing computational load.\\n   */\\n\\n\\n  function findParams(infNorm, eps) {\\n    var maxSearchSize = 30;\\n\\n    for (var k = 0; k < maxSearchSize; k++) {\\n      for (var q = 0; q <= k; q++) {\\n        var j = k - q;\\n\\n        if (errorEstimate(infNorm, q, j) < eps) {\\n          return {\\n            q: q,\\n            j: j\\n          };\\n        }\\n      }\\n    }\\n\\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\\n  }\\n  /**\\n   * Returns the estimated error of the Pade approximant for the given\\n   * parameters.\\n   */\\n\\n\\n  function errorEstimate(infNorm, q, j) {\\n    var qfac = 1;\\n\\n    for (var i = 2; i <= q; i++) {\\n      qfac *= i;\\n    }\\n\\n    var twoqfac = qfac;\\n\\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\\n      twoqfac *= _i2;\\n    }\\n\\n    var twoqp1fac = twoqfac * (2 * q + 1);\\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\\n  }\\n});\\nexports.createExpm = createExpm;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createExpm\",\"_is\",\"_string\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"abs\",\"add\",\"identity\",\"inv\",\"multiply\",\"Matrix\",\"A\",\"size\",\"length\",\"RangeError\",\"format\",\"n\",\"infNorm\",\"i\",\"rowSum\",\"j\",\"get\",\"Math\",\"max\",\"k\",\"maxSearchSize\",\"q\",\"qfac\",\"twoqfac\",\"_i2\",\"eps\",\"pow\",\"Error\",\"Apos\",\"N\",\"D\",\"factor\",\"AposToI\",\"alternate\",\"R\",\"_i\",\"isSparseMatrix\",\"createSparseMatrix\"]\n}\n"]