["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/chain/Chain.js"],"~:js","shadow$provide[299]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createChainClass=void 0;var q=b(14),f=b(21),u=b(15);c=b(25);c=(0,c.factory)(\"Chain\",[\"?on\",\"math\"],function(k){function t(h){if(!(this instanceof t))throw new SyntaxError(\"Constructor must be called with the new operator\");(0,q.isChain)(h)?this.value=h.value:this.value=h}function p(h,n){(0,u.lazy)(t.prototype,h,function(){var r=n();if(\"function\"===typeof r)return g(r)})}function g(h){return function(){for(var n=\n[this.value],r=0;r<arguments.length;r++)n[r+1]=arguments[r];return new t(h.apply(h,n))}}var d=k.on;k=k.math;t.prototype.type=\"Chain\";t.prototype.isChain=!0;t.prototype.done=function(){return this.value};t.prototype.valueOf=function(){return this.value};t.prototype.toString=function(){return(0,f.format)(this.value)};t.prototype.toJSON=function(){return{mathjs:\"Chain\",value:this.value}};t.fromJSON=function(h){return new t(h.value)};t.createProxy=function(h,n){if(\"string\"===typeof h)\"function\"===typeof n&&\n(t.prototype[h]=g(n));else{n=function(v){(0,u.hasOwnProperty)(h,v)&&void 0===l[v]&&p(v,function(){return h[v]})};for(var r in h)n(r)}};var l={expression:!0,docs:!0,type:!0,classes:!0,json:!0,error:!0,isChain:!0};t.createProxy(k);d&&d(\"import\",function(h,n,r){r||p(h,n)});return t},{isClass:!0});a.createChainClass=c}","~:source","shadow$provide[299] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createChainClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Chain';\nvar dependencies = ['?on', 'math'];\nvar createChainClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var on = _ref.on,\n      math = _ref.math;\n\n  /**\n   * @constructor Chain\n   * Wrap any value in a chain, allowing to perform chained operations on\n   * the value.\n   *\n   * All methods available in the math.js library can be called upon the chain,\n   * and then will be evaluated with the value itself as first argument.\n   * The chain can be closed by executing chain.done(), which will return\n   * the final value.\n   *\n   * The Chain has a number of special functions:\n   * - done()             Finalize the chained operation and return the\n   *                      chain's value.\n   * - valueOf()          The same as done()\n   * - toString()         Returns a string representation of the chain's value.\n   *\n   * @param {*} [value]\n   */\n  function Chain(value) {\n    if (!(this instanceof Chain)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if ((0, _is.isChain)(value)) {\n      this.value = value.value;\n    } else {\n      this.value = value;\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Chain.prototype.type = 'Chain';\n  Chain.prototype.isChain = true;\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method valueOf()\n   * @returns {*} value\n   */\n\n  Chain.prototype.done = function () {\n    return this.value;\n  };\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method done()\n   * @returns {*} value\n   */\n\n\n  Chain.prototype.valueOf = function () {\n    return this.value;\n  };\n  /**\n   * Get a string representation of the value in the chain\n   * @returns {string}\n   */\n\n\n  Chain.prototype.toString = function () {\n    return (0, _string.format)(this.value);\n  };\n  /**\n   * Get a JSON representation of the chain\n   * @returns {Object}\n   */\n\n\n  Chain.prototype.toJSON = function () {\n    return {\n      mathjs: 'Chain',\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate a Chain from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\n   *                       where mathjs is optional\n   * @returns {Chain}\n   */\n\n\n  Chain.fromJSON = function (json) {\n    return new Chain(json.value);\n  };\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {Function} fn      The function to be proxied\n   *                           If fn is no function, it is silently ignored.\n   * @private\n   */\n\n\n  function createProxy(name, fn) {\n    if (typeof fn === 'function') {\n      Chain.prototype[name] = chainify(fn);\n    }\n  }\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {function} resolver   The function resolving with the\n   *                              function to be proxied\n   * @private\n   */\n\n\n  function createLazyProxy(name, resolver) {\n    (0, _object.lazy)(Chain.prototype, name, function outerResolver() {\n      var fn = resolver();\n\n      if (typeof fn === 'function') {\n        return chainify(fn);\n      }\n\n      return undefined; // if not a function, ignore\n    });\n  }\n  /**\n   * Make a function chainable\n   * @param {function} fn\n   * @return {Function} chain function\n   * @private\n   */\n\n\n  function chainify(fn) {\n    return function () {\n      var args = [this.value]; // `this` will be the context of a Chain instance\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i];\n      }\n\n      return new Chain(fn.apply(fn, args));\n    };\n  }\n  /**\n   * Create a proxy for a single method, or an object with multiple methods.\n   * Example usage:\n   *\n   *   Chain.createProxy('add', function add (x, y) {...})\n   *   Chain.createProxy({\n   *     add:      function add (x, y) {...},\n   *     subtract: function subtract (x, y) {...}\n   *   }\n   *\n   * @param {string | Object} arg0   A name (string), or an object with\n   *                                 functions\n   * @param {*} [arg1]               A function, when arg0 is a name\n   */\n\n\n  Chain.createProxy = function (arg0, arg1) {\n    if (typeof arg0 === 'string') {\n      // createProxy(name, value)\n      createProxy(arg0, arg1);\n    } else {\n      var _loop = function _loop(_name) {\n        if ((0, _object.hasOwnProperty)(arg0, _name) && excludedNames[_name] === undefined) {\n          createLazyProxy(_name, function () {\n            return arg0[_name];\n          });\n        }\n      };\n\n      // createProxy(values)\n      for (var _name in arg0) {\n        _loop(_name);\n      }\n    }\n  };\n\n  var excludedNames = {\n    expression: true,\n    docs: true,\n    type: true,\n    classes: true,\n    json: true,\n    error: true,\n    isChain: true // conflicts with the property isChain of a Chain instance\n\n  }; // create proxy for everything that is in math.js\n\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\n\n  if (on) {\n    on('import', function (name, resolver, path) {\n      if (!path) {\n        // an imported function (not a data type or something special)\n        createLazyProxy(name, resolver);\n      }\n    });\n  }\n\n  return Chain;\n}, {\n  isClass: true\n});\nexports.createChainClass = createChainClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["json","valueOf","fromJSON","isClass","__esModule","error","toString","expression","isChain","value","classes","createChainClass","mathjs","type","done","docs","createProxy","toJSON"]],"~:compiled-at",1619135723981,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$chain$Chain.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/chain/Chain.js\"],\n\"sourcesContent\":[\"shadow$provide[299] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createChainClass = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'Chain';\\nvar dependencies = ['?on', 'math'];\\nvar createChainClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var on = _ref.on,\\n      math = _ref.math;\\n\\n  /**\\n   * @constructor Chain\\n   * Wrap any value in a chain, allowing to perform chained operations on\\n   * the value.\\n   *\\n   * All methods available in the math.js library can be called upon the chain,\\n   * and then will be evaluated with the value itself as first argument.\\n   * The chain can be closed by executing chain.done(), which will return\\n   * the final value.\\n   *\\n   * The Chain has a number of special functions:\\n   * - done()             Finalize the chained operation and return the\\n   *                      chain's value.\\n   * - valueOf()          The same as done()\\n   * - toString()         Returns a string representation of the chain's value.\\n   *\\n   * @param {*} [value]\\n   */\\n  function Chain(value) {\\n    if (!(this instanceof Chain)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if ((0, _is.isChain)(value)) {\\n      this.value = value.value;\\n    } else {\\n      this.value = value;\\n    }\\n  }\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  Chain.prototype.type = 'Chain';\\n  Chain.prototype.isChain = true;\\n  /**\\n   * Close the chain. Returns the final value.\\n   * Does the same as method valueOf()\\n   * @returns {*} value\\n   */\\n\\n  Chain.prototype.done = function () {\\n    return this.value;\\n  };\\n  /**\\n   * Close the chain. Returns the final value.\\n   * Does the same as method done()\\n   * @returns {*} value\\n   */\\n\\n\\n  Chain.prototype.valueOf = function () {\\n    return this.value;\\n  };\\n  /**\\n   * Get a string representation of the value in the chain\\n   * @returns {string}\\n   */\\n\\n\\n  Chain.prototype.toString = function () {\\n    return (0, _string.format)(this.value);\\n  };\\n  /**\\n   * Get a JSON representation of the chain\\n   * @returns {Object}\\n   */\\n\\n\\n  Chain.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'Chain',\\n      value: this.value\\n    };\\n  };\\n  /**\\n   * Instantiate a Chain from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"Chain\\\", value: ...}`,\\n   *                       where mathjs is optional\\n   * @returns {Chain}\\n   */\\n\\n\\n  Chain.fromJSON = function (json) {\\n    return new Chain(json.value);\\n  };\\n  /**\\n   * Create a proxy method for the chain\\n   * @param {string} name\\n   * @param {Function} fn      The function to be proxied\\n   *                           If fn is no function, it is silently ignored.\\n   * @private\\n   */\\n\\n\\n  function createProxy(name, fn) {\\n    if (typeof fn === 'function') {\\n      Chain.prototype[name] = chainify(fn);\\n    }\\n  }\\n  /**\\n   * Create a proxy method for the chain\\n   * @param {string} name\\n   * @param {function} resolver   The function resolving with the\\n   *                              function to be proxied\\n   * @private\\n   */\\n\\n\\n  function createLazyProxy(name, resolver) {\\n    (0, _object.lazy)(Chain.prototype, name, function outerResolver() {\\n      var fn = resolver();\\n\\n      if (typeof fn === 'function') {\\n        return chainify(fn);\\n      }\\n\\n      return undefined; // if not a function, ignore\\n    });\\n  }\\n  /**\\n   * Make a function chainable\\n   * @param {function} fn\\n   * @return {Function} chain function\\n   * @private\\n   */\\n\\n\\n  function chainify(fn) {\\n    return function () {\\n      var args = [this.value]; // `this` will be the context of a Chain instance\\n\\n      for (var i = 0; i < arguments.length; i++) {\\n        args[i + 1] = arguments[i];\\n      }\\n\\n      return new Chain(fn.apply(fn, args));\\n    };\\n  }\\n  /**\\n   * Create a proxy for a single method, or an object with multiple methods.\\n   * Example usage:\\n   *\\n   *   Chain.createProxy('add', function add (x, y) {...})\\n   *   Chain.createProxy({\\n   *     add:      function add (x, y) {...},\\n   *     subtract: function subtract (x, y) {...}\\n   *   }\\n   *\\n   * @param {string | Object} arg0   A name (string), or an object with\\n   *                                 functions\\n   * @param {*} [arg1]               A function, when arg0 is a name\\n   */\\n\\n\\n  Chain.createProxy = function (arg0, arg1) {\\n    if (typeof arg0 === 'string') {\\n      // createProxy(name, value)\\n      createProxy(arg0, arg1);\\n    } else {\\n      var _loop = function _loop(_name) {\\n        if ((0, _object.hasOwnProperty)(arg0, _name) && excludedNames[_name] === undefined) {\\n          createLazyProxy(_name, function () {\\n            return arg0[_name];\\n          });\\n        }\\n      };\\n\\n      // createProxy(values)\\n      for (var _name in arg0) {\\n        _loop(_name);\\n      }\\n    }\\n  };\\n\\n  var excludedNames = {\\n    expression: true,\\n    docs: true,\\n    type: true,\\n    classes: true,\\n    json: true,\\n    error: true,\\n    isChain: true // conflicts with the property isChain of a Chain instance\\n\\n  }; // create proxy for everything that is in math.js\\n\\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\\n\\n  if (on) {\\n    on('import', function (name, resolver, path) {\\n      if (!path) {\\n        // an imported function (not a data type or something special)\\n        createLazyProxy(name, resolver);\\n      }\\n    });\\n  }\\n\\n  return Chain;\\n}, {\\n  isClass: true\\n});\\nexports.createChainClass = createChainClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createChainClass\",\"_is\",\"_string\",\"_object\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"Chain\",\"SyntaxError\",\"isChain\",\"createLazyProxy\",\"resolver\",\"lazy\",\"prototype\",\"outerResolver\",\"fn\",\"chainify\",\"args\",\"i\",\"arguments\",\"length\",\"apply\",\"on\",\"math\",\"type\",\"done\",\"Chain.prototype.done\",\"valueOf\",\"Chain.prototype.valueOf\",\"toString\",\"Chain.prototype.toString\",\"format\",\"toJSON\",\"Chain.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"Chain.fromJSON\",\"json\",\"createProxy\",\"Chain.createProxy\",\"arg0\",\"arg1\",\"_loop\",\"_name\",\"hasOwnProperty\",\"undefined\",\"excludedNames\",\"expression\",\"docs\",\"classes\",\"error\",\"path\",\"isClass\"]\n}\n"]