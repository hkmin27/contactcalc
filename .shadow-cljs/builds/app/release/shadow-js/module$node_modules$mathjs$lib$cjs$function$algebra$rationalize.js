["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/rationalize.js"],"~:js","shadow$provide[568]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createRationalize=void 0;var q=b(19);c=b(25);var f=b(564),u=b(563);b=(0,c.factory)(\"rationalize\",\"config typed equal isZero add subtract multiply divide pow parse simplify ?bignumber ?fraction mathWithTransform ConstantNode OperatorNode FunctionNode SymbolNode ParenthesisNode\".split(\" \"),function(k){function t(R,ba,Q,T){function Y(ha){var wa=ha.type;if(\"FunctionNode\"===wa)throw Error(\"There is an unsolved function call\");\nif(\"OperatorNode\"===wa)if(\"^\"===ha.op)if(\"ConstantNode\"===ha.args[1].type&&(0,q.isInteger)(parseFloat(ha.args[1].value)))Y(ha.args[0]);else throw Error(\"There is a non-integer exponent\");else{if(-1===ka.indexOf(ha.op))throw Error(\"Operator \"+ha.op+\" invalid in polynomial expression\");for(wa=0;wa<ha.args.length;wa++)Y(ha.args[wa])}else if(\"SymbolNode\"===wa)ha=ha.name,-1===ca.indexOf(ha)&&ca.push(ha);else if(\"ParenthesisNode\"===wa)Y(ha.content);else if(\"ConstantNode\"!==wa)throw Error(\"type \"+wa+\" is not allowed in polynomial expression\");\n}var ca=[];R=x(R,T,ba,{exactFractions:!1});var ka=\"+-*\"+(Q?\"/\":\"\");Y(R);Q={};Q.expression=R;Q.variables=ca;return Q}function p(R,ba,Q){var T=R.type,Y=1<arguments.length;if(\"OperatorNode\"===T&&R.isBinary()){var ca=!1;if(\"^\"===R.op&&(\"ParenthesisNode\"===R.args[0].type||\"OperatorNode\"===R.args[0].type)&&\"ConstantNode\"===R.args[1].type){var ka=parseFloat(R.args[1].value);ca=2<=ka&&(0,q.isInteger)(ka)}ca&&(2<ka?(ca=R.args[0],ka=new I(\"^\",\"pow\",[R.args[0].cloneDeep(),new G(ka-1)]),R=new I(\"*\",\"multiply\",\n[ca,ka])):R=new I(\"*\",\"multiply\",[R.args[0],R.args[0].cloneDeep()]),Y&&(\"content\"===Q?ba.content=R:ba.args[Q]=R))}if(\"ParenthesisNode\"===T)p(R.content,R,\"content\");else if(\"ConstantNode\"!==T&&\"SymbolNode\"!==T)for(T=0;T<R.args.length;T++)p(R.args[T],R,T);if(!Y)return R}function g(R,ba){function Q(oa,Ka,fa){var va=oa.type;if(\"FunctionNode\"===va)throw Error(\"There is an unsolved function call\");if(\"OperatorNode\"===va){if(-1===\"+-*^\".indexOf(oa.op))throw Error(\"Operator \"+oa.op+\" invalid\");if(null!==\nKa){if((\"unaryMinus\"===oa.fn||\"pow\"===oa.fn)&&\"add\"!==Ka.fn&&\"subtract\"!==Ka.fn&&\"multiply\"!==Ka.fn)throw Error(\"Invalid \"+oa.op+\" placing\");if((\"subtract\"===oa.fn||\"add\"===oa.fn||\"multiply\"===oa.fn)&&\"add\"!==Ka.fn&&\"subtract\"!==Ka.fn)throw Error(\"Invalid \"+oa.op+\" placing\");if((\"subtract\"===oa.fn||\"add\"===oa.fn||\"unaryMinus\"===oa.fn)&&0!==fa.noFil)throw Error(\"Invalid \"+oa.op+\" placing\");}if(\"^\"===oa.op||\"*\"===oa.op)fa.fire=oa.op;for(Ka=0;Ka<oa.args.length;Ka++){\"unaryMinus\"===oa.fn&&(fa.oper=\"-\");\nif(\"+\"===oa.op||\"subtract\"===oa.fn)fa.fire=\"\",fa.cte=1,fa.oper=0===Ka?\"+\":oa.op;fa.noFil=Ka;Q(oa.args[Ka],oa,fa)}}else if(\"SymbolNode\"===va){if(oa.name!==Y&&\"\"!==Y)throw Error(\"There is more than one variable\");Y=oa.name;if(null===Ka)ba[1]=1;else{if(\"^\"===Ka.op&&0!==fa.noFil)throw Error(\"In power the variable should be the first parameter\");if(\"*\"===Ka.op&&1!==fa.noFil)throw Error(\"In multiply the variable should be the second parameter\");if(\"\"===fa.fire||\"*\"===fa.fire)1>T&&(ba[1]=0),ba[1]+=fa.cte*\n(\"+\"===fa.oper?1:-1),T=Math.max(1,T)}}else if(\"ConstantNode\"===va)if(oa=parseFloat(oa.value),null===Ka)ba[0]=oa;else if(\"^\"===Ka.op){if(1!==fa.noFil)throw Error(\"Constant cannot be powered\");if(!(0,q.isInteger)(oa)||0>=oa)throw Error(\"Non-integer exponent is not allowed\");for(Ka=T+1;Ka<oa;Ka++)ba[Ka]=0;oa>T&&(ba[oa]=0);ba[oa]+=fa.cte*(\"+\"===fa.oper?1:-1);T=Math.max(oa,T)}else fa.cte=oa,\"\"===fa.fire&&(ba[0]+=fa.cte*(\"+\"===fa.oper?1:-1));else throw Error(\"Type \"+va+\" is not allowed\");}void 0===ba&&\n(ba=[]);var T=ba[0]=0,Y=\"\";Q(R,null,{cte:1,oper:\"+\",fire:\"\"});T=ba.length-1;R=!0;for(var ca,ka=T;0<=ka;ka--)if(0!==ba[ka]){var ha=new G(R?ba[ka]:Math.abs(ba[ka])),wa=0>ba[ka]?\"-\":\"+\";if(0<ka){var Ia=new M(Y);if(1<ka){var Ha=new G(ka);Ia=new I(\"^\",\"pow\",[Ia,Ha])}ha=-1===ba[ka]&&R?new I(\"-\",\"unaryMinus\",[Ia]):1===Math.abs(ba[ka])?Ia:new I(\"*\",\"multiply\",[ha,Ia])}ca=R?ha:\"+\"===wa?new I(\"+\",\"add\",[ca,ha]):new I(\"-\",\"subtract\",[ca,ha]);R=!1}return R?new G(0):ca}var d=k.config,l=k.typed,h=k.equal,n=k.isZero,\nr=k.add,v=k.subtract,C=k.multiply,z=k.divide,w=k.pow,B=k.parse,x=k.simplify,D=k.fraction,F=k.bignumber,E=k.mathWithTransform,G=k.ConstantNode,I=k.OperatorNode,L=k.FunctionNode,M=k.SymbolNode;k=k.ParenthesisNode;var S=(0,f.createSimplifyConstant)({typed:l,config:d,mathWithTransform:E,fraction:D,bignumber:F,ConstantNode:G,OperatorNode:I,FunctionNode:L,SymbolNode:M}),P=(0,u.createSimplifyCore)({equal:h,isZero:n,add:r,subtract:v,multiply:C,divide:z,pow:w,ConstantNode:G,OperatorNode:I,FunctionNode:L,ParenthesisNode:k});\nreturn l(\"rationalize\",{string:function(R){return this(B(R),{},!1)},\"string, boolean\":function(R,ba){return this(B(R),{},ba)},\"string, Object\":function(R,ba){return this(B(R),ba,!1)},\"string, Object, boolean\":function(R,ba,Q){return this(B(R),ba,Q)},Node:function(R){return this(R,{},!1)},\"Node, boolean\":function(R,ba){return this(R,{},ba)},\"Node, Object\":function(R,ba){return this(R,ba,!1)},\"Node, Object, boolean\":function(R,ba,Q){var T=[P,{l:\"n+n\",r:\"2*n\"},{l:\"n+-n\",r:\"0\"},S,{l:\"n*(n1^-1)\",r:\"n/n1\"},\n{l:\"n*n1^-n2\",r:\"n/n1^n2\"},{l:\"n1^-1\",r:\"1/n1\"},{l:\"n*(n1/n2)\",r:\"(n*n1)/n2\"},{l:\"1*n\",r:\"n\"}],Y=[{l:\"(-n1)/(-n2)\",r:\"n1/n2\"},{l:\"(-n1)*(-n2)\",r:\"n1*n2\"},{l:\"n1--n2\",r:\"n1+n2\"},{l:\"n1-n2\",r:\"n1+(-n2)\"},{l:\"(n1+n2)*n3\",r:\"(n1*n3 + n2*n3)\"},{l:\"n1*(n2+n3)\",r:\"(n1*n2+n1*n3)\"},{l:\"c1*n + c2*n\",r:\"(c1+c2)*n\"},{l:\"c1*n + n\",r:\"(c1+1)*n\"},{l:\"c1*n - c2*n\",r:\"(c1-c2)*n\"},{l:\"c1*n - n\",r:\"(c1-1)*n\"},{l:\"v/c\",r:\"(1/c)*v\"},{l:\"v/-c\",r:\"-(1/c)*v\"},{l:\"-v*-c\",r:\"c*v\"},{l:\"-v*c\",r:\"-c*v\"},{l:\"v*-c\",r:\"-c*v\"},{l:\"v*c\",\nr:\"c*v\"},{l:\"-(-n1*n2)\",r:\"(n1*n2)\"},{l:\"-(n1*n2)\",r:\"(-n1*n2)\"},{l:\"-(-n1+n2)\",r:\"(n1-n2)\"},{l:\"-(n1+n2)\",r:\"(-n1-n2)\"},{l:\"(n1^n2)^n3\",r:\"(n1^(n2*n3))\"},{l:\"-(-n1/n2)\",r:\"(n1/n2)\"},{l:\"-(n1/n2)\",r:\"(-n1/n2)\"}],ca=[{l:\"(n1/(n2/n3))\",r:\"((n1*n3)/n2)\"},{l:\"(n1/n2/n3)\",r:\"(n1/(n2*n3))\"}];var ka=T.concat(Y,ca);var ha=[{l:\"(n1/n2 + n3/n4)\",r:\"((n1*n4 + n3*n2)/(n2*n4))\"},{l:\"(n1/n2 + n3)\",r:\"((n1 + n3*n2)/n2)\"},{l:\"(n1 + n2/n3)\",r:\"((n1*n3 + n2)/n3)\"}];Y=T.concat(Y);var wa=[P,{l:\"n*-n\",r:\"-n^2\"},{l:\"n*n\",\nr:\"n^2\"},S,{l:\"n*-n^n1\",r:\"-n^(n1+1)\"},{l:\"n*n^n1\",r:\"n^(n1+1)\"},{l:\"n^n1*-n^n2\",r:\"-n^(n1+n2)\"},{l:\"n^n1*n^n2\",r:\"n^(n1+n2)\"},{l:\"n^n1*-n\",r:\"-n^(n1+1)\"},{l:\"n^n1*n\",r:\"n^(n1+1)\"},{l:\"n^n1/-n\",r:\"-n^(n1-1)\"},{l:\"n^n1/n\",r:\"n^(n1-1)\"},{l:\"n/-n^n1\",r:\"-n^(1-n1)\"},{l:\"n/n^n1\",r:\"n^(1-n1)\"},{l:\"n^n1/-n^n2\",r:\"n^(n1-n2)\"},{l:\"n^n1/n^n2\",r:\"n^(n1-n2)\"},{l:\"n1+(-n2*n3)\",r:\"n1-n2*n3\"},{l:\"v*(-c)\",r:\"-c*v\"},{l:\"n1+-n2\",r:\"n1-n2\"},{l:\"v*c\",r:\"c*v\"},{l:\"(n1^n2)^n3\",r:\"(n1^(n2*n3))\"}];ba=t(R,ba,!0,ka);T=ba.variables.length;\nR=ba.expression;if(1<=T){R=p(R);var Ia=!0,Ha=!1;for(R=x(R,ka,{},{exactFractions:!1});;){ka=Ia?ha:ca;R=x(R,ka);Ia=!Ia;ka=R.toString();if(ka===oa)break;Ha=!0;var oa=ka}Ha&&(R=x(R,Y,{},{exactFractions:!1}));R=x(R,wa,{},{exactFractions:!1})}ca=[];ha={};\"OperatorNode\"===R.type&&R.isBinary()&&\"/\"===R.op?(1===T&&(R.args[0]=g(R.args[0],ca),R.args[1]=g(R.args[1])),Q&&(ha.numerator=R.args[0],ha.denominator=R.args[1])):(1===T&&(R=g(R,ca)),Q&&(ha.numerator=R,ha.denominator=null));if(!Q)return R;ha.coefficients=\nca;ha.variables=ba.variables;ha.expression=R;return ha}})});a.createRationalize=b}","~:source","shadow$provide[568] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRationalize = void 0;\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _simplifyConstant = require(\"./simplify/simplifyConstant.js\");\n\nvar _simplifyCore = require(\"./simplify/simplifyCore.js\");\n\nvar name = 'rationalize';\nvar dependencies = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode', 'ParenthesisNode'];\nvar createRationalize = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      parse = _ref.parse,\n      simplify = _ref.simplify,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  /**\n   * Transform a rationalizable expression in a rational fraction.\n   * If rational fraction is one variable polynomial then converts\n   * the numerator and denominator in canonical form, with decreasing\n   * exponents, returning the coefficients of numerator.\n   *\n   * Syntax:\n   *\n   *     rationalize(expr)\n   *     rationalize(expr, detailed)\n   *     rationalize(expr, scope)\n   *     rationalize(expr, scope, detailed)\n   *\n   * Examples:\n   *\n   *     math.rationalize('sin(x)+y')\n   *                   //  Error: There is an unsolved function call\n   *     math.rationalize('2x/y - y/(x+1)')\n   *                   // (2*x^2-y^2+2*x)/(x*y+y)\n   *     math.rationalize('(2x+1)^6')\n   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1\n   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')\n   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)\n   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =\n   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/\n   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)\n   *\n   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1\n   *     math.rationalize('x+x+x+y',{})    // 3*x+y\n   *\n   *     const ret = math.rationalize('x+x+x+y',{},true)\n   *                   // ret.expression=3*x+y, ret.variables = [\"x\",\"y\"]\n   *     const ret = math.rationalize('-2+5x^2',{},true)\n   *                   // ret.expression=5*x^2-2, ret.variables = [\"x\"], ret.coefficients=[-2,0,5]\n   *\n   * See also:\n   *\n   *     simplify\n   *\n   * @param  {Node|string} expr    The expression to check if is a polynomial expression\n   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input\n   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)\n   *\n   * @return {Object | Node}    The rational polynomial of `expr` or na object\n   *            {Object}\n   *              {Expression Node} expression: node simplified expression\n   *              {Expression Node} numerator: simplified numerator of expression\n   *              {Expression Node | boolean} denominator: simplified denominator or false (if there is no denominator)\n   *              {Array}           variables:  variable names\n   *              {Array}           coefficients: coefficients of numerator sorted by increased exponent\n   *           {Expression Node}  node simplified expression\n   *\n   */\n\n  return typed(name, {\n    string: function string(expr) {\n      return this(parse(expr), {}, false);\n    },\n    'string, boolean': function stringBoolean(expr, detailed) {\n      return this(parse(expr), {}, detailed);\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return this(parse(expr), scope, false);\n    },\n    'string, Object, boolean': function stringObjectBoolean(expr, scope, detailed) {\n      return this(parse(expr), scope, detailed);\n    },\n    Node: function Node(expr) {\n      return this(expr, {}, false);\n    },\n    'Node, boolean': function NodeBoolean(expr, detailed) {\n      return this(expr, {}, detailed);\n    },\n    'Node, Object': function NodeObject(expr, scope) {\n      return this(expr, scope, false);\n    },\n    'Node, Object, boolean': function NodeObjectBoolean(expr, scope, detailed) {\n      var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form\n\n      var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial\n\n      var nVars = polyRet.variables.length;\n      expr = polyRet.expression;\n\n      if (nVars >= 1) {\n        // If expression in not a constant\n        expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)\n\n        var sBefore; // Previous expression\n\n        var rules;\n        var eDistrDiv = true;\n        var redoInic = false;\n        expr = simplify(expr, setRules.firstRules, {}, {\n          exactFractions: false\n        }); // Apply the initial rules, including succ div rules\n\n        var s;\n\n        while (true) {\n          // Apply alternately  successive division rules and distr.div.rules\n          rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;\n          expr = simplify(expr, rules); // until no more changes\n\n          eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules\n\n          s = expr.toString();\n\n          if (s === sBefore) {\n            break; // No changes : end of the loop\n          }\n\n          redoInic = true;\n          sBefore = s;\n        }\n\n        if (redoInic) {\n          // Apply first rules again without succ div rules (if there are changes)\n          expr = simplify(expr, setRules.firstRulesAgain, {}, {\n            exactFractions: false\n          });\n        }\n\n        expr = simplify(expr, setRules.finalRules, {}, {\n          exactFractions: false\n        }); // Apply final rules\n      } // NVars >= 1\n\n\n      var coefficients = [];\n      var retRationalize = {};\n\n      if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {\n        // Separate numerator from denominator\n        if (nVars === 1) {\n          expr.args[0] = polyToCanonical(expr.args[0], coefficients);\n          expr.args[1] = polyToCanonical(expr.args[1]);\n        }\n\n        if (detailed) {\n          retRationalize.numerator = expr.args[0];\n          retRationalize.denominator = expr.args[1];\n        }\n      } else {\n        if (nVars === 1) {\n          expr = polyToCanonical(expr, coefficients);\n        }\n\n        if (detailed) {\n          retRationalize.numerator = expr;\n          retRationalize.denominator = null;\n        }\n      } // nVars\n\n\n      if (!detailed) return expr;\n      retRationalize.coefficients = coefficients;\n      retRationalize.variables = polyRet.variables;\n      retRationalize.expression = expr;\n      return retRationalize;\n    } // ^^^^^^^ end of rationalize ^^^^^^^^\n\n  }); // end of typed rationalize\n\n  /**\n   *  Function to simplify an expression using an optional scope and\n   *  return it if the expression is a polynomial expression, i.e.\n   *  an expression with one or more variables and the operators\n   *  +, -, *, and ^, where the exponent can only be a positive integer.\n   *\n   * Syntax:\n   *\n   *     polynomial(expr,scope,extended, rules)\n   *\n   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression\n   * @param  {object} scope           Optional scope for expression simplification\n   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.\n   * @param  {array}  rules           Optional. Default is no rule.\n   *\n   *\n   * @return {Object}\n   *            {Object} node:   node simplified expression\n   *            {Array}  variables:  variable names\n   */\n\n  function polynomial(expr, scope, extended, rules) {\n    var variables = [];\n    var node = simplify(expr, rules, scope, {\n      exactFractions: false\n    }); // Resolves any variables and functions with all defined parameters\n\n    extended = !!extended;\n    var oper = '+-*' + (extended ? '/' : '');\n    recPoly(node);\n    var retFunc = {};\n    retFunc.expression = node;\n    retFunc.variables = variables;\n    return retFunc; // -------------------------------------------------------------------------------------------------------\n\n    /**\n     *  Function to simplify an expression using an optional scope and\n     *  return it if the expression is a polynomial expression, i.e.\n     *  an expression with one or more variables and the operators\n     *  +, -, *, and ^, where the exponent can only be a positive integer.\n     *\n     * Syntax:\n     *\n     *     recPoly(node)\n     *\n     *\n     * @param  {Node} node               The current sub tree expression in recursion\n     *\n     * @return                           nothing, throw an exception if error\n     */\n\n    function recPoly(node) {\n      var tp = node.type; // node type\n\n      if (tp === 'FunctionNode') {\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        if (node.op === '^') {\n          // TODO: handle negative exponents like in '1/x^(-2)'\n          if (node.args[1].type !== 'ConstantNode' || !(0, _number.isInteger)(parseFloat(node.args[1].value))) {\n            throw new Error('There is a non-integer exponent');\n          } else {\n            recPoly(node.args[0]);\n          }\n        } else {\n          if (oper.indexOf(node.op) === -1) {\n            throw new Error('Operator ' + node.op + ' invalid in polynomial expression');\n          }\n\n          for (var i = 0; i < node.args.length; i++) {\n            recPoly(node.args[i]);\n          }\n        } // type of operator\n\n      } else if (tp === 'SymbolNode') {\n        var _name = node.name; // variable name\n\n        var pos = variables.indexOf(_name);\n\n        if (pos === -1) {\n          // new variable in expression\n          variables.push(_name);\n        }\n      } else if (tp === 'ParenthesisNode') {\n        recPoly(node.content);\n      } else if (tp !== 'ConstantNode') {\n        throw new Error('type ' + tp + ' is not allowed in polynomial expression');\n      }\n    } // end of recPoly\n\n  } // end of polynomial\n  // ---------------------------------------------------------------------------------------\n\n  /**\n   * Return a rule set to rationalize an polynomial expression in rationalize\n   *\n   * Syntax:\n   *\n   *     rulesRationalize()\n   *\n   * @return {array}        rule set to rationalize an polynomial expression\n   */\n\n\n  function rulesRationalize() {\n    var oldRules = [simplifyCore, // sCore\n    {\n      l: 'n+n',\n      r: '2*n'\n    }, {\n      l: 'n+-n',\n      r: '0'\n    }, simplifyConstant, // sConstant\n    {\n      l: 'n*(n1^-1)',\n      r: 'n/n1'\n    }, {\n      l: 'n*n1^-n2',\n      r: 'n/n1^n2'\n    }, {\n      l: 'n1^-1',\n      r: '1/n1'\n    }, {\n      l: 'n*(n1/n2)',\n      r: '(n*n1)/n2'\n    }, {\n      l: '1*n',\n      r: 'n'\n    }];\n    var rulesFirst = [{\n      l: '(-n1)/(-n2)',\n      r: 'n1/n2'\n    }, // Unary division\n    {\n      l: '(-n1)*(-n2)',\n      r: 'n1*n2'\n    }, // Unary multiplication\n    {\n      l: 'n1--n2',\n      r: 'n1+n2'\n    }, // '--' elimination\n    {\n      l: 'n1-n2',\n      r: 'n1+(-n2)'\n    }, // Subtraction turn into add with unï¿½ry minus\n    {\n      l: '(n1+n2)*n3',\n      r: '(n1*n3 + n2*n3)'\n    }, // Distributive 1\n    {\n      l: 'n1*(n2+n3)',\n      r: '(n1*n2+n1*n3)'\n    }, // Distributive 2\n    {\n      l: 'c1*n + c2*n',\n      r: '(c1+c2)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n + n',\n      r: '(c1+1)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n - c2*n',\n      r: '(c1-c2)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n - n',\n      r: '(c1-1)*n'\n    }, // Joining constants\n    {\n      l: 'v/c',\n      r: '(1/c)*v'\n    }, // variable/constant (new!)\n    {\n      l: 'v/-c',\n      r: '-(1/c)*v'\n    }, // variable/constant (new!)\n    {\n      l: '-v*-c',\n      r: 'c*v'\n    }, // Inversion constant and variable 1\n    {\n      l: '-v*c',\n      r: '-c*v'\n    }, // Inversion constant and variable 2\n    {\n      l: 'v*-c',\n      r: '-c*v'\n    }, // Inversion constant and variable 3\n    {\n      l: 'v*c',\n      r: 'c*v'\n    }, // Inversion constant and variable 4\n    {\n      l: '-(-n1*n2)',\n      r: '(n1*n2)'\n    }, // Unary propagation\n    {\n      l: '-(n1*n2)',\n      r: '(-n1*n2)'\n    }, // Unary propagation\n    {\n      l: '-(-n1+n2)',\n      r: '(n1-n2)'\n    }, // Unary propagation\n    {\n      l: '-(n1+n2)',\n      r: '(-n1-n2)'\n    }, // Unary propagation\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    }, // Power to Power\n    {\n      l: '-(-n1/n2)',\n      r: '(n1/n2)'\n    }, // Division and Unary\n    {\n      l: '-(n1/n2)',\n      r: '(-n1/n2)'\n    }]; // Divisao and Unary\n\n    var rulesDistrDiv = [{\n      l: '(n1/n2 + n3/n4)',\n      r: '((n1*n4 + n3*n2)/(n2*n4))'\n    }, // Sum of fractions\n    {\n      l: '(n1/n2 + n3)',\n      r: '((n1 + n3*n2)/n2)'\n    }, // Sum fraction with number 1\n    {\n      l: '(n1 + n2/n3)',\n      r: '((n1*n3 + n2)/n3)'\n    }]; // Sum fraction with number 1\n\n    var rulesSucDiv = [{\n      l: '(n1/(n2/n3))',\n      r: '((n1*n3)/n2)'\n    }, // Division simplification\n    {\n      l: '(n1/n2/n3)',\n      r: '(n1/(n2*n3))'\n    }];\n    var setRules = {}; // rules set in 4 steps.\n    // All rules => infinite loop\n    // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)\n\n    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set\n\n    setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules\n\n    setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules\n\n    setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.\n    // Division simplification\n    // Second rule set.\n    // There is no aggregate expression with parentesis, but the only variable can be scattered.\n\n    setRules.finalRules = [simplifyCore, // simplify.rules[0]\n    {\n      l: 'n*-n',\n      r: '-n^2'\n    }, // Joining multiply with power 1\n    {\n      l: 'n*n',\n      r: 'n^2'\n    }, // Joining multiply with power 2\n    simplifyConstant, // simplify.rules[14] old 3rd index in oldRules\n    {\n      l: 'n*-n^n1',\n      r: '-n^(n1+1)'\n    }, // Joining multiply with power 3\n    {\n      l: 'n*n^n1',\n      r: 'n^(n1+1)'\n    }, // Joining multiply with power 4\n    {\n      l: 'n^n1*-n^n2',\n      r: '-n^(n1+n2)'\n    }, // Joining multiply with power 5\n    {\n      l: 'n^n1*n^n2',\n      r: 'n^(n1+n2)'\n    }, // Joining multiply with power 6\n    {\n      l: 'n^n1*-n',\n      r: '-n^(n1+1)'\n    }, // Joining multiply with power 7\n    {\n      l: 'n^n1*n',\n      r: 'n^(n1+1)'\n    }, // Joining multiply with power 8\n    {\n      l: 'n^n1/-n',\n      r: '-n^(n1-1)'\n    }, // Joining multiply with power 8\n    {\n      l: 'n^n1/n',\n      r: 'n^(n1-1)'\n    }, // Joining division with power 1\n    {\n      l: 'n/-n^n1',\n      r: '-n^(1-n1)'\n    }, // Joining division with power 2\n    {\n      l: 'n/n^n1',\n      r: 'n^(1-n1)'\n    }, // Joining division with power 3\n    {\n      l: 'n^n1/-n^n2',\n      r: 'n^(n1-n2)'\n    }, // Joining division with power 4\n    {\n      l: 'n^n1/n^n2',\n      r: 'n^(n1-n2)'\n    }, // Joining division with power 5\n    {\n      l: 'n1+(-n2*n3)',\n      r: 'n1-n2*n3'\n    }, // Solving useless parenthesis 1\n    {\n      l: 'v*(-c)',\n      r: '-c*v'\n    }, // Solving useless unary 2\n    {\n      l: 'n1+-n2',\n      r: 'n1-n2'\n    }, // Solving +- together (new!)\n    {\n      l: 'v*c',\n      r: 'c*v'\n    }, // inversion constant with variable\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    } // Power to Power\n    ];\n    return setRules;\n  } // End rulesRationalize\n  // ---------------------------------------------------------------------------------------\n\n  /**\n   *  Expand recursively a tree node for handling with expressions with exponents\n   *  (it's not for constants, symbols or functions with exponents)\n   *  PS: The other parameters are internal for recursion\n   *\n   * Syntax:\n   *\n   *     expandPower(node)\n   *\n   * @param  {Node} node         Current expression node\n   * @param  {node} parent       Parent current node inside the recursion\n   * @param  (int}               Parent number of chid inside the rercursion\n   *\n   * @return {node}        node expression with all powers expanded.\n   */\n\n\n  function expandPower(node, parent, indParent) {\n    var tp = node.type;\n    var internal = arguments.length > 1; // TRUE in internal calls\n\n    if (tp === 'OperatorNode' && node.isBinary()) {\n      var does = false;\n      var val;\n\n      if (node.op === '^') {\n        // First operator: Parenthesis or UnaryMinus\n        if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {\n          // Second operator: Constant\n          val = parseFloat(node.args[1].value);\n          does = val >= 2 && (0, _number.isInteger)(val);\n        }\n      }\n\n      if (does) {\n        // Exponent >= 2\n        // Before:\n        //            operator A --> Subtree\n        // parent pow\n        //            constant\n        //\n        if (val > 2) {\n          // Exponent > 2,\n          // AFTER:  (exponent > 2)\n          //             operator A --> Subtree\n          // parent  *\n          //                 deep clone (operator A --> Subtree\n          //             pow\n          //                 constant - 1\n          //\n          var nEsqTopo = node.args[0];\n          var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);\n          node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);\n        } else {\n          // Expo = 2 - no power\n          // AFTER:  (exponent =  2)\n          //             operator A --> Subtree\n          // parent   oper\n          //            deep clone (operator A --> Subtree)\n          //\n          node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);\n        }\n\n        if (internal) {\n          // Change parent references in internal recursive calls\n          if (indParent === 'content') {\n            parent.content = node;\n          } else {\n            parent.args[indParent] = node;\n          }\n        }\n      } // does\n\n    } // binary OperatorNode\n\n\n    if (tp === 'ParenthesisNode') {\n      // Recursion\n      expandPower(node.content, node, 'content');\n    } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {\n      for (var i = 0; i < node.args.length; i++) {\n        expandPower(node.args[i], node, i);\n      }\n    }\n\n    if (!internal) {\n      // return the root node\n      return node;\n    }\n  } // End expandPower\n  // ---------------------------------------------------------------------------------------\n\n  /**\n   * Auxilary function for rationalize\n   * Convert near canonical polynomial in one variable in a canonical polynomial\n   * with one term for each exponent in decreasing order\n   *\n   * Syntax:\n   *\n   *     polyToCanonical(node [, coefficients])\n   *\n   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression\n   *\n   *        The string or tree expression needs to be at below syntax, with free spaces:\n   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+\n   *       Where 'var' is one variable with any valid name\n   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1\n   *             'expo' are integers greater than 0. It can be omitted if equal than 1.\n   *\n   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent\n   *\n   *\n   * @return {node}        new node tree with one variable polynomial or string error.\n   */\n\n\n  function polyToCanonical(node, coefficients) {\n    if (coefficients === undefined) {\n      coefficients = [];\n    } // coefficients.\n\n\n    coefficients[0] = 0; // index is the exponent\n\n    var o = {};\n    o.cte = 1;\n    o.oper = '+'; // fire: mark with * or ^ when finds * or ^ down tree, reset to \"\" with + and -.\n    //       It is used to deduce the exponent: 1 for *, 0 for \"\".\n\n    o.fire = '';\n    var maxExpo = 0; // maximum exponent\n\n    var varname = ''; // variable name\n\n    recurPol(node, null, o);\n    maxExpo = coefficients.length - 1;\n    var first = true;\n    var no;\n\n    for (var i = maxExpo; i >= 0; i--) {\n      if (coefficients[i] === 0) continue;\n      var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));\n      var op = coefficients[i] < 0 ? '-' : '+';\n\n      if (i > 0) {\n        // Is not a constant without variable\n        var n2 = new SymbolNode(varname);\n\n        if (i > 1) {\n          var n3 = new ConstantNode(i);\n          n2 = new OperatorNode('^', 'pow', [n2, n3]);\n        }\n\n        if (coefficients[i] === -1 && first) {\n          n1 = new OperatorNode('-', 'unaryMinus', [n2]);\n        } else if (Math.abs(coefficients[i]) === 1) {\n          n1 = n2;\n        } else {\n          n1 = new OperatorNode('*', 'multiply', [n1, n2]);\n        }\n      }\n\n      if (first) {\n        no = n1;\n      } else if (op === '+') {\n        no = new OperatorNode('+', 'add', [no, n1]);\n      } else {\n        no = new OperatorNode('-', 'subtract', [no, n1]);\n      }\n\n      first = false;\n    } // for\n\n\n    if (first) {\n      return new ConstantNode(0);\n    } else {\n      return no;\n    }\n    /**\n     * Recursive auxilary function inside polyToCanonical for\n     * converting expression in canonical form\n     *\n     * Syntax:\n     *\n     *     recurPol(node, noPai, obj)\n     *\n     * @param  {Node} node        The current subpolynomial expression\n     * @param  {Node | Null}  noPai   The current parent node\n     * @param  {object}    obj        Object with many internal flags\n     *\n     * @return {}                    No return. If error, throws an exception\n     */\n\n\n    function recurPol(node, noPai, o) {\n      var tp = node.type;\n\n      if (tp === 'FunctionNode') {\n        // ***** FunctionName *****\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        // ***** OperatorName *****\n        if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');\n\n        if (noPai !== null) {\n          // -(unary),^  : children of *,+,-\n          if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          } // -,+,* : children of +,-\n\n\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          } // -,+ : first child\n\n\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {\n            throw new Error('Invalid ' + node.op + ' placing');\n          }\n        } // Has parent\n        // Firers: ^,*       Old:   ^,&,-(unary): firers\n\n\n        if (node.op === '^' || node.op === '*') {\n          o.fire = node.op;\n        }\n\n        for (var _i = 0; _i < node.args.length; _i++) {\n          // +,-: reset fire\n          if (node.fn === 'unaryMinus') o.oper = '-';\n\n          if (node.op === '+' || node.fn === 'subtract') {\n            o.fire = '';\n            o.cte = 1; // default if there is no constant\n\n            o.oper = _i === 0 ? '+' : node.op;\n          }\n\n          o.noFil = _i; // number of son\n\n          recurPol(node.args[_i], node, o);\n        } // for in children\n\n      } else if (tp === 'SymbolNode') {\n        // ***** SymbolName *****\n        if (node.name !== varname && varname !== '') {\n          throw new Error('There is more than one variable');\n        }\n\n        varname = node.name;\n\n        if (noPai === null) {\n          coefficients[1] = 1;\n          return;\n        } // ^: Symbol is First child\n\n\n        if (noPai.op === '^' && o.noFil !== 0) {\n          throw new Error('In power the variable should be the first parameter');\n        } // *: Symbol is Second child\n\n\n        if (noPai.op === '*' && o.noFil !== 1) {\n          throw new Error('In multiply the variable should be the second parameter');\n        } // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)\n\n\n        if (o.fire === '' || o.fire === '*') {\n          if (maxExpo < 1) coefficients[1] = 0;\n          coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(1, maxExpo);\n        }\n      } else if (tp === 'ConstantNode') {\n        var valor = parseFloat(node.value);\n\n        if (noPai === null) {\n          coefficients[0] = valor;\n          return;\n        }\n\n        if (noPai.op === '^') {\n          // cte: second  child of power\n          if (o.noFil !== 1) throw new Error('Constant cannot be powered');\n\n          if (!(0, _number.isInteger)(valor) || valor <= 0) {\n            throw new Error('Non-integer exponent is not allowed');\n          }\n\n          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {\n            coefficients[_i2] = 0;\n          }\n\n          if (valor > maxExpo) coefficients[valor] = 0;\n          coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(valor, maxExpo);\n          return;\n        }\n\n        o.cte = valor; // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.\n\n        if (o.fire === '') {\n          coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);\n        }\n      } else {\n        throw new Error('Type ' + tp + ' is not allowed');\n      }\n    } // End of recurPol\n\n  } // End of polyToCanonical\n\n});\nexports.createRationalize = createRationalize;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyCore","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["denominator","FunctionNode","typed","string","isZero","config","oper","multiply","ConstantNode","__esModule","numerator","SymbolNode","pow","createRationalize","fraction","expression","coefficients","value","OperatorNode","subtract","ParenthesisNode","noFil","bignumber","content","mathWithTransform","variables","exactFractions","r","divide","l","add","equal","Node","cte","fire"]],"~:compiled-at",1619135724039,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$rationalize.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/rationalize.js\"],\n\"sourcesContent\":[\"shadow$provide[568] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createRationalize = void 0;\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _simplifyConstant = require(\\\"./simplify/simplifyConstant.js\\\");\\n\\nvar _simplifyCore = require(\\\"./simplify/simplifyCore.js\\\");\\n\\nvar name = 'rationalize';\\nvar dependencies = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode', 'ParenthesisNode'];\\nvar createRationalize = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var config = _ref.config,\\n      typed = _ref.typed,\\n      equal = _ref.equal,\\n      isZero = _ref.isZero,\\n      add = _ref.add,\\n      subtract = _ref.subtract,\\n      multiply = _ref.multiply,\\n      divide = _ref.divide,\\n      pow = _ref.pow,\\n      parse = _ref.parse,\\n      simplify = _ref.simplify,\\n      fraction = _ref.fraction,\\n      bignumber = _ref.bignumber,\\n      mathWithTransform = _ref.mathWithTransform,\\n      ConstantNode = _ref.ConstantNode,\\n      OperatorNode = _ref.OperatorNode,\\n      FunctionNode = _ref.FunctionNode,\\n      SymbolNode = _ref.SymbolNode,\\n      ParenthesisNode = _ref.ParenthesisNode;\\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\\n    typed: typed,\\n    config: config,\\n    mathWithTransform: mathWithTransform,\\n    fraction: fraction,\\n    bignumber: bignumber,\\n    ConstantNode: ConstantNode,\\n    OperatorNode: OperatorNode,\\n    FunctionNode: FunctionNode,\\n    SymbolNode: SymbolNode\\n  });\\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\\n    equal: equal,\\n    isZero: isZero,\\n    add: add,\\n    subtract: subtract,\\n    multiply: multiply,\\n    divide: divide,\\n    pow: pow,\\n    ConstantNode: ConstantNode,\\n    OperatorNode: OperatorNode,\\n    FunctionNode: FunctionNode,\\n    ParenthesisNode: ParenthesisNode\\n  });\\n  /**\\n   * Transform a rationalizable expression in a rational fraction.\\n   * If rational fraction is one variable polynomial then converts\\n   * the numerator and denominator in canonical form, with decreasing\\n   * exponents, returning the coefficients of numerator.\\n   *\\n   * Syntax:\\n   *\\n   *     rationalize(expr)\\n   *     rationalize(expr, detailed)\\n   *     rationalize(expr, scope)\\n   *     rationalize(expr, scope, detailed)\\n   *\\n   * Examples:\\n   *\\n   *     math.rationalize('sin(x)+y')\\n   *                   //  Error: There is an unsolved function call\\n   *     math.rationalize('2x/y - y/(x+1)')\\n   *                   // (2*x^2-y^2+2*x)/(x*y+y)\\n   *     math.rationalize('(2x+1)^6')\\n   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1\\n   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')\\n   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)\\n   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =\\n   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/\\n   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)\\n   *\\n   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1\\n   *     math.rationalize('x+x+x+y',{})    // 3*x+y\\n   *\\n   *     const ret = math.rationalize('x+x+x+y',{},true)\\n   *                   // ret.expression=3*x+y, ret.variables = [\\\"x\\\",\\\"y\\\"]\\n   *     const ret = math.rationalize('-2+5x^2',{},true)\\n   *                   // ret.expression=5*x^2-2, ret.variables = [\\\"x\\\"], ret.coefficients=[-2,0,5]\\n   *\\n   * See also:\\n   *\\n   *     simplify\\n   *\\n   * @param  {Node|string} expr    The expression to check if is a polynomial expression\\n   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input\\n   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)\\n   *\\n   * @return {Object | Node}    The rational polynomial of `expr` or na object\\n   *            {Object}\\n   *              {Expression Node} expression: node simplified expression\\n   *              {Expression Node} numerator: simplified numerator of expression\\n   *              {Expression Node | boolean} denominator: simplified denominator or false (if there is no denominator)\\n   *              {Array}           variables:  variable names\\n   *              {Array}           coefficients: coefficients of numerator sorted by increased exponent\\n   *           {Expression Node}  node simplified expression\\n   *\\n   */\\n\\n  return typed(name, {\\n    string: function string(expr) {\\n      return this(parse(expr), {}, false);\\n    },\\n    'string, boolean': function stringBoolean(expr, detailed) {\\n      return this(parse(expr), {}, detailed);\\n    },\\n    'string, Object': function stringObject(expr, scope) {\\n      return this(parse(expr), scope, false);\\n    },\\n    'string, Object, boolean': function stringObjectBoolean(expr, scope, detailed) {\\n      return this(parse(expr), scope, detailed);\\n    },\\n    Node: function Node(expr) {\\n      return this(expr, {}, false);\\n    },\\n    'Node, boolean': function NodeBoolean(expr, detailed) {\\n      return this(expr, {}, detailed);\\n    },\\n    'Node, Object': function NodeObject(expr, scope) {\\n      return this(expr, scope, false);\\n    },\\n    'Node, Object, boolean': function NodeObjectBoolean(expr, scope, detailed) {\\n      var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form\\n\\n      var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial\\n\\n      var nVars = polyRet.variables.length;\\n      expr = polyRet.expression;\\n\\n      if (nVars >= 1) {\\n        // If expression in not a constant\\n        expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)\\n\\n        var sBefore; // Previous expression\\n\\n        var rules;\\n        var eDistrDiv = true;\\n        var redoInic = false;\\n        expr = simplify(expr, setRules.firstRules, {}, {\\n          exactFractions: false\\n        }); // Apply the initial rules, including succ div rules\\n\\n        var s;\\n\\n        while (true) {\\n          // Apply alternately  successive division rules and distr.div.rules\\n          rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;\\n          expr = simplify(expr, rules); // until no more changes\\n\\n          eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules\\n\\n          s = expr.toString();\\n\\n          if (s === sBefore) {\\n            break; // No changes : end of the loop\\n          }\\n\\n          redoInic = true;\\n          sBefore = s;\\n        }\\n\\n        if (redoInic) {\\n          // Apply first rules again without succ div rules (if there are changes)\\n          expr = simplify(expr, setRules.firstRulesAgain, {}, {\\n            exactFractions: false\\n          });\\n        }\\n\\n        expr = simplify(expr, setRules.finalRules, {}, {\\n          exactFractions: false\\n        }); // Apply final rules\\n      } // NVars >= 1\\n\\n\\n      var coefficients = [];\\n      var retRationalize = {};\\n\\n      if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {\\n        // Separate numerator from denominator\\n        if (nVars === 1) {\\n          expr.args[0] = polyToCanonical(expr.args[0], coefficients);\\n          expr.args[1] = polyToCanonical(expr.args[1]);\\n        }\\n\\n        if (detailed) {\\n          retRationalize.numerator = expr.args[0];\\n          retRationalize.denominator = expr.args[1];\\n        }\\n      } else {\\n        if (nVars === 1) {\\n          expr = polyToCanonical(expr, coefficients);\\n        }\\n\\n        if (detailed) {\\n          retRationalize.numerator = expr;\\n          retRationalize.denominator = null;\\n        }\\n      } // nVars\\n\\n\\n      if (!detailed) return expr;\\n      retRationalize.coefficients = coefficients;\\n      retRationalize.variables = polyRet.variables;\\n      retRationalize.expression = expr;\\n      return retRationalize;\\n    } // ^^^^^^^ end of rationalize ^^^^^^^^\\n\\n  }); // end of typed rationalize\\n\\n  /**\\n   *  Function to simplify an expression using an optional scope and\\n   *  return it if the expression is a polynomial expression, i.e.\\n   *  an expression with one or more variables and the operators\\n   *  +, -, *, and ^, where the exponent can only be a positive integer.\\n   *\\n   * Syntax:\\n   *\\n   *     polynomial(expr,scope,extended, rules)\\n   *\\n   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression\\n   * @param  {object} scope           Optional scope for expression simplification\\n   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.\\n   * @param  {array}  rules           Optional. Default is no rule.\\n   *\\n   *\\n   * @return {Object}\\n   *            {Object} node:   node simplified expression\\n   *            {Array}  variables:  variable names\\n   */\\n\\n  function polynomial(expr, scope, extended, rules) {\\n    var variables = [];\\n    var node = simplify(expr, rules, scope, {\\n      exactFractions: false\\n    }); // Resolves any variables and functions with all defined parameters\\n\\n    extended = !!extended;\\n    var oper = '+-*' + (extended ? '/' : '');\\n    recPoly(node);\\n    var retFunc = {};\\n    retFunc.expression = node;\\n    retFunc.variables = variables;\\n    return retFunc; // -------------------------------------------------------------------------------------------------------\\n\\n    /**\\n     *  Function to simplify an expression using an optional scope and\\n     *  return it if the expression is a polynomial expression, i.e.\\n     *  an expression with one or more variables and the operators\\n     *  +, -, *, and ^, where the exponent can only be a positive integer.\\n     *\\n     * Syntax:\\n     *\\n     *     recPoly(node)\\n     *\\n     *\\n     * @param  {Node} node               The current sub tree expression in recursion\\n     *\\n     * @return                           nothing, throw an exception if error\\n     */\\n\\n    function recPoly(node) {\\n      var tp = node.type; // node type\\n\\n      if (tp === 'FunctionNode') {\\n        // No function call in polynomial expression\\n        throw new Error('There is an unsolved function call');\\n      } else if (tp === 'OperatorNode') {\\n        if (node.op === '^') {\\n          // TODO: handle negative exponents like in '1/x^(-2)'\\n          if (node.args[1].type !== 'ConstantNode' || !(0, _number.isInteger)(parseFloat(node.args[1].value))) {\\n            throw new Error('There is a non-integer exponent');\\n          } else {\\n            recPoly(node.args[0]);\\n          }\\n        } else {\\n          if (oper.indexOf(node.op) === -1) {\\n            throw new Error('Operator ' + node.op + ' invalid in polynomial expression');\\n          }\\n\\n          for (var i = 0; i < node.args.length; i++) {\\n            recPoly(node.args[i]);\\n          }\\n        } // type of operator\\n\\n      } else if (tp === 'SymbolNode') {\\n        var _name = node.name; // variable name\\n\\n        var pos = variables.indexOf(_name);\\n\\n        if (pos === -1) {\\n          // new variable in expression\\n          variables.push(_name);\\n        }\\n      } else if (tp === 'ParenthesisNode') {\\n        recPoly(node.content);\\n      } else if (tp !== 'ConstantNode') {\\n        throw new Error('type ' + tp + ' is not allowed in polynomial expression');\\n      }\\n    } // end of recPoly\\n\\n  } // end of polynomial\\n  // ---------------------------------------------------------------------------------------\\n\\n  /**\\n   * Return a rule set to rationalize an polynomial expression in rationalize\\n   *\\n   * Syntax:\\n   *\\n   *     rulesRationalize()\\n   *\\n   * @return {array}        rule set to rationalize an polynomial expression\\n   */\\n\\n\\n  function rulesRationalize() {\\n    var oldRules = [simplifyCore, // sCore\\n    {\\n      l: 'n+n',\\n      r: '2*n'\\n    }, {\\n      l: 'n+-n',\\n      r: '0'\\n    }, simplifyConstant, // sConstant\\n    {\\n      l: 'n*(n1^-1)',\\n      r: 'n/n1'\\n    }, {\\n      l: 'n*n1^-n2',\\n      r: 'n/n1^n2'\\n    }, {\\n      l: 'n1^-1',\\n      r: '1/n1'\\n    }, {\\n      l: 'n*(n1/n2)',\\n      r: '(n*n1)/n2'\\n    }, {\\n      l: '1*n',\\n      r: 'n'\\n    }];\\n    var rulesFirst = [{\\n      l: '(-n1)/(-n2)',\\n      r: 'n1/n2'\\n    }, // Unary division\\n    {\\n      l: '(-n1)*(-n2)',\\n      r: 'n1*n2'\\n    }, // Unary multiplication\\n    {\\n      l: 'n1--n2',\\n      r: 'n1+n2'\\n    }, // '--' elimination\\n    {\\n      l: 'n1-n2',\\n      r: 'n1+(-n2)'\\n    }, // Subtraction turn into add with un\\ufffdry minus\\n    {\\n      l: '(n1+n2)*n3',\\n      r: '(n1*n3 + n2*n3)'\\n    }, // Distributive 1\\n    {\\n      l: 'n1*(n2+n3)',\\n      r: '(n1*n2+n1*n3)'\\n    }, // Distributive 2\\n    {\\n      l: 'c1*n + c2*n',\\n      r: '(c1+c2)*n'\\n    }, // Joining constants\\n    {\\n      l: 'c1*n + n',\\n      r: '(c1+1)*n'\\n    }, // Joining constants\\n    {\\n      l: 'c1*n - c2*n',\\n      r: '(c1-c2)*n'\\n    }, // Joining constants\\n    {\\n      l: 'c1*n - n',\\n      r: '(c1-1)*n'\\n    }, // Joining constants\\n    {\\n      l: 'v/c',\\n      r: '(1/c)*v'\\n    }, // variable/constant (new!)\\n    {\\n      l: 'v/-c',\\n      r: '-(1/c)*v'\\n    }, // variable/constant (new!)\\n    {\\n      l: '-v*-c',\\n      r: 'c*v'\\n    }, // Inversion constant and variable 1\\n    {\\n      l: '-v*c',\\n      r: '-c*v'\\n    }, // Inversion constant and variable 2\\n    {\\n      l: 'v*-c',\\n      r: '-c*v'\\n    }, // Inversion constant and variable 3\\n    {\\n      l: 'v*c',\\n      r: 'c*v'\\n    }, // Inversion constant and variable 4\\n    {\\n      l: '-(-n1*n2)',\\n      r: '(n1*n2)'\\n    }, // Unary propagation\\n    {\\n      l: '-(n1*n2)',\\n      r: '(-n1*n2)'\\n    }, // Unary propagation\\n    {\\n      l: '-(-n1+n2)',\\n      r: '(n1-n2)'\\n    }, // Unary propagation\\n    {\\n      l: '-(n1+n2)',\\n      r: '(-n1-n2)'\\n    }, // Unary propagation\\n    {\\n      l: '(n1^n2)^n3',\\n      r: '(n1^(n2*n3))'\\n    }, // Power to Power\\n    {\\n      l: '-(-n1/n2)',\\n      r: '(n1/n2)'\\n    }, // Division and Unary\\n    {\\n      l: '-(n1/n2)',\\n      r: '(-n1/n2)'\\n    }]; // Divisao and Unary\\n\\n    var rulesDistrDiv = [{\\n      l: '(n1/n2 + n3/n4)',\\n      r: '((n1*n4 + n3*n2)/(n2*n4))'\\n    }, // Sum of fractions\\n    {\\n      l: '(n1/n2 + n3)',\\n      r: '((n1 + n3*n2)/n2)'\\n    }, // Sum fraction with number 1\\n    {\\n      l: '(n1 + n2/n3)',\\n      r: '((n1*n3 + n2)/n3)'\\n    }]; // Sum fraction with number 1\\n\\n    var rulesSucDiv = [{\\n      l: '(n1/(n2/n3))',\\n      r: '((n1*n3)/n2)'\\n    }, // Division simplification\\n    {\\n      l: '(n1/n2/n3)',\\n      r: '(n1/(n2*n3))'\\n    }];\\n    var setRules = {}; // rules set in 4 steps.\\n    // All rules => infinite loop\\n    // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)\\n\\n    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set\\n\\n    setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules\\n\\n    setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules\\n\\n    setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.\\n    // Division simplification\\n    // Second rule set.\\n    // There is no aggregate expression with parentesis, but the only variable can be scattered.\\n\\n    setRules.finalRules = [simplifyCore, // simplify.rules[0]\\n    {\\n      l: 'n*-n',\\n      r: '-n^2'\\n    }, // Joining multiply with power 1\\n    {\\n      l: 'n*n',\\n      r: 'n^2'\\n    }, // Joining multiply with power 2\\n    simplifyConstant, // simplify.rules[14] old 3rd index in oldRules\\n    {\\n      l: 'n*-n^n1',\\n      r: '-n^(n1+1)'\\n    }, // Joining multiply with power 3\\n    {\\n      l: 'n*n^n1',\\n      r: 'n^(n1+1)'\\n    }, // Joining multiply with power 4\\n    {\\n      l: 'n^n1*-n^n2',\\n      r: '-n^(n1+n2)'\\n    }, // Joining multiply with power 5\\n    {\\n      l: 'n^n1*n^n2',\\n      r: 'n^(n1+n2)'\\n    }, // Joining multiply with power 6\\n    {\\n      l: 'n^n1*-n',\\n      r: '-n^(n1+1)'\\n    }, // Joining multiply with power 7\\n    {\\n      l: 'n^n1*n',\\n      r: 'n^(n1+1)'\\n    }, // Joining multiply with power 8\\n    {\\n      l: 'n^n1/-n',\\n      r: '-n^(n1-1)'\\n    }, // Joining multiply with power 8\\n    {\\n      l: 'n^n1/n',\\n      r: 'n^(n1-1)'\\n    }, // Joining division with power 1\\n    {\\n      l: 'n/-n^n1',\\n      r: '-n^(1-n1)'\\n    }, // Joining division with power 2\\n    {\\n      l: 'n/n^n1',\\n      r: 'n^(1-n1)'\\n    }, // Joining division with power 3\\n    {\\n      l: 'n^n1/-n^n2',\\n      r: 'n^(n1-n2)'\\n    }, // Joining division with power 4\\n    {\\n      l: 'n^n1/n^n2',\\n      r: 'n^(n1-n2)'\\n    }, // Joining division with power 5\\n    {\\n      l: 'n1+(-n2*n3)',\\n      r: 'n1-n2*n3'\\n    }, // Solving useless parenthesis 1\\n    {\\n      l: 'v*(-c)',\\n      r: '-c*v'\\n    }, // Solving useless unary 2\\n    {\\n      l: 'n1+-n2',\\n      r: 'n1-n2'\\n    }, // Solving +- together (new!)\\n    {\\n      l: 'v*c',\\n      r: 'c*v'\\n    }, // inversion constant with variable\\n    {\\n      l: '(n1^n2)^n3',\\n      r: '(n1^(n2*n3))'\\n    } // Power to Power\\n    ];\\n    return setRules;\\n  } // End rulesRationalize\\n  // ---------------------------------------------------------------------------------------\\n\\n  /**\\n   *  Expand recursively a tree node for handling with expressions with exponents\\n   *  (it's not for constants, symbols or functions with exponents)\\n   *  PS: The other parameters are internal for recursion\\n   *\\n   * Syntax:\\n   *\\n   *     expandPower(node)\\n   *\\n   * @param  {Node} node         Current expression node\\n   * @param  {node} parent       Parent current node inside the recursion\\n   * @param  (int}               Parent number of chid inside the rercursion\\n   *\\n   * @return {node}        node expression with all powers expanded.\\n   */\\n\\n\\n  function expandPower(node, parent, indParent) {\\n    var tp = node.type;\\n    var internal = arguments.length > 1; // TRUE in internal calls\\n\\n    if (tp === 'OperatorNode' && node.isBinary()) {\\n      var does = false;\\n      var val;\\n\\n      if (node.op === '^') {\\n        // First operator: Parenthesis or UnaryMinus\\n        if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {\\n          // Second operator: Constant\\n          val = parseFloat(node.args[1].value);\\n          does = val >= 2 && (0, _number.isInteger)(val);\\n        }\\n      }\\n\\n      if (does) {\\n        // Exponent >= 2\\n        // Before:\\n        //            operator A --\\u003e Subtree\\n        // parent pow\\n        //            constant\\n        //\\n        if (val > 2) {\\n          // Exponent > 2,\\n          // AFTER:  (exponent > 2)\\n          //             operator A --\\u003e Subtree\\n          // parent  *\\n          //                 deep clone (operator A --\\u003e Subtree\\n          //             pow\\n          //                 constant - 1\\n          //\\n          var nEsqTopo = node.args[0];\\n          var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);\\n          node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);\\n        } else {\\n          // Expo = 2 - no power\\n          // AFTER:  (exponent =  2)\\n          //             operator A --\\u003e Subtree\\n          // parent   oper\\n          //            deep clone (operator A --\\u003e Subtree)\\n          //\\n          node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);\\n        }\\n\\n        if (internal) {\\n          // Change parent references in internal recursive calls\\n          if (indParent === 'content') {\\n            parent.content = node;\\n          } else {\\n            parent.args[indParent] = node;\\n          }\\n        }\\n      } // does\\n\\n    } // binary OperatorNode\\n\\n\\n    if (tp === 'ParenthesisNode') {\\n      // Recursion\\n      expandPower(node.content, node, 'content');\\n    } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {\\n      for (var i = 0; i < node.args.length; i++) {\\n        expandPower(node.args[i], node, i);\\n      }\\n    }\\n\\n    if (!internal) {\\n      // return the root node\\n      return node;\\n    }\\n  } // End expandPower\\n  // ---------------------------------------------------------------------------------------\\n\\n  /**\\n   * Auxilary function for rationalize\\n   * Convert near canonical polynomial in one variable in a canonical polynomial\\n   * with one term for each exponent in decreasing order\\n   *\\n   * Syntax:\\n   *\\n   *     polyToCanonical(node [, coefficients])\\n   *\\n   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression\\n   *\\n   *        The string or tree expression needs to be at below syntax, with free spaces:\\n   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+\\n   *       Where 'var' is one variable with any valid name\\n   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1\\n   *             'expo' are integers greater than 0. It can be omitted if equal than 1.\\n   *\\n   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent\\n   *\\n   *\\n   * @return {node}        new node tree with one variable polynomial or string error.\\n   */\\n\\n\\n  function polyToCanonical(node, coefficients) {\\n    if (coefficients === undefined) {\\n      coefficients = [];\\n    } // coefficients.\\n\\n\\n    coefficients[0] = 0; // index is the exponent\\n\\n    var o = {};\\n    o.cte = 1;\\n    o.oper = '+'; // fire: mark with * or ^ when finds * or ^ down tree, reset to \\\"\\\" with + and -.\\n    //       It is used to deduce the exponent: 1 for *, 0 for \\\"\\\".\\n\\n    o.fire = '';\\n    var maxExpo = 0; // maximum exponent\\n\\n    var varname = ''; // variable name\\n\\n    recurPol(node, null, o);\\n    maxExpo = coefficients.length - 1;\\n    var first = true;\\n    var no;\\n\\n    for (var i = maxExpo; i >= 0; i--) {\\n      if (coefficients[i] === 0) continue;\\n      var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));\\n      var op = coefficients[i] < 0 ? '-' : '+';\\n\\n      if (i > 0) {\\n        // Is not a constant without variable\\n        var n2 = new SymbolNode(varname);\\n\\n        if (i > 1) {\\n          var n3 = new ConstantNode(i);\\n          n2 = new OperatorNode('^', 'pow', [n2, n3]);\\n        }\\n\\n        if (coefficients[i] === -1 && first) {\\n          n1 = new OperatorNode('-', 'unaryMinus', [n2]);\\n        } else if (Math.abs(coefficients[i]) === 1) {\\n          n1 = n2;\\n        } else {\\n          n1 = new OperatorNode('*', 'multiply', [n1, n2]);\\n        }\\n      }\\n\\n      if (first) {\\n        no = n1;\\n      } else if (op === '+') {\\n        no = new OperatorNode('+', 'add', [no, n1]);\\n      } else {\\n        no = new OperatorNode('-', 'subtract', [no, n1]);\\n      }\\n\\n      first = false;\\n    } // for\\n\\n\\n    if (first) {\\n      return new ConstantNode(0);\\n    } else {\\n      return no;\\n    }\\n    /**\\n     * Recursive auxilary function inside polyToCanonical for\\n     * converting expression in canonical form\\n     *\\n     * Syntax:\\n     *\\n     *     recurPol(node, noPai, obj)\\n     *\\n     * @param  {Node} node        The current subpolynomial expression\\n     * @param  {Node | Null}  noPai   The current parent node\\n     * @param  {object}    obj        Object with many internal flags\\n     *\\n     * @return {}                    No return. If error, throws an exception\\n     */\\n\\n\\n    function recurPol(node, noPai, o) {\\n      var tp = node.type;\\n\\n      if (tp === 'FunctionNode') {\\n        // ***** FunctionName *****\\n        // No function call in polynomial expression\\n        throw new Error('There is an unsolved function call');\\n      } else if (tp === 'OperatorNode') {\\n        // ***** OperatorName *****\\n        if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');\\n\\n        if (noPai !== null) {\\n          // -(unary),^  : children of *,+,-\\n          if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {\\n            throw new Error('Invalid ' + node.op + ' placing');\\n          } // -,+,* : children of +,-\\n\\n\\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {\\n            throw new Error('Invalid ' + node.op + ' placing');\\n          } // -,+ : first child\\n\\n\\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {\\n            throw new Error('Invalid ' + node.op + ' placing');\\n          }\\n        } // Has parent\\n        // Firers: ^,*       Old:   ^,&,-(unary): firers\\n\\n\\n        if (node.op === '^' || node.op === '*') {\\n          o.fire = node.op;\\n        }\\n\\n        for (var _i = 0; _i < node.args.length; _i++) {\\n          // +,-: reset fire\\n          if (node.fn === 'unaryMinus') o.oper = '-';\\n\\n          if (node.op === '+' || node.fn === 'subtract') {\\n            o.fire = '';\\n            o.cte = 1; // default if there is no constant\\n\\n            o.oper = _i === 0 ? '+' : node.op;\\n          }\\n\\n          o.noFil = _i; // number of son\\n\\n          recurPol(node.args[_i], node, o);\\n        } // for in children\\n\\n      } else if (tp === 'SymbolNode') {\\n        // ***** SymbolName *****\\n        if (node.name !== varname && varname !== '') {\\n          throw new Error('There is more than one variable');\\n        }\\n\\n        varname = node.name;\\n\\n        if (noPai === null) {\\n          coefficients[1] = 1;\\n          return;\\n        } // ^: Symbol is First child\\n\\n\\n        if (noPai.op === '^' && o.noFil !== 0) {\\n          throw new Error('In power the variable should be the first parameter');\\n        } // *: Symbol is Second child\\n\\n\\n        if (noPai.op === '*' && o.noFil !== 1) {\\n          throw new Error('In multiply the variable should be the second parameter');\\n        } // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)\\n\\n\\n        if (o.fire === '' || o.fire === '*') {\\n          if (maxExpo < 1) coefficients[1] = 0;\\n          coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);\\n          maxExpo = Math.max(1, maxExpo);\\n        }\\n      } else if (tp === 'ConstantNode') {\\n        var valor = parseFloat(node.value);\\n\\n        if (noPai === null) {\\n          coefficients[0] = valor;\\n          return;\\n        }\\n\\n        if (noPai.op === '^') {\\n          // cte: second  child of power\\n          if (o.noFil !== 1) throw new Error('Constant cannot be powered');\\n\\n          if (!(0, _number.isInteger)(valor) || valor <= 0) {\\n            throw new Error('Non-integer exponent is not allowed');\\n          }\\n\\n          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {\\n            coefficients[_i2] = 0;\\n          }\\n\\n          if (valor > maxExpo) coefficients[valor] = 0;\\n          coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);\\n          maxExpo = Math.max(valor, maxExpo);\\n          return;\\n        }\\n\\n        o.cte = valor; // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.\\n\\n        if (o.fire === '') {\\n          coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);\\n        }\\n      } else {\\n        throw new Error('Type ' + tp + ' is not allowed');\\n      }\\n    } // End of recurPol\\n\\n  } // End of polyToCanonical\\n\\n});\\nexports.createRationalize = createRationalize;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createRationalize\",\"_number\",\"_factory\",\"_simplifyConstant\",\"_simplifyCore\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"polynomial\",\"expr\",\"scope\",\"extended\",\"rules\",\"recPoly\",\"node\",\"tp\",\"type\",\"Error\",\"op\",\"args\",\"isInteger\",\"parseFloat\",\"oper\",\"indexOf\",\"i\",\"length\",\"_name\",\"variables\",\"pos\",\"push\",\"content\",\"simplify\",\"exactFractions\",\"retFunc\",\"expression\",\"expandPower\",\"parent\",\"indParent\",\"internal\",\"arguments\",\"isBinary\",\"does\",\"val\",\"nEsqTopo\",\"nDirTopo\",\"OperatorNode\",\"cloneDeep\",\"ConstantNode\",\"polyToCanonical\",\"coefficients\",\"recurPol\",\"noPai\",\"o\",\"fn\",\"noFil\",\"fire\",\"_i\",\"cte\",\"varname\",\"maxExpo\",\"Math\",\"max\",\"valor\",\"_i2\",\"undefined\",\"first\",\"no\",\"n1\",\"abs\",\"n2\",\"SymbolNode\",\"n3\",\"config\",\"typed\",\"equal\",\"isZero\",\"add\",\"subtract\",\"multiply\",\"divide\",\"pow\",\"parse\",\"fraction\",\"bignumber\",\"mathWithTransform\",\"FunctionNode\",\"ParenthesisNode\",\"simplifyConstant\",\"createSimplifyConstant\",\"simplifyCore\",\"createSimplifyCore\",\"string\",\"stringBoolean\",\"detailed\",\"stringObject\",\"stringObjectBoolean\",\"Node\",\"NodeBoolean\",\"NodeObject\",\"NodeObjectBoolean\",\"oldRules\",\"l\",\"r\",\"rulesFirst\",\"rulesSucDiv\",\"firstRules\",\"concat\",\"distrDivRules\",\"rulesDistrDiv\",\"firstRulesAgain\",\"finalRules\",\"polyRet\",\"nVars\",\"eDistrDiv\",\"redoInic\",\"s\",\"toString\",\"sBefore\",\"retRationalize\",\"numerator\",\"denominator\"]\n}\n"]