["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/operators.js"],"~:js","shadow$provide[255]=function(c,b,y,a){function q(k,t){var p=k;\"keep\"!==t&&(p=k.getContent());k=p.getIdentifier();for(t=0;t<u.length;t++)if(k in u[t])return t;return null}Object.defineProperty(a,\"__esModule\",{value:!0});a.getPrecedence=q;a.getAssociativity=function(k,t){var p=k;\"keep\"!==t&&(p=k.getContent());k=p.getIdentifier();t=q(p,t);if(null===t)return null;t=u[t][k];if((0,f.hasOwnProperty)(t,\"associativity\")){if(\"left\"===t.associativity)return\"left\";if(\"right\"===t.associativity)return\"right\";throw Error(\"'\"+\nk+\"' has the invalid associativity '\"+t.associativity+\"'.\");}return null};a.isAssociativeWith=function(k,t,p){var g=\"keep\"!==p?k.getContent():k;k=\"keep\"!==p?k.getContent():t;t=g.getIdentifier();k=k.getIdentifier();p=q(g,p);if(null===p)return null;p=u[p][t];if((0,f.hasOwnProperty)(p,\"associativeWith\")&&p.associativeWith instanceof Array){for(g=0;g<p.associativeWith.length;g++)if(p.associativeWith[g]===k)return!0;return!1}return null};a.properties=void 0;var f=b(15),u=[{AssignmentNode:{},FunctionAssignmentNode:{}},\n{ConditionalNode:{latexLeftParens:!1,latexRightParens:!1,latexParens:!1}},{\"OperatorNode:or\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:xor\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:and\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:bitOr\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:bitXor\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:bitAnd\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:equal\":{associativity:\"left\",\nassociativeWith:[]},\"OperatorNode:unequal\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:smaller\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:larger\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:smallerEq\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:largerEq\":{associativity:\"left\",associativeWith:[]},RelationalNode:{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:leftShift\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:rightArithShift\":{associativity:\"left\",\nassociativeWith:[]},\"OperatorNode:rightLogShift\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:to\":{associativity:\"left\",associativeWith:[]}},{RangeNode:{}},{\"OperatorNode:add\":{associativity:\"left\",associativeWith:[\"OperatorNode:add\",\"OperatorNode:subtract\"]},\"OperatorNode:subtract\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:multiply\":{associativity:\"left\",associativeWith:[\"OperatorNode:multiply\",\"OperatorNode:divide\",\"Operator:dotMultiply\",\"Operator:dotDivide\"]},\"OperatorNode:divide\":{associativity:\"left\",\nassociativeWith:[],latexLeftParens:!1,latexRightParens:!1,latexParens:!1},\"OperatorNode:dotMultiply\":{associativity:\"left\",associativeWith:[\"OperatorNode:multiply\",\"OperatorNode:divide\",\"OperatorNode:dotMultiply\",\"OperatorNode:doDivide\"]},\"OperatorNode:dotDivide\":{associativity:\"left\",associativeWith:[]},\"OperatorNode:mod\":{associativity:\"left\",associativeWith:[]}},{\"OperatorNode:unaryPlus\":{associativity:\"right\"},\"OperatorNode:unaryMinus\":{associativity:\"right\"},\"OperatorNode:bitNot\":{associativity:\"right\"},\n\"OperatorNode:not\":{associativity:\"right\"}},{\"OperatorNode:pow\":{associativity:\"right\",associativeWith:[],latexRightParens:!1},\"OperatorNode:dotPow\":{associativity:\"right\",associativeWith:[]}},{\"OperatorNode:factorial\":{associativity:\"left\"}},{\"OperatorNode:transpose\":{associativity:\"left\"}}];a.properties=u}","~:source","shadow$provide[255] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrecedence = getPrecedence;\nexports.getAssociativity = getAssociativity;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\n\nvar _object = require(\"../utils/object.js\");\n\n// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexports.properties = properties;\n\nfunction getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\n\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\n\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$object"]],"~:properties",["^5",["properties","AssignmentNode","latexLeftParens","associativeWith","latexRightParens","isAssociativeWith","__esModule","getAssociativity","ConditionalNode","RelationalNode","RangeNode","value","FunctionAssignmentNode","associativity","latexParens","getPrecedence"]],"~:compiled-at",1619135723956,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$operators.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/operators.js\"],\n\"sourcesContent\":[\"shadow$provide[255] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getPrecedence = getPrecedence;\\nexports.getAssociativity = getAssociativity;\\nexports.isAssociativeWith = isAssociativeWith;\\nexports.properties = void 0;\\n\\nvar _object = require(\\\"../utils/object.js\\\");\\n\\n// list of identifiers of nodes in order of their precedence\\n// also contains information about left/right associativity\\n// and which other operator the operator is associative with\\n// Example:\\n// addition is associative with addition and subtraction, because:\\n// (a+b)+c=a+(b+c)\\n// (a+b)-c=a+(b-c)\\n//\\n// postfix operators are left associative, prefix operators\\n// are right associative\\n//\\n// It's also possible to set the following properties:\\n// latexParens: if set to false, this node doesn't need to be enclosed\\n//              in parentheses when using LaTeX\\n// latexLeftParens: if set to false, this !OperatorNode's!\\n//                  left argument doesn't need to be enclosed\\n//                  in parentheses\\n// latexRightParens: the same for the right argument\\nvar properties = [{\\n  // assignment\\n  AssignmentNode: {},\\n  FunctionAssignmentNode: {}\\n}, {\\n  // conditional expression\\n  ConditionalNode: {\\n    latexLeftParens: false,\\n    latexRightParens: false,\\n    latexParens: false // conditionals don't need parentheses in LaTeX because\\n    // they are 2 dimensional\\n\\n  }\\n}, {\\n  // logical or\\n  'OperatorNode:or': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // logical xor\\n  'OperatorNode:xor': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // logical and\\n  'OperatorNode:and': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // bitwise or\\n  'OperatorNode:bitOr': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // bitwise xor\\n  'OperatorNode:bitXor': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // bitwise and\\n  'OperatorNode:bitAnd': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // relational operators\\n  'OperatorNode:equal': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:unequal': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:smaller': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:larger': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:smallerEq': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:largerEq': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  RelationalNode: {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // bitshift operators\\n  'OperatorNode:leftShift': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:rightArithShift': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:rightLogShift': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // unit conversion\\n  'OperatorNode:to': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // range\\n  RangeNode: {}\\n}, {\\n  // addition, subtraction\\n  'OperatorNode:add': {\\n    associativity: 'left',\\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\\n  },\\n  'OperatorNode:subtract': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // multiply, divide, modulus\\n  'OperatorNode:multiply': {\\n    associativity: 'left',\\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\\n  },\\n  'OperatorNode:divide': {\\n    associativity: 'left',\\n    associativeWith: [],\\n    latexLeftParens: false,\\n    latexRightParens: false,\\n    latexParens: false // fractions don't require parentheses because\\n    // they're 2 dimensional, so parens aren't needed\\n    // in LaTeX\\n\\n  },\\n  'OperatorNode:dotMultiply': {\\n    associativity: 'left',\\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\\n  },\\n  'OperatorNode:dotDivide': {\\n    associativity: 'left',\\n    associativeWith: []\\n  },\\n  'OperatorNode:mod': {\\n    associativity: 'left',\\n    associativeWith: []\\n  }\\n}, {\\n  // unary prefix operators\\n  'OperatorNode:unaryPlus': {\\n    associativity: 'right'\\n  },\\n  'OperatorNode:unaryMinus': {\\n    associativity: 'right'\\n  },\\n  'OperatorNode:bitNot': {\\n    associativity: 'right'\\n  },\\n  'OperatorNode:not': {\\n    associativity: 'right'\\n  }\\n}, {\\n  // exponentiation\\n  'OperatorNode:pow': {\\n    associativity: 'right',\\n    associativeWith: [],\\n    latexRightParens: false // the exponent doesn't need parentheses in\\n    // LaTeX because it's 2 dimensional\\n    // (it's on top)\\n\\n  },\\n  'OperatorNode:dotPow': {\\n    associativity: 'right',\\n    associativeWith: []\\n  }\\n}, {\\n  // factorial\\n  'OperatorNode:factorial': {\\n    associativity: 'left'\\n  }\\n}, {\\n  // matrix transpose\\n  'OperatorNode:transpose': {\\n    associativity: 'left'\\n  }\\n}];\\n/**\\n * Get the precedence of a Node.\\n * Higher number for higher precedence, starting with 0.\\n * Returns null if the precedence is undefined.\\n *\\n * @param {Node} _node\\n * @param {string} parenthesis\\n * @return {number | null}\\n */\\n\\nexports.properties = properties;\\n\\nfunction getPrecedence(_node, parenthesis) {\\n  var node = _node;\\n\\n  if (parenthesis !== 'keep') {\\n    // ParenthesisNodes are only ignored when not in 'keep' mode\\n    node = _node.getContent();\\n  }\\n\\n  var identifier = node.getIdentifier();\\n\\n  for (var i = 0; i < properties.length; i++) {\\n    if (identifier in properties[i]) {\\n      return i;\\n    }\\n  }\\n\\n  return null;\\n}\\n/**\\n * Get the associativity of an operator (left or right).\\n * Returns a string containing 'left' or 'right' or null if\\n * the associativity is not defined.\\n *\\n * @param {Node} _node\\n * @param {string} parenthesis\\n * @return {string|null}\\n * @throws {Error}\\n */\\n\\n\\nfunction getAssociativity(_node, parenthesis) {\\n  var node = _node;\\n\\n  if (parenthesis !== 'keep') {\\n    // ParenthesisNodes are only ignored when not in 'keep' mode\\n    node = _node.getContent();\\n  }\\n\\n  var identifier = node.getIdentifier();\\n  var index = getPrecedence(node, parenthesis);\\n\\n  if (index === null) {\\n    // node isn't in the list\\n    return null;\\n  }\\n\\n  var property = properties[index][identifier];\\n\\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\\n    if (property.associativity === 'left') {\\n      return 'left';\\n    }\\n\\n    if (property.associativity === 'right') {\\n      return 'right';\\n    } // associativity is invalid\\n\\n\\n    throw Error('\\\\'' + identifier + '\\\\' has the invalid associativity \\\\'' + property.associativity + '\\\\'.');\\n  } // associativity is undefined\\n\\n\\n  return null;\\n}\\n/**\\n * Check if an operator is associative with another operator.\\n * Returns either true or false or null if not defined.\\n *\\n * @param {Node} nodeA\\n * @param {Node} nodeB\\n * @param {string} parenthesis\\n * @return {boolean | null}\\n */\\n\\n\\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\\n  // ParenthesisNodes are only ignored when not in 'keep' mode\\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\\n  var identifierA = a.getIdentifier();\\n  var identifierB = b.getIdentifier();\\n  var index = getPrecedence(a, parenthesis);\\n\\n  if (index === null) {\\n    // node isn't in the list\\n    return null;\\n  }\\n\\n  var property = properties[index][identifierA];\\n\\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\\n    for (var i = 0; i < property.associativeWith.length; i++) {\\n      if (property.associativeWith[i] === identifierB) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  } // associativeWith is not defined\\n\\n\\n  return null;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getPrecedence\",\"_node\",\"parenthesis\",\"node\",\"getContent\",\"identifier\",\"getIdentifier\",\"i\",\"properties\",\"length\",\"Object\",\"defineProperty\",\"value\",\"getAssociativity\",\"index\",\"property\",\"_object\",\"hasOwnProperty\",\"associativity\",\"Error\",\"isAssociativeWith\",\"nodeA\",\"nodeB\",\"a\",\"b\",\"identifierA\",\"identifierB\",\"associativeWith\",\"Array\",\"AssignmentNode\",\"FunctionAssignmentNode\",\"ConditionalNode\",\"latexLeftParens\",\"latexRightParens\",\"latexParens\",\"RelationalNode\",\"RangeNode\"]\n}\n"]