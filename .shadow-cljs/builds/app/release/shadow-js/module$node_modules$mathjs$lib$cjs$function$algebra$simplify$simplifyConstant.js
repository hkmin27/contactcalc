["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyConstant.js"],"~:js","shadow$provide[564]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSimplifyConstant=void 0;var q=b(14);c=b(25);var f=b(562),u=b(137);b=(0,c.factory)(\"simplifyConstant\",\"typed config mathWithTransform ?fraction ?bignumber ConstantNode OperatorNode FunctionNode SymbolNode\".split(\" \"),function(k){function t(I,L,M){try{return G(n[I].apply(null,L),M)}catch(S){return L=L.map(function(P){return(0,q.isFraction)(P)?P.valueOf():P}),G(n[I].apply(null,L),M)}}function p(I,L){if(L&&\n!1!==L.exactFractions&&isFinite(I)&&r){var M=r(I);L=L&&\"number\"===typeof L.fractionsLimit?L.fractionsLimit:Infinity;if(M.valueOf()===I&&M.n<L&&M.d<L)return M}return I}function g(I,L,M,S){return L.reduce(function(P,R){if((0,q.isNode)(P)||(0,q.isNode)(R))(0,q.isNode)(P)?(0,q.isNode)(R)||(R=E(R)):P=E(P);else{try{return t(I,[P,R],S)}catch(ba){}P=E(P);R=E(R)}return M([P,R])})}function d(I,L){switch(I.type){case \"SymbolNode\":return I;case \"ConstantNode\":return\"number\"!==typeof I.value&&isNaN(I.value)?I:\nG(I.value,L);case \"FunctionNode\":if(n[I.name]&&n[I.name].rawArgs)return I;if(-1===[\"add\",\"multiply\"].indexOf(I.name)){var M=I.args.map(function(Q){return d(Q,L)});if(!M.some(q.isNode))try{return t(I.name,M,L)}catch(Q){}M=M.map(function(Q){return(0,q.isNode)(Q)?Q:E(Q)});return new w(I.name,M)}case \"OperatorNode\":M=I.fn.toString();var S=F(I);if((0,q.isOperatorNode)(I)&&I.isUnary()){var P=[d(I.args[0],L)];P=(0,q.isNode)(P[0])?S(P):t(M,P,L)}else if(x(I))if(P=D(I),P=P.map(function(Q){return d(Q,L)}),B(M)){var R=\n[];I=[];for(var ba=0;ba<P.length;ba++)(0,q.isNode)(P[ba])?I.push(P[ba]):R.push(P[ba]);1<R.length?(P=g(M,R,S,L),I.unshift(P),P=g(M,I,S,L)):P=g(M,P,S,L)}else P=g(M,P,S,L);else P=I.args.map(function(Q){return d(Q,L)}),P=g(M,P,S,L);return P;case \"ParenthesisNode\":return d(I.content,L);default:throw Error(\"Unimplemented node type in simplifyConstant: \".concat(I.type));}}var l=k.typed,h=k.config,n=k.mathWithTransform,r=k.fraction,v=k.bignumber,C=k.ConstantNode,z=k.OperatorNode,w=k.FunctionNode;k=k.SymbolNode;\nk=(0,f.createUtil)({FunctionNode:w,OperatorNode:z,SymbolNode:k});var B=k.isCommutative,x=k.isAssociative,D=k.allChildren,F=k.createMakeNodeFunction,E=l({Fraction:function(I){var L=I.s*I.n;L=0>L?new z(\"-\",\"unaryMinus\",[new C(-L)]):new C(L);return 1===I.d?L:new z(\"/\",\"divide\",[L,new C(I.d)])},number:function(I){return 0>I?new z(\"-\",\"unaryMinus\",[new C(-I)]):new C(I)},BigNumber:function(I){return 0>I?new z(\"-\",\"unaryMinus\",[new C(-I)]):new C(I)},Complex:function(I){throw Error(\"Cannot convert Complex number to Node\");\n}}),G=l({\"string, Object\":function(I,L){if(\"BigNumber\"===h.number)return void 0===v&&(0,u.noBignumber)(),v(I);if(\"Fraction\"===h.number)return void 0===r&&(0,u.noFraction)(),r(I);I=parseFloat(I);return p(I,L)},\"Fraction, Object\":function(I,L){return I},\"BigNumber, Object\":function(I,L){return I},\"number, Object\":function(I,L){return p(I,L)},\"Complex, Object\":function(I,L){return 0!==I.im?I:p(I.re,L)}});return function(I,L){I=d(I,L);return(0,q.isNode)(I)?I:E(I)}});a.createSimplifyConstant=b}","~:source","shadow$provide[564] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _util = require(\"./util.js\");\n\nvar _noop = require(\"../../../utils/noop.js\");\n\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return (0, _is.isNode)(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if ((0, _is.isFraction)(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            args = args.map(function (arg) {\n              return (0, _is.isNode)(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$noop","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["FunctionNode","Complex","__esModule","SymbolNode","createSimplifyConstant","value","OperatorNode","number","BigNumber","Fraction"]],"~:compiled-at",1619135724034,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyConstant.js\"],\n\"sourcesContent\":[\"shadow$provide[564] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSimplifyConstant = void 0;\\n\\nvar _is = require(\\\"../../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _util = require(\\\"./util.js\\\");\\n\\nvar _noop = require(\\\"../../../utils/noop.js\\\");\\n\\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\\nvar name = 'simplifyConstant';\\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      config = _ref.config,\\n      mathWithTransform = _ref.mathWithTransform,\\n      fraction = _ref.fraction,\\n      bignumber = _ref.bignumber,\\n      ConstantNode = _ref.ConstantNode,\\n      OperatorNode = _ref.OperatorNode,\\n      FunctionNode = _ref.FunctionNode,\\n      SymbolNode = _ref.SymbolNode;\\n\\n  var _createUtil = (0, _util.createUtil)({\\n    FunctionNode: FunctionNode,\\n    OperatorNode: OperatorNode,\\n    SymbolNode: SymbolNode\\n  }),\\n      isCommutative = _createUtil.isCommutative,\\n      isAssociative = _createUtil.isAssociative,\\n      allChildren = _createUtil.allChildren,\\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\\n\\n  function simplifyConstant(expr, options) {\\n    var res = foldFraction(expr, options);\\n    return (0, _is.isNode)(res) ? res : _toNode(res);\\n  }\\n\\n  function _eval(fnname, args, options) {\\n    try {\\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\\n    } catch (ignore) {\\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\\n      args = args.map(function (x) {\\n        if ((0, _is.isFraction)(x)) {\\n          return x.valueOf();\\n        }\\n\\n        return x;\\n      });\\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\\n    }\\n  }\\n\\n  var _toNode = typed({\\n    Fraction: _fractionToNode,\\n    number: function number(n) {\\n      if (n < 0) {\\n        return unaryMinusNode(new ConstantNode(-n));\\n      }\\n\\n      return new ConstantNode(n);\\n    },\\n    BigNumber: function BigNumber(n) {\\n      if (n < 0) {\\n        return unaryMinusNode(new ConstantNode(-n));\\n      }\\n\\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\\n    },\\n    Complex: function Complex(s) {\\n      throw new Error('Cannot convert Complex number to Node');\\n    }\\n  }); // convert a number to a fraction only if it can be expressed exactly,\\n  // and when both numerator and denominator are small enough\\n\\n\\n  function _exactFraction(n, options) {\\n    var exactFractions = options && options.exactFractions !== false;\\n\\n    if (exactFractions && isFinite(n) && fraction) {\\n      var f = fraction(n);\\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\\n\\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\\n        return f;\\n      }\\n    }\\n\\n    return n;\\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\\n  // BigNumbers are left alone\\n\\n\\n  var _toNumber = typed({\\n    'string, Object': function stringObject(s, options) {\\n      if (config.number === 'BigNumber') {\\n        if (bignumber === undefined) {\\n          (0, _noop.noBignumber)();\\n        }\\n\\n        return bignumber(s);\\n      } else if (config.number === 'Fraction') {\\n        if (fraction === undefined) {\\n          (0, _noop.noFraction)();\\n        }\\n\\n        return fraction(s);\\n      } else {\\n        var n = parseFloat(s);\\n        return _exactFraction(n, options);\\n      }\\n    },\\n    'Fraction, Object': function FractionObject(s, options) {\\n      return s;\\n    },\\n    // we don't need options here\\n    'BigNumber, Object': function BigNumberObject(s, options) {\\n      return s;\\n    },\\n    // we don't need options here\\n    'number, Object': function numberObject(s, options) {\\n      return _exactFraction(s, options);\\n    },\\n    'Complex, Object': function ComplexObject(s, options) {\\n      if (s.im !== 0) {\\n        return s;\\n      }\\n\\n      return _exactFraction(s.re, options);\\n    }\\n  });\\n\\n  function unaryMinusNode(n) {\\n    return new OperatorNode('-', 'unaryMinus', [n]);\\n  }\\n\\n  function _fractionToNode(f) {\\n    var n;\\n    var vn = f.s * f.n;\\n\\n    if (vn < 0) {\\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\\n    } else {\\n      n = new ConstantNode(vn);\\n    }\\n\\n    if (f.d === 1) {\\n      return n;\\n    }\\n\\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\\n  }\\n  /*\\n   * Create a binary tree from a list of Fractions and Nodes.\\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\\n   * @param args - list of Fractions and Nodes\\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\\n   * if args.length is 1, returns args[0]\\n   * @return - Either a Node representing a binary expression or Fraction\\n   */\\n\\n\\n  function foldOp(fn, args, makeNode, options) {\\n    return args.reduce(function (a, b) {\\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\\n        try {\\n          return _eval(fn, [a, b], options);\\n        } catch (ignoreandcontinue) {}\\n\\n        a = _toNode(a);\\n        b = _toNode(b);\\n      } else if (!(0, _is.isNode)(a)) {\\n        a = _toNode(a);\\n      } else if (!(0, _is.isNode)(b)) {\\n        b = _toNode(b);\\n      }\\n\\n      return makeNode([a, b]);\\n    });\\n  } // destroys the original node and returns a folded one\\n\\n\\n  function foldFraction(node, options) {\\n    switch (node.type) {\\n      case 'SymbolNode':\\n        return node;\\n\\n      case 'ConstantNode':\\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\\n          return _toNumber(node.value, options);\\n        }\\n\\n        return node;\\n\\n      case 'FunctionNode':\\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\\n          return node;\\n        }\\n\\n        {\\n          // Process operators as OperatorNode\\n          var operatorFunctions = ['add', 'multiply'];\\n\\n          if (operatorFunctions.indexOf(node.name) === -1) {\\n            var args = node.args.map(function (arg) {\\n              return foldFraction(arg, options);\\n            }); // If all args are numbers\\n\\n            if (!args.some(_is.isNode)) {\\n              try {\\n                return _eval(node.name, args, options);\\n              } catch (ignoreandcontine) {}\\n            } // Convert all args to nodes and construct a symbolic function call\\n\\n\\n            args = args.map(function (arg) {\\n              return (0, _is.isNode)(arg) ? arg : _toNode(arg);\\n            });\\n            return new FunctionNode(node.name, args);\\n          } else {// treat as operator\\n          }\\n        }\\n\\n      /* falls through */\\n\\n      case 'OperatorNode':\\n        {\\n          var fn = node.fn.toString();\\n\\n          var _args;\\n\\n          var res;\\n          var makeNode = createMakeNodeFunction(node);\\n\\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\\n            _args = [foldFraction(node.args[0], options)];\\n\\n            if (!(0, _is.isNode)(_args[0])) {\\n              res = _eval(fn, _args, options);\\n            } else {\\n              res = makeNode(_args);\\n            }\\n          } else if (isAssociative(node)) {\\n            _args = allChildren(node);\\n            _args = _args.map(function (arg) {\\n              return foldFraction(arg, options);\\n            });\\n\\n            if (isCommutative(fn)) {\\n              // commutative binary operator\\n              var consts = [];\\n              var vars = [];\\n\\n              for (var i = 0; i < _args.length; i++) {\\n                if (!(0, _is.isNode)(_args[i])) {\\n                  consts.push(_args[i]);\\n                } else {\\n                  vars.push(_args[i]);\\n                }\\n              }\\n\\n              if (consts.length > 1) {\\n                res = foldOp(fn, consts, makeNode, options);\\n                vars.unshift(res);\\n                res = foldOp(fn, vars, makeNode, options);\\n              } else {\\n                // we won't change the children order since it's not neccessary\\n                res = foldOp(fn, _args, makeNode, options);\\n              }\\n            } else {\\n              // non-commutative binary operator\\n              res = foldOp(fn, _args, makeNode, options);\\n            }\\n          } else {\\n            // non-associative binary operator\\n            _args = node.args.map(function (arg) {\\n              return foldFraction(arg, options);\\n            });\\n            res = foldOp(fn, _args, makeNode, options);\\n          }\\n\\n          return res;\\n        }\\n\\n      case 'ParenthesisNode':\\n        // remove the uneccessary parenthesis\\n        return foldFraction(node.content, options);\\n\\n      case 'AccessorNode':\\n      /* falls through */\\n\\n      case 'ArrayNode':\\n      /* falls through */\\n\\n      case 'AssignmentNode':\\n      /* falls through */\\n\\n      case 'BlockNode':\\n      /* falls through */\\n\\n      case 'FunctionAssignmentNode':\\n      /* falls through */\\n\\n      case 'IndexNode':\\n      /* falls through */\\n\\n      case 'ObjectNode':\\n      /* falls through */\\n\\n      case 'RangeNode':\\n      /* falls through */\\n\\n      case 'ConditionalNode':\\n      /* falls through */\\n\\n      default:\\n        throw new Error(\\\"Unimplemented node type in simplifyConstant: \\\".concat(node.type));\\n    }\\n  }\\n\\n  return simplifyConstant;\\n});\\nexports.createSimplifyConstant = createSimplifyConstant;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSimplifyConstant\",\"_is\",\"_factory\",\"_util\",\"_noop\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_eval\",\"fnname\",\"args\",\"options\",\"_toNumber\",\"mathWithTransform\",\"apply\",\"ignore\",\"map\",\"x\",\"isFraction\",\"valueOf\",\"_exactFraction\",\"n\",\"exactFractions\",\"isFinite\",\"fraction\",\"f\",\"fractionsLimit\",\"Infinity\",\"d\",\"foldOp\",\"fn\",\"makeNode\",\"reduce\",\"a\",\"b\",\"isNode\",\"_toNode\",\"ignoreandcontinue\",\"foldFraction\",\"node\",\"type\",\"isNaN\",\"rawArgs\",\"operatorFunctions\",\"indexOf\",\"arg\",\"some\",\"ignoreandcontine\",\"FunctionNode\",\"toString\",\"createMakeNodeFunction\",\"isOperatorNode\",\"isUnary\",\"_args\",\"res\",\"isAssociative\",\"allChildren\",\"isCommutative\",\"consts\",\"vars\",\"i\",\"length\",\"push\",\"unshift\",\"content\",\"Error\",\"concat\",\"typed\",\"config\",\"bignumber\",\"ConstantNode\",\"OperatorNode\",\"SymbolNode\",\"_createUtil\",\"createUtil\",\"Fraction\",\"_fractionToNode\",\"vn\",\"s\",\"number\",\"BigNumber\",\"Complex\",\"stringObject\",\"undefined\",\"noBignumber\",\"noFraction\",\"parseFloat\",\"FractionObject\",\"BigNumberObject\",\"numberObject\",\"ComplexObject\",\"im\",\"re\",\"simplifyConstant\",\"expr\"]\n}\n"]