["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js"],"~:js","shadow$provide[295]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSlu=void 0;var q=b(19);c=b(25);var f=b(287),u=b(294);b=(0,c.factory)(\"slu\",\"typed abs add multiply transpose divideScalar subtract larger largerEq SparseMatrix\".split(\" \"),function(k){var t=k.typed,p=k.abs,g=k.add,d=k.multiply,l=k.transpose,h=k.divideScalar,n=k.subtract,r=k.larger,v=k.largerEq;k=k.SparseMatrix;var C=(0,f.createCsSqr)({add:g,multiply:d,transpose:l}),z=(0,u.createCsLu)({abs:p,divideScalar:h,\nmultiply:d,subtract:n,larger:r,largerEq:v,SparseMatrix:k});return t(\"slu\",{\"SparseMatrix, number, number\":function(w,B,x){if(!(0,q.isInteger)(B)||0>B||3<B)throw Error(\"Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]\");if(0>x||1<x)throw Error(\"Partial pivoting threshold must be a number from 0 to 1\");B=C(B,w,!1);w=z(w,B,x);return{L:w.L,U:w.U,p:w.pinv,q:B.q,toString:function(){return\"L: \"+this.L.toString()+\"\\nU: \"+this.U.toString()+\"\\np: \"+this.p.toString()+(this.q?\n\"\\nq: \"+this.q.toString():\"\")+\"\\n\"}}}})});a.createSlu=b}","~:source","shadow$provide[295] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSlu = void 0;\n\nvar _number = require(\"../../../utils/number.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csSqr = require(\"../sparse/csSqr.js\");\n\nvar _csLu = require(\"../sparse/csLu.js\");\n\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createSlu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = (0, _csSqr.createCsSqr)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = (0, _csLu.createCsLu)({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});\nexports.createSlu = createSlu;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu"]],"~:properties",["^5",["createSlu","SparseMatrix","multiply","q","larger","L","p","__esModule","largerEq","toString","value","subtract","U","abs","add","transpose","divideScalar"]],"~:compiled-at",1619135723980,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$slu.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js\"],\n\"sourcesContent\":[\"shadow$provide[295] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSlu = void 0;\\n\\nvar _number = require(\\\"../../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _csSqr = require(\\\"../sparse/csSqr.js\\\");\\n\\nvar _csLu = require(\\\"../sparse/csLu.js\\\");\\n\\nvar name = 'slu';\\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\\nvar createSlu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      abs = _ref.abs,\\n      add = _ref.add,\\n      multiply = _ref.multiply,\\n      transpose = _ref.transpose,\\n      divideScalar = _ref.divideScalar,\\n      subtract = _ref.subtract,\\n      larger = _ref.larger,\\n      largerEq = _ref.largerEq,\\n      SparseMatrix = _ref.SparseMatrix;\\n  var csSqr = (0, _csSqr.createCsSqr)({\\n    add: add,\\n    multiply: multiply,\\n    transpose: transpose\\n  });\\n  var csLu = (0, _csLu.createCsLu)({\\n    abs: abs,\\n    divideScalar: divideScalar,\\n    multiply: multiply,\\n    subtract: subtract,\\n    larger: larger,\\n    largerEq: largerEq,\\n    SparseMatrix: SparseMatrix\\n  });\\n  /**\\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\\n   *\\n   * `P * A * Q = L * U`\\n   *\\n   * Syntax:\\n   *\\n   *    math.slu(A, order, threshold)\\n   *\\n   * Examples:\\n   *\\n   *    const A = math.sparse([[4,3], [6, 3]])\\n   *    math.slu(A, 1, 0.001)\\n   *    // returns:\\n   *    // {\\n   *    //   L: [[1, 0], [1.5, 1]]\\n   *    //   U: [[4, 3], [0, -1.5]]\\n   *    //   p: [0, 1]\\n   *    //   q: [0, 1]\\n   *    // }\\n   *\\n   * See also:\\n   *\\n   *    lup, lsolve, usolve, lusolve\\n   *\\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\\n   *                                       0 - Natural ordering, no permutation vector q is returned\\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\\n   *\\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\\n   */\\n\\n  return typed(name, {\\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\\n      // verify order\\n      if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {\\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\\n      } // verify threshold\\n\\n\\n      if (threshold < 0 || threshold > 1) {\\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\\n      } // perform symbolic ordering and analysis\\n\\n\\n      var s = csSqr(order, a, false); // perform lu decomposition\\n\\n      var f = csLu(a, s, threshold); // return decomposition\\n\\n      return {\\n        L: f.L,\\n        U: f.U,\\n        p: f.pinv,\\n        q: s.q,\\n        toString: function toString() {\\n          return 'L: ' + this.L.toString() + '\\\\nU: ' + this.U.toString() + '\\\\np: ' + this.p.toString() + (this.q ? '\\\\nq: ' + this.q.toString() : '') + '\\\\n';\\n        }\\n      };\\n    }\\n  });\\n});\\nexports.createSlu = createSlu;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSlu\",\"_number\",\"_factory\",\"_csSqr\",\"_csLu\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"abs\",\"add\",\"multiply\",\"transpose\",\"divideScalar\",\"subtract\",\"larger\",\"largerEq\",\"SparseMatrix\",\"csSqr\",\"createCsSqr\",\"csLu\",\"createCsLu\",\"SparseMatrixNumberNumber\",\"a\",\"order\",\"threshold\",\"isInteger\",\"Error\",\"s\",\"f\",\"L\",\"U\",\"p\",\"pinv\",\"q\",\"toString\"]\n}\n"]