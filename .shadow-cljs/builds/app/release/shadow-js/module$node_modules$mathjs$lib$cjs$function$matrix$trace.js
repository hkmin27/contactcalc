["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/trace.js"],"~:js","shadow$provide[246]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createTrace=void 0;var q=b(15),f=b(21);c=b(25);c=(0,c.factory)(\"trace\",[\"typed\",\"matrix\",\"add\"],function(u){function k(d){var l=d._size;d=d._data;switch(l.length){case 1:if(1===l[0])return(0,q.clone)(d[0]);throw new RangeError(\"Matrix must be square (size: \"+(0,f.format)(l)+\")\");case 2:var h=l[0];if(h===l[1]){for(var n=l=0;n<h;n++)l=g(l,d[n][n]);return l}throw new RangeError(\"Matrix must be square (size: \"+(0,\nf.format)(l)+\")\");default:throw new RangeError(\"Matrix must be two dimensional (size: \"+(0,f.format)(l)+\")\");}}var t=u.typed,p=u.matrix,g=u.add;return t(\"trace\",{Array:function(d){return k(p(d))},SparseMatrix:function(d){var l=d._values,h=d._index,n=d._ptr,r=d._size;d=r[1];if(r[0]===d){r=0;if(0<l.length)for(var v=0;v<d;v++)for(var C=n[v+1],z=n[v];z<C;z++){var w=h[z];if(w===v){r=g(r,l[z]);break}if(w>v)break}return r}throw new RangeError(\"Matrix must be square (size: \"+(0,f.format)(r)+\")\");},DenseMatrix:k,\nany:q.clone})});a.createTrace=c}","~:source","shadow$provide[246] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTrace = void 0;\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'trace';\nvar dependencies = ['typed', 'matrix', 'add'];\nvar createTrace = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      add = _ref.add;\n\n  /**\n   * Calculate the trace of a matrix: the sum of the elements on the main\n   * diagonal of a square matrix.\n   *\n   * Syntax:\n   *\n   *    math.trace(x)\n   *\n   * Examples:\n   *\n   *    math.trace([[1, 2], [3, 4]]) // returns 5\n   *\n   *    const A = [\n   *      [1, 2, 3],\n   *      [-1, 2, 3],\n   *      [2, 0, 3]\n   *    ]\n   *    math.trace(A) // returns 6\n   *\n   * See also:\n   *\n   *    diag\n   *\n   * @param {Array | Matrix} x  A matrix\n   *\n   * @return {number} The trace of `x`\n   */\n  return typed('trace', {\n    Array: function _arrayTrace(x) {\n      // use dense matrix implementation\n      return _denseTrace(matrix(x));\n    },\n    SparseMatrix: _sparseTrace,\n    DenseMatrix: _denseTrace,\n    any: _object.clone\n  });\n\n  function _denseTrace(m) {\n    // matrix size & data\n    var size = m._size;\n    var data = m._data; // process dimensions\n\n    switch (size.length) {\n      case 1:\n        // vector\n        if (size[0] === 1) {\n          // return data[0]\n          return (0, _object.clone)(data[0]);\n        }\n\n        throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\n\n      case 2:\n        {\n          // two dimensional\n          var rows = size[0];\n          var cols = size[1];\n\n          if (rows === cols) {\n            // calulate sum\n            var sum = 0; // loop diagonal\n\n            for (var i = 0; i < rows; i++) {\n              sum = add(sum, data[i][i]);\n            } // return trace\n\n\n            return sum;\n          } else {\n            throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\n          }\n        }\n\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be two dimensional (size: ' + (0, _string.format)(size) + ')');\n    }\n  }\n\n  function _sparseTrace(m) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    var size = m._size; // check dimensions\n\n    var rows = size[0];\n    var columns = size[1]; // matrix must be square\n\n    if (rows === columns) {\n      // calulate sum\n      var sum = 0; // check we have data (avoid looping columns)\n\n      if (values.length > 0) {\n        // loop columns\n        for (var j = 0; j < columns; j++) {\n          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n          var k0 = ptr[j];\n          var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n          for (var k = k0; k < k1; k++) {\n            // row index\n            var i = index[k]; // check row\n\n            if (i === j) {\n              // accumulate value\n              sum = add(sum, values[k]); // exit loop\n\n              break;\n            }\n\n            if (i > j) {\n              // exit loop, no value on the diagonal for column j\n              break;\n            }\n          }\n        }\n      } // return trace\n\n\n      return sum;\n    }\n\n    throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\n  }\n});\nexports.createTrace = createTrace;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["SparseMatrix","DenseMatrix","__esModule","any","createTrace","value","Array"]],"~:compiled-at",1619135723953,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$trace.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/trace.js\"],\n\"sourcesContent\":[\"shadow$provide[246] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createTrace = void 0;\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'trace';\\nvar dependencies = ['typed', 'matrix', 'add'];\\nvar createTrace = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      add = _ref.add;\\n\\n  /**\\n   * Calculate the trace of a matrix: the sum of the elements on the main\\n   * diagonal of a square matrix.\\n   *\\n   * Syntax:\\n   *\\n   *    math.trace(x)\\n   *\\n   * Examples:\\n   *\\n   *    math.trace([[1, 2], [3, 4]]) // returns 5\\n   *\\n   *    const A = [\\n   *      [1, 2, 3],\\n   *      [-1, 2, 3],\\n   *      [2, 0, 3]\\n   *    ]\\n   *    math.trace(A) // returns 6\\n   *\\n   * See also:\\n   *\\n   *    diag\\n   *\\n   * @param {Array | Matrix} x  A matrix\\n   *\\n   * @return {number} The trace of `x`\\n   */\\n  return typed('trace', {\\n    Array: function _arrayTrace(x) {\\n      // use dense matrix implementation\\n      return _denseTrace(matrix(x));\\n    },\\n    SparseMatrix: _sparseTrace,\\n    DenseMatrix: _denseTrace,\\n    any: _object.clone\\n  });\\n\\n  function _denseTrace(m) {\\n    // matrix size & data\\n    var size = m._size;\\n    var data = m._data; // process dimensions\\n\\n    switch (size.length) {\\n      case 1:\\n        // vector\\n        if (size[0] === 1) {\\n          // return data[0]\\n          return (0, _object.clone)(data[0]);\\n        }\\n\\n        throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\\n\\n      case 2:\\n        {\\n          // two dimensional\\n          var rows = size[0];\\n          var cols = size[1];\\n\\n          if (rows === cols) {\\n            // calulate sum\\n            var sum = 0; // loop diagonal\\n\\n            for (var i = 0; i < rows; i++) {\\n              sum = add(sum, data[i][i]);\\n            } // return trace\\n\\n\\n            return sum;\\n          } else {\\n            throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\\n          }\\n        }\\n\\n      default:\\n        // multi dimensional\\n        throw new RangeError('Matrix must be two dimensional (size: ' + (0, _string.format)(size) + ')');\\n    }\\n  }\\n\\n  function _sparseTrace(m) {\\n    // matrix arrays\\n    var values = m._values;\\n    var index = m._index;\\n    var ptr = m._ptr;\\n    var size = m._size; // check dimensions\\n\\n    var rows = size[0];\\n    var columns = size[1]; // matrix must be square\\n\\n    if (rows === columns) {\\n      // calulate sum\\n      var sum = 0; // check we have data (avoid looping columns)\\n\\n      if (values.length > 0) {\\n        // loop columns\\n        for (var j = 0; j < columns; j++) {\\n          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\\n          var k0 = ptr[j];\\n          var k1 = ptr[j + 1]; // loop k within [k0, k1[\\n\\n          for (var k = k0; k < k1; k++) {\\n            // row index\\n            var i = index[k]; // check row\\n\\n            if (i === j) {\\n              // accumulate value\\n              sum = add(sum, values[k]); // exit loop\\n\\n              break;\\n            }\\n\\n            if (i > j) {\\n              // exit loop, no value on the diagonal for column j\\n              break;\\n            }\\n          }\\n        }\\n      } // return trace\\n\\n\\n      return sum;\\n    }\\n\\n    throw new RangeError('Matrix must be square (size: ' + (0, _string.format)(size) + ')');\\n  }\\n});\\nexports.createTrace = createTrace;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createTrace\",\"_object\",\"_string\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_denseTrace\",\"m\",\"size\",\"_size\",\"data\",\"_data\",\"length\",\"clone\",\"RangeError\",\"format\",\"rows\",\"cols\",\"i\",\"sum\",\"add\",\"typed\",\"matrix\",\"Array\",\"_arrayTrace\",\"x\",\"SparseMatrix\",\"_sparseTrace\",\"values\",\"_values\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"columns\",\"j\",\"k1\",\"k\",\"k0\",\"DenseMatrix\",\"any\"]\n}\n"]