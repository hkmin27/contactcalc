["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/diag.js"],"~:js","shadow$provide[125]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createDiag=void 0;var q=b(14),f=b(24),u=b(19);c=b(25);c=(0,c.factory)(\"diag\",[\"typed\",\"matrix\",\"DenseMatrix\",\"SparseMatrix\"],function(k){function t(h,n,r,v){if(!(0,u.isInteger)(n))throw new TypeError(\"Second parameter in function diag must be an integer\");var C=0<n?n:0,z=0>n?-n:0;switch(r.length){case 1:r=r[0];C=[r+z,r+C];if(v&&\"sparse\"!==v&&\"dense\"!==v)throw new TypeError(\"Unknown matrix type \".concat(v,'\"'));\nh=\"sparse\"===v?l.diagonal(C,h,n):d.diagonal(C,h,n);return null!==v?h:h.valueOf();case 2:if((0,q.isMatrix)(h))h=h.diagonal(n),v=null!==v?v!==h.storage()?g(h,v):h:h.valueOf();else{n=Math.min(r[0]-z,r[1]-C);r=[];for(var w=0;w<n;w++)r[w]=h[w+z][w+C];v=null!==v?g(r):r}return v}throw new RangeError(\"Matrix for function diag must be 2 dimensional\");}var p=k.typed,g=k.matrix,d=k.DenseMatrix,l=k.SparseMatrix;return p(\"diag\",{Array:function(h){return t(h,0,(0,f.arraySize)(h),null)},\"Array, number\":function(h,\nn){return t(h,n,(0,f.arraySize)(h),null)},\"Array, BigNumber\":function(h,n){return t(h,n.toNumber(),(0,f.arraySize)(h),null)},\"Array, string\":function(h,n){return t(h,0,(0,f.arraySize)(h),n)},\"Array, number, string\":function(h,n,r){return t(h,n,(0,f.arraySize)(h),r)},\"Array, BigNumber, string\":function(h,n,r){return t(h,n.toNumber(),(0,f.arraySize)(h),r)},Matrix:function(h){return t(h,0,h.size(),h.storage())},\"Matrix, number\":function(h,n){return t(h,n,h.size(),h.storage())},\"Matrix, BigNumber\":function(h,\nn){return t(h,n.toNumber(),h.size(),h.storage())},\"Matrix, string\":function(h,n){return t(h,0,h.size(),n)},\"Matrix, number, string\":function(h,n,r){return t(h,n,h.size(),r)},\"Matrix, BigNumber, string\":function(h,n,r){return t(h,n.toNumber(),h.size(),r)}})});a.createDiag=c}","~:source","shadow$provide[125] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDiag = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nvar createDiag = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix;\n\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, (0, _array.arraySize)(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, (0, _array.arraySize)(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, (0, _array.arraySize)(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, (0, _array.arraySize)(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!(0, _number.isInteger)(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if ((0, _is.isMatrix)(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});\nexports.createDiag = createDiag;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","createDiag","Matrix","Array"]],"~:compiled-at",1619135723803,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$diag.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/diag.js\"],\n\"sourcesContent\":[\"shadow$provide[125] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createDiag = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'diag';\\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\\nvar createDiag = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      DenseMatrix = _ref.DenseMatrix,\\n      SparseMatrix = _ref.SparseMatrix;\\n\\n  /**\\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\\n   *\\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\\n   * When k is positive, the values are placed on the super diagonal.\\n   * When k is negative, the values are placed on the sub diagonal.\\n   *\\n   * Syntax:\\n   *\\n   *     math.diag(X)\\n   *     math.diag(X, format)\\n   *     math.diag(X, k)\\n   *     math.diag(X, k, format)\\n   *\\n   * Examples:\\n   *\\n   *     // create a diagonal matrix\\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\\n   *\\n   *    // retrieve the diagonal from a matrix\\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\\n   *    math.diag(a)   // returns [1, 5, 9]\\n   *\\n   * See also:\\n   *\\n   *     ones, zeros, identity\\n   *\\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\\n   *                                    in or retrieved.\\n   * @param {string} [format='dense']   The matrix storage format.\\n   *\\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\\n   */\\n  return typed(name, {\\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\\n    Array: function Array(x) {\\n      return _diag(x, 0, (0, _array.arraySize)(x), null);\\n    },\\n    'Array, number': function ArrayNumber(x, k) {\\n      return _diag(x, k, (0, _array.arraySize)(x), null);\\n    },\\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), null);\\n    },\\n    'Array, string': function ArrayString(x, format) {\\n      return _diag(x, 0, (0, _array.arraySize)(x), format);\\n    },\\n    'Array, number, string': function ArrayNumberString(x, k, format) {\\n      return _diag(x, k, (0, _array.arraySize)(x), format);\\n    },\\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), format);\\n    },\\n    Matrix: function Matrix(x) {\\n      return _diag(x, 0, x.size(), x.storage());\\n    },\\n    'Matrix, number': function MatrixNumber(x, k) {\\n      return _diag(x, k, x.size(), x.storage());\\n    },\\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\\n      return _diag(x, k.toNumber(), x.size(), x.storage());\\n    },\\n    'Matrix, string': function MatrixString(x, format) {\\n      return _diag(x, 0, x.size(), format);\\n    },\\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\\n      return _diag(x, k, x.size(), format);\\n    },\\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\\n      return _diag(x, k.toNumber(), x.size(), format);\\n    }\\n  });\\n  /**\\n   * Creeate diagonal matrix from a vector or vice versa\\n   * @param {Array | Matrix} x\\n   * @param {number} k\\n   * @param {string} format Storage format for matrix. If null,\\n   *                          an Array is returned\\n   * @returns {Array | Matrix}\\n   * @private\\n   */\\n\\n  function _diag(x, k, size, format) {\\n    if (!(0, _number.isInteger)(k)) {\\n      throw new TypeError('Second parameter in function diag must be an integer');\\n    }\\n\\n    var kSuper = k > 0 ? k : 0;\\n    var kSub = k < 0 ? -k : 0; // check dimensions\\n\\n    switch (size.length) {\\n      case 1:\\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\\n\\n      case 2:\\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\\n    }\\n\\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\\n  }\\n\\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\\n    // matrix size\\n    var ms = [l + kSub, l + kSuper];\\n\\n    if (format && format !== 'sparse' && format !== 'dense') {\\n      throw new TypeError(\\\"Unknown matrix type \\\".concat(format, \\\"\\\\\\\"\\\"));\\n    } // create diagonal matrix\\n\\n\\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\\n\\n    return format !== null ? m : m.valueOf();\\n  }\\n\\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\\n    // check x is a Matrix\\n    if ((0, _is.isMatrix)(x)) {\\n      // get diagonal matrix\\n      var dm = x.diagonal(k); // check we need to return a matrix\\n\\n      if (format !== null) {\\n        // check we need to change matrix format\\n        if (format !== dm.storage()) {\\n          return matrix(dm, format);\\n        }\\n\\n        return dm;\\n      }\\n\\n      return dm.valueOf();\\n    } // vector size\\n\\n\\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\\n\\n    var vector = []; // loop diagonal\\n\\n    for (var i = 0; i < n; i++) {\\n      vector[i] = x[i + kSub][i + kSuper];\\n    } // check we need to return a matrix\\n\\n\\n    return format !== null ? matrix(vector) : vector;\\n  }\\n});\\nexports.createDiag = createDiag;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createDiag\",\"_is\",\"_array\",\"_number\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_diag\",\"x\",\"k\",\"size\",\"format\",\"isInteger\",\"TypeError\",\"kSuper\",\"kSub\",\"length\",\"ms\",\"l\",\"concat\",\"m\",\"SparseMatrix\",\"diagonal\",\"DenseMatrix\",\"valueOf\",\"isMatrix\",\"dm\",\"storage\",\"matrix\",\"n\",\"Math\",\"min\",\"vector\",\"i\",\"RangeError\",\"typed\",\"Array\",\"arraySize\",\"ArrayNumber\",\"ArrayBigNumber\",\"toNumber\",\"ArrayString\",\"ArrayNumberString\",\"ArrayBigNumberString\",\"Matrix\",\"MatrixNumber\",\"MatrixBigNumber\",\"MatrixString\",\"MatrixNumberString\",\"MatrixBigNumberString\"]\n}\n"]