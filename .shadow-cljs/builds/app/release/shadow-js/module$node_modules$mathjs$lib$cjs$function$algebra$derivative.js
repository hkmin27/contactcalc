["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/derivative.js"],"~:js","shadow$provide[567]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createDerivative=void 0;var q=b(14);c=b(25);c=(0,c.factory)(\"derivative\",\"typed config parse simplify equal isZero numeric ConstantNode FunctionNode OperatorNode ParenthesisNode SymbolNode\".split(\" \"),function(f){function u(D,F){return new n(h(D,F||t.number))}var k=f.typed,t=f.config,p=f.parse,g=f.simplify,d=f.equal,l=f.isZero,h=f.numeric,n=f.ConstantNode,r=f.FunctionNode,v=f.OperatorNode,C=f.ParenthesisNode,\nz=f.SymbolNode;f=k(\"derivative\",{\"Node, SymbolNode, Object\":function(D,F,E){var G={};B(G,D,F.name);D=x(D,G);return E.simplify?g(D):D},\"Node, SymbolNode\":function(D,F){return this(D,F,{simplify:!0})},\"string, SymbolNode\":function(D,F){return this(p(D),F)},\"string, SymbolNode, Object\":function(D,F,E){return this(p(D),F,E)},\"string, string\":function(D,F){return this(p(D),p(F))},\"string, string, Object\":function(D,F,E){return this(p(D),p(F),E)},\"Node, string\":function(D,F){return this(D,p(F))},\"Node, string, Object\":function(D,\nF,E){return this(D,p(F),E)}});f._simplify=!0;f.toTex=function(D){return w.apply(null,D.args)};var w=k(\"_derivTex\",{\"Node, SymbolNode\":function(D,F){return(0,q.isConstantNode)(D)&&\"string\"===(0,q.typeOf)(D.value)?w(p(D.value).toString(),F.toString(),1):w(D.toString(),F.toString(),1)},\"Node, ConstantNode\":function(D,F){if(\"string\"===(0,q.typeOf)(F.value))return w(D,p(F.value));throw Error(\"The second parameter to 'derivative' is a non-string constant\");},\"Node, SymbolNode, ConstantNode\":function(D,\nF,E){return w(D.toString(),F.name,E.value)},\"string, string, number\":function(D,F,E){return(1===E?\"{d\\\\over d\"+F+\"}\":\"{d^{\"+E+\"}\\\\over d\"+F+\"^{\"+E+\"}}\")+\"\\\\left[\".concat(D,\"\\\\right]\")}}),B=k(\"constTag\",{\"Object, ConstantNode, string\":function(D,F){return D[F]=!0},\"Object, SymbolNode, string\":function(D,F,E){return F.name!==E?D[F]=!0:!1},\"Object, ParenthesisNode, string\":function(D,F,E){return B(D,F.content,E)},\"Object, FunctionAssignmentNode, string\":function(D,F,E){return-1===F.params.indexOf(E)?\nD[F]=!0:B(D,F.expr,E)},\"Object, FunctionNode | OperatorNode, string\":function(D,F,E){if(0<F.args.length){for(var G=B(D,F.args[0],E),I=1;I<F.args.length;++I)G=B(D,F.args[I],E)&&G;if(G)return D[F]=!0}return!1}}),x=k(\"_derivative\",{\"ConstantNode, Object\":function(D){return u(0)},\"SymbolNode, Object\":function(D,F){return void 0!==F[D]?u(0):u(1)},\"ParenthesisNode, Object\":function(D,F){return new C(x(D.content,F))},\"FunctionAssignmentNode, Object\":function(D,F){return void 0!==F[D]?u(0):x(D.expr,F)},\"FunctionNode, Object\":function(D,\nF){if(1!==D.args.length&&(\"log\"!==D.name&&\"nthRoot\"!==D.name&&\"pow\"!==D.name||2!==D.args.length)){for(var E=0;E<D.args.length;++E)D.args[E]=u(0);D.compile().evaluate();throw Error(\"Expected TypeError, but none found\");}if(void 0!==F[D])return u(0);var G=D.args[0],I=!1;E=!1;switch(D.name){case \"cbrt\":I=!0;var L=new v(\"*\",\"multiply\",[u(3),new v(\"^\",\"pow\",[G,new v(\"/\",\"divide\",[u(2),u(3)])])]);break;case \"sqrt\":case \"nthRoot\":if(1===D.args.length)I=!0,L=new v(\"*\",\"multiply\",[u(2),new r(\"sqrt\",[G])]);\nelse if(2===D.args.length){var M=new v(\"/\",\"divide\",[u(1),D.args[1]]);F[M]=F[D.args[1]];return x(new v(\"^\",\"pow\",[G,M]),F)}break;case \"log10\":M=u(10);case \"log\":if(!M&&1===D.args.length)L=G.clone(),I=!0;else if(1===D.args.length&&M||2===D.args.length&&void 0!==F[D.args[1]])L=new v(\"*\",\"multiply\",[G.clone(),new r(\"log\",[M||D.args[1]])]),I=!0;else if(2===D.args.length)return x(new v(\"/\",\"divide\",[new r(\"log\",[G]),new r(\"log\",[D.args[1]])]),F);break;case \"pow\":return F[M]=F[D.args[1]],x(new v(\"^\",\"pow\",\n[G,D.args[1]]),F);case \"exp\":L=new r(\"exp\",[G.clone()]);break;case \"sin\":L=new r(\"cos\",[G.clone()]);break;case \"cos\":L=new v(\"-\",\"unaryMinus\",[new r(\"sin\",[G.clone()])]);break;case \"tan\":L=new v(\"^\",\"pow\",[new r(\"sec\",[G.clone()]),u(2)]);break;case \"sec\":L=new v(\"*\",\"multiply\",[D,new r(\"tan\",[G.clone()])]);break;case \"csc\":E=!0;L=new v(\"*\",\"multiply\",[D,new r(\"cot\",[G.clone()])]);break;case \"cot\":E=!0;L=new v(\"^\",\"pow\",[new r(\"csc\",[G.clone()]),u(2)]);break;case \"asin\":I=!0;L=new r(\"sqrt\",[new v(\"-\",\n\"subtract\",[u(1),new v(\"^\",\"pow\",[G.clone(),u(2)])])]);break;case \"acos\":E=I=!0;L=new r(\"sqrt\",[new v(\"-\",\"subtract\",[u(1),new v(\"^\",\"pow\",[G.clone(),u(2)])])]);break;case \"atan\":I=!0;L=new v(\"+\",\"add\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)]);break;case \"asec\":I=!0;L=new v(\"*\",\"multiply\",[new r(\"abs\",[G.clone()]),new r(\"sqrt\",[new v(\"-\",\"subtract\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)])])]);break;case \"acsc\":E=I=!0;L=new v(\"*\",\"multiply\",[new r(\"abs\",[G.clone()]),new r(\"sqrt\",[new v(\"-\",\"subtract\",\n[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)])])]);break;case \"acot\":E=I=!0;L=new v(\"+\",\"add\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)]);break;case \"sinh\":L=new r(\"cosh\",[G.clone()]);break;case \"cosh\":L=new r(\"sinh\",[G.clone()]);break;case \"tanh\":L=new v(\"^\",\"pow\",[new r(\"sech\",[G.clone()]),u(2)]);break;case \"sech\":E=!0;L=new v(\"*\",\"multiply\",[D,new r(\"tanh\",[G.clone()])]);break;case \"csch\":E=!0;L=new v(\"*\",\"multiply\",[D,new r(\"coth\",[G.clone()])]);break;case \"coth\":E=!0;L=new v(\"^\",\"pow\",[new r(\"csch\",\n[G.clone()]),u(2)]);break;case \"asinh\":I=!0;L=new r(\"sqrt\",[new v(\"+\",\"add\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)])]);break;case \"acosh\":I=!0;L=new r(\"sqrt\",[new v(\"-\",\"subtract\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)])]);break;case \"atanh\":I=!0;L=new v(\"-\",\"subtract\",[u(1),new v(\"^\",\"pow\",[G.clone(),u(2)])]);break;case \"asech\":E=I=!0;L=new v(\"*\",\"multiply\",[G.clone(),new r(\"sqrt\",[new v(\"-\",\"subtract\",[u(1),new v(\"^\",\"pow\",[G.clone(),u(2)])])])]);break;case \"acsch\":E=I=!0;L=new v(\"*\",\"multiply\",\n[new r(\"abs\",[G.clone()]),new r(\"sqrt\",[new v(\"+\",\"add\",[new v(\"^\",\"pow\",[G.clone(),u(2)]),u(1)])])]);break;case \"acoth\":E=I=!0;L=new v(\"-\",\"subtract\",[u(1),new v(\"^\",\"pow\",[G.clone(),u(2)])]);break;case \"abs\":L=new v(\"/\",\"divide\",[new r(new z(\"abs\"),[G.clone()]),G.clone()]);break;default:throw Error('Function \"'+D.name+'\" is not supported by derivative, or a wrong number of arguments is passed');}I?(D=\"/\",M=\"divide\"):(D=\"*\",M=\"multiply\");F=x(G,F);E&&(F=new v(\"-\",\"unaryMinus\",[F]));return new v(D,\nM,[F,L])},\"OperatorNode, Object\":function(D,F){if(void 0!==F[D])return u(0);if(\"+\"===D.op)return new v(D.op,D.fn,D.args.map(function(L){return x(L,F)}));if(\"-\"===D.op){if(D.isUnary())return new v(D.op,D.fn,[x(D.args[0],F)]);if(D.isBinary())return new v(D.op,D.fn,[x(D.args[0],F),x(D.args[1],F)])}if(\"*\"===D.op){var E=D.args.filter(function(L){return void 0!==F[L]});if(0<E.length){var G=D.args.filter(function(L){return void 0===F[L]});G=1===G.length?G[0]:new v(\"*\",\"multiply\",G);E=E.concat(x(G,F));return new v(\"*\",\n\"multiply\",E)}return new v(\"+\",\"add\",D.args.map(function(L){return new v(\"*\",\"multiply\",D.args.map(function(M){return M===L?x(M,F):M.clone()}))}))}if(\"/\"===D.op&&D.isBinary())return E=D.args[0],G=D.args[1],void 0!==F[G]?new v(\"/\",\"divide\",[x(E,F),G]):void 0!==F[E]?new v(\"*\",\"multiply\",[new v(\"-\",\"unaryMinus\",[E]),new v(\"/\",\"divide\",[x(G,F),new v(\"^\",\"pow\",[G.clone(),u(2)])])]):new v(\"/\",\"divide\",[new v(\"-\",\"subtract\",[new v(\"*\",\"multiply\",[x(E,F),G.clone()]),new v(\"*\",\"multiply\",[E.clone(),x(G,F)])]),\nnew v(\"^\",\"pow\",[G.clone(),u(2)])]);if(\"^\"===D.op&&D.isBinary()){E=D.args[0];G=D.args[1];if(void 0!==F[E])return(0,q.isConstantNode)(E)&&(l(E.value)||d(E.value,1))?u(0):new v(\"*\",\"multiply\",[D,new v(\"*\",\"multiply\",[new r(\"log\",[E.clone()]),x(G.clone(),F)])]);if(void 0!==F[G]){if((0,q.isConstantNode)(G)){if(l(G.value))return u(0);if(d(G.value,1))return x(E,F)}var I=new v(\"^\",\"pow\",[E.clone(),new v(\"-\",\"subtract\",[G,u(1)])]);return new v(\"*\",\"multiply\",[G.clone(),new v(\"*\",\"multiply\",[x(E,F),I])])}return new v(\"*\",\n\"multiply\",[new v(\"^\",\"pow\",[E.clone(),G.clone()]),new v(\"+\",\"add\",[new v(\"*\",\"multiply\",[x(E,F),new v(\"/\",\"divide\",[G.clone(),E.clone()])]),new v(\"*\",\"multiply\",[x(G,F),new r(\"log\",[E.clone()])])])])}throw Error('Operator \"'+D.op+'\" is not supported by derivative, or a wrong number of arguments is passed');}});return f});a.createDerivative=c}","~:source","shadow$provide[567] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDerivative = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'derivative';\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createDerivative = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      parse = _ref.parse,\n      simplify = _ref.simplify,\n      equal = _ref.equal,\n      isZero = _ref.isZero,\n      numeric = _ref.numeric,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * Takes the derivative of an expression expressed in parser Nodes.\n   * The derivative will be taken over the supplied variable in the\n   * second parameter. If there are multiple variables in the expression,\n   * it will return a partial derivative.\n   *\n   * This uses rules of differentiation which can be found here:\n   *\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\n   *\n   * Syntax:\n   *\n   *     derivative(expr, variable)\n   *     derivative(expr, variable, options)\n   *\n   * Examples:\n   *\n   *     math.derivative('x^2', 'x')                     // Node {2 * x}\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)\n   *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\n   *     const f = math.parse('x^2')\n   *     const x = math.parse('x')\n   *     math.derivative(f, x)                           // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, parse, evaluate\n   *\n   * @param  {Node | string} expr           The expression to differentiate\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\n   * @param  {{simplify: boolean}} [options]\n   *                         There is one option available, `simplify`, which\n   *                         is true by default. When false, output will not\n   *                         be simplified.\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  var derivative = typed('derivative', {\n    'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {\n      var constNodes = {};\n      constTag(constNodes, expr, variable.name);\n\n      var res = _derivative(expr, constNodes);\n\n      return options.simplify ? simplify(res) : res;\n    },\n    'Node, SymbolNode': function NodeSymbolNode(expr, variable) {\n      return this(expr, variable, {\n        simplify: true\n      });\n    },\n    'string, SymbolNode': function stringSymbolNode(expr, variable) {\n      return this(parse(expr), variable);\n    },\n    'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {\n      return this(parse(expr), variable, options);\n    },\n    'string, string': function stringString(expr, variable) {\n      return this(parse(expr), parse(variable));\n    },\n    'string, string, Object': function stringStringObject(expr, variable, options) {\n      return this(parse(expr), parse(variable), options);\n    },\n    'Node, string': function NodeString(expr, variable) {\n      return this(expr, parse(variable));\n    },\n    'Node, string, Object': function NodeStringObject(expr, variable, options) {\n      return this(expr, parse(variable), options);\n    } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\n      let res = expr\n      for (let i = 0; i < order; i++) {\n        let constNodes = {}\n        constTag(constNodes, expr, variable.name)\n        res = _derivative(res, constNodes)\n      }\n      return res\n    }\n    */\n\n  });\n  derivative._simplify = true;\n\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  }; // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\n  // NOTE: the optional \"order\" parameter here is currently unused\n\n\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function NodeSymbolNode(expr, x) {\n      if ((0, _is.isConstantNode)(expr) && (0, _is.typeOf)(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toString(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function NodeConstantNode(expr, x) {\n      if ((0, _is.typeOf)(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function stringStringNumber(expr, x, order) {\n      var d;\n\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n  /**\n   * Does a depth-first search on the expression tree to identify what Nodes\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\n   * constNodes. Classification is done as follows:\n   *\n   *   1. ConstantNodes are constants.\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\n   *      in the subtree it is not constant.\n   *\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {string} varName     Variable that we are differentiating\n   * @return {boolean}  if node is constant\n   */\n  // TODO: can we rewrite constTag into a pure function?\n\n\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return false;\n    },\n    'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {\n      if (node.params.indexOf(varName) === -1) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  /**\n   * Applies differentiation rules.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNodeObject(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {\n      if (node.args.length !== 1) {\n        funcArgsCheck(node);\n      }\n\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?\n\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n\n          break;\n\n        case 'log10':\n          arg1 = createConstantNode(10);\n\n        /* fall through! */\n\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n\n          break;\n\n        case 'pow':\n          constNodes[arg1] = constNodes[node.args[1]]; // Pass to pow operator node parser\n\n          return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\n\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n\n        default:\n          throw new Error('Function \"' + node.name + '\" is not supported by derivative, or a wrong number of arguments is passed');\n      }\n\n      var op, func;\n\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n      /* Apply chain rule to all functions:\n         F(x)  = f(g(x))\n         F'(x) = g'(x)*f'(g(x)) */\n\n\n      var chainDerivative = _derivative(arg0, constNodes);\n\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n\n\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n\n\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c\n\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n\n\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n\n\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if ((0, _is.isConstantNode)(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n\n\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n\n        if (constNodes[_arg2] !== undefined) {\n          if ((0, _is.isConstantNode)(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            } // Ignore exponent; f(x)^1 = f(x)\n\n\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n\n\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n\n\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n\n      throw new Error('Operator \"' + node.op + '\" is not supported by derivative, or a wrong number of arguments is passed');\n    }\n  });\n  /**\n   * Ensures the number of arguments for a function are correct,\n   * and will throw an error otherwise.\n   *\n   * @param {FunctionNode} node\n   */\n\n\n  function funcArgsCheck(node) {\n    // TODO add min, max etc\n    if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {\n      return;\n    } // There should be an incorrect number of arguments if we reach here\n    // Change all args to constants to avoid unidentified\n    // symbol error when compiling function\n\n\n    for (var i = 0; i < node.args.length; ++i) {\n      node.args[i] = createConstantNode(0);\n    }\n\n    node.compile().evaluate();\n    throw new Error('Expected TypeError, but none found');\n  }\n  /**\n   * Helper function to create a constant node with a specific type\n   * (number, BigNumber, Fraction)\n   * @param {number} value\n   * @param {string} [valueType]\n   * @return {ConstantNode}\n   */\n\n\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || config.number));\n  }\n\n  return derivative;\n});\nexports.createDerivative = createDerivative;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["simplify","__esModule","_simplify","value","toTex","createDerivative"]],"~:compiled-at",1619135724037,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$derivative.js\",\n\"lineCount\":16,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,gBAAR,CAA2B,IAAK,EAEhC,KAAIC,EAAMP,CAAA,CAAQ,EAAR,CAENQ,EAAAA,CAAWR,CAAA,CAAQ,EAAR,CAIXM,EAAAA,CAAkC,CAAC,CAAA,CAAGE,CAASC,CAAAA,OAAb,EAF3BC,YAE2B,CADnBC,oHAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CACmB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAgmB9FC,QAASA,EAAkB,CAACR,CAAD,CAAQS,CAAR,CAAmB,CAC5C,MAAO,KAAIC,CAAJ,CAAiBC,CAAA,CAAQX,CAAR,CAAeS,CAAf,EAA4BG,CAAOC,CAAAA,MAAnC,CAAjB,CADqC,CAhmBgD,IAC1FC,EAAQP,CAAKO,CAAAA,KAD6E,CAE1FF,EAASL,CAAKK,CAAAA,MAF4E,CAG1FG,EAAQR,CAAKQ,CAAAA,KAH6E,CAI1FC,EAAWT,CAAKS,CAAAA,QAJ0E,CAK1FC,EAAQV,CAAKU,CAAAA,KAL6E,CAM1FC,EAASX,CAAKW,CAAAA,MAN4E,CAO1FP,EAAUJ,CAAKI,CAAAA,OAP2E,CAQ1FD,EAAeH,CAAKG,CAAAA,YARsE,CAS1FS,EAAeZ,CAAKY,CAAAA,YATsE,CAU1FC,EAAeb,CAAKa,CAAAA,YAVsE,CAW1FC,EAAkBd,CAAKc,CAAAA,eAXmE;AAY1FC,EAAaf,CAAKe,CAAAA,UAwClBC,EAAAA,CAAaT,CAAA,CAAM,YAAN,CAAoB,CACnC,2BAA4BU,QAA6B,CAACC,CAAD,CAAOC,CAAP,CAAiBC,CAAjB,CAA0B,CACjF,IAAIC,EAAa,EACjBC,EAAA,CAASD,CAAT,CAAqBH,CAArB,CAA2BC,CAASrB,CAAAA,IAApC,CAEIyB,EAAAA,CAAMC,CAAA,CAAYN,CAAZ,CAAkBG,CAAlB,CAEV,OAAOD,EAAQX,CAAAA,QAAR,CAAmBA,CAAA,CAASc,CAAT,CAAnB,CAAmCA,CANuC,CADhD,CASnC,mBAAoBE,QAAuB,CAACP,CAAD,CAAOC,CAAP,CAAiB,CAC1D,MAAO,KAAA,CAAKD,CAAL,CAAWC,CAAX,CAAqB,CAC1BV,SAAU,CAAA,CADgB,CAArB,CADmD,CATzB,CAcnC,qBAAsBiB,QAAyB,CAACR,CAAD,CAAOC,CAAP,CAAiB,CAC9D,MAAO,KAAA,CAAKX,CAAA,CAAMU,CAAN,CAAL,CAAkBC,CAAlB,CADuD,CAd7B,CAiBnC,6BAA8BQ,QAA+B,CAACT,CAAD,CAAOC,CAAP,CAAiBC,CAAjB,CAA0B,CACrF,MAAO,KAAA,CAAKZ,CAAA,CAAMU,CAAN,CAAL,CAAkBC,CAAlB,CAA4BC,CAA5B,CAD8E,CAjBpD,CAoBnC,iBAAkBQ,QAAqB,CAACV,CAAD,CAAOC,CAAP,CAAiB,CACtD,MAAO,KAAA,CAAKX,CAAA,CAAMU,CAAN,CAAL,CAAkBV,CAAA,CAAMW,CAAN,CAAlB,CAD+C,CApBrB,CAuBnC,yBAA0BU,QAA2B,CAACX,CAAD,CAAOC,CAAP,CAAiBC,CAAjB,CAA0B,CAC7E,MAAO,KAAA,CAAKZ,CAAA,CAAMU,CAAN,CAAL,CAAkBV,CAAA,CAAMW,CAAN,CAAlB,CAAmCC,CAAnC,CADsE,CAvB5C,CA0BnC,eAAgBU,QAAmB,CAACZ,CAAD,CAAOC,CAAP,CAAiB,CAClD,MAAO,KAAA,CAAKD,CAAL,CAAWV,CAAA,CAAMW,CAAN,CAAX,CAD2C,CA1BjB,CA6BnC,uBAAwBY,QAAyB,CAACb,CAAD;AAAOC,CAAP,CAAiBC,CAAjB,CAA0B,CACzE,MAAO,KAAA,CAAKF,CAAL,CAAWV,CAAA,CAAMW,CAAN,CAAX,CAA4BC,CAA5B,CADkE,CA7BxC,CAApB,CA8CjBJ,EAAWgB,CAAAA,SAAX,CAAuB,CAAA,CAEvBhB,EAAWiB,CAAAA,KAAX,CAAmBC,QAAS,CAACC,CAAD,CAAQ,CAClC,MAAOC,EAAUC,CAAAA,KAAV,CAAgB,IAAhB,CAAsBF,CAAMG,CAAAA,IAA5B,CAD2B,CAMpC,KAAIF,EAAY7B,CAAA,CAAM,WAAN,CAAmB,CACjC,mBAAoBkB,QAAuB,CAACP,CAAD,CAAOqB,CAAP,CAAU,CACnD,MAAI,CAAC,CAAA,CAAG5C,CAAI6C,CAAAA,cAAR,EAAwBtB,CAAxB,CAAJ,EAAqE,QAArE,GAAqC,CAAC,CAAA,CAAGvB,CAAI8C,CAAAA,MAAR,EAAgBvB,CAAKzB,CAAAA,KAArB,CAArC,CACS2C,CAAA,CAAU5B,CAAA,CAAMU,CAAKzB,CAAAA,KAAX,CAAkBiD,CAAAA,QAAlB,EAAV,CAAwCH,CAAEG,CAAAA,QAAF,EAAxC,CAAsD,CAAtD,CADT,CAGSN,CAAA,CAAUlB,CAAKwB,CAAAA,QAAL,EAAV,CAA2BH,CAAEG,CAAAA,QAAF,EAA3B,CAAyC,CAAzC,CAJ0C,CADpB,CAQjC,qBAAsBC,QAAyB,CAACzB,CAAD,CAAOqB,CAAP,CAAU,CACvD,GAAiC,QAAjC,GAAI,CAAC,CAAA,CAAG5C,CAAI8C,CAAAA,MAAR,EAAgBF,CAAE9C,CAAAA,KAAlB,CAAJ,CACE,MAAO2C,EAAA,CAAUlB,CAAV,CAAgBV,CAAA,CAAM+B,CAAE9C,CAAAA,KAAR,CAAhB,CAEP,MAAUmD,MAAJ,CAAU,+DAAV,CAAN,CAJqD,CARxB,CAejC,iCAAkCC,QAAmC,CAAC3B,CAAD;AAAOqB,CAAP,CAAUO,CAAV,CAAiB,CACpF,MAAOV,EAAA,CAAUlB,CAAKwB,CAAAA,QAAL,EAAV,CAA2BH,CAAEzC,CAAAA,IAA7B,CAAmCgD,CAAMrD,CAAAA,KAAzC,CAD6E,CAfrD,CAkBjC,yBAA0BsD,QAA2B,CAAC7B,CAAD,CAAOqB,CAAP,CAAUO,CAAV,CAAiB,CASpE,OANc,CAAdE,GAAIF,CAAJE,CACM,YADNA,CACqBT,CADrBS,CACyB,GADzBA,CAGM,MAHNA,CAGeF,CAHfE,CAGuB,WAHvBA,CAGqCT,CAHrCS,CAGyC,IAHzCA,CAGgDF,CAHhDE,CAGwD,IAGxD,EAAW,SAAUC,CAAAA,MAAV,CAAiB/B,CAAjB,CAAuB,UAAvB,CATyD,CAlBrC,CAAnB,CAAhB,CA+CII,EAAWf,CAAA,CAAM,UAAN,CAAkB,CAC/B,+BAAgC2C,QAAiC,CAAC7B,CAAD,CAAa8B,CAAb,CAAmB,CAElF,MADA9B,EAAA,CAAW8B,CAAX,CACA,CADmB,CAAA,CAD+D,CADrD,CAK/B,6BAA8BC,QAA+B,CAAC/B,CAAD,CAAa8B,CAAb,CAAmBE,CAAnB,CAA4B,CAGvF,MAAIF,EAAKrD,CAAAA,IAAT,GAAkBuD,CAAlB,CACEhC,CAAA,CAAW8B,CAAX,CADF,CACqB,CAAA,CADrB,CAKO,CAAA,CARgF,CAL1D,CAe/B,kCAAmCG,QAAoC,CAACjC,CAAD,CAAa8B,CAAb,CAAmBE,CAAnB,CAA4B,CACjG,MAAO/B,EAAA,CAASD,CAAT,CAAqB8B,CAAKI,CAAAA,OAA1B,CAAmCF,CAAnC,CAD0F,CAfpE,CAkB/B,yCAA0CG,QAA2C,CAACnC,CAAD,CAAa8B,CAAb,CAAmBE,CAAnB,CAA4B,CAC/G,MAAqC,EAArC,GAAIF,CAAKM,CAAAA,MAAOC,CAAAA,OAAZ,CAAoBL,CAApB,CAAJ;AACEhC,CAAA,CAAW8B,CAAX,CADF,CACqB,CAAA,CADrB,CAKO7B,CAAA,CAASD,CAAT,CAAqB8B,CAAKjC,CAAAA,IAA1B,CAAgCmC,CAAhC,CANwG,CAlBlF,CA0B/B,8CAA+CM,QAA6C,CAACtC,CAAD,CAAa8B,CAAb,CAAmBE,CAAnB,CAA4B,CACtH,GAAuB,CAAvB,CAAIF,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,CAA0B,CAGxB,IAFA,IAAIC,EAAUvC,CAAA,CAASD,CAAT,CAAqB8B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAArB,CAAmCe,CAAnC,CAAd,CAESS,EAAI,CAAb,CAAgBA,CAAhB,CAAoBX,CAAKb,CAAAA,IAAKsB,CAAAA,MAA9B,CAAsC,EAAEE,CAAxC,CACED,CAAA,CAAUvC,CAAA,CAASD,CAAT,CAAqB8B,CAAKb,CAAAA,IAAL,CAAUwB,CAAV,CAArB,CAAmCT,CAAnC,CAAV,EAAyDQ,CAG3D,IAAIA,CAAJ,CAEE,MADAxC,EAAA,CAAW8B,CAAX,CACA,CADmB,CAAA,CARG,CAa1B,MAAO,CAAA,CAd+G,CA1BzF,CAAlB,CA/Cf,CAkGI3B,EAAcjB,CAAA,CAAM,aAAN,CAAqB,CACrC,uBAAwBwD,QAA2B,CAACZ,CAAD,CAAO,CACxD,MAAOlD,EAAA,CAAmB,CAAnB,CADiD,CADrB,CAIrC,qBAAsB+D,QAAyB,CAACb,CAAD,CAAO9B,CAAP,CAAmB,CAChE,MAAyB4C,KAAAA,EAAzB,GAAI5C,CAAA,CAAW8B,CAAX,CAAJ,CACSlD,CAAA,CAAmB,CAAnB,CADT,CAIOA,CAAA,CAAmB,CAAnB,CALyD,CAJ7B,CAWrC,0BAA2BiE,QAA8B,CAACf,CAAD,CAAO9B,CAAP,CAAmB,CAC1E,MAAO,KAAIP,CAAJ,CAAoBU,CAAA,CAAY2B,CAAKI,CAAAA,OAAjB,CAA0BlC,CAA1B,CAApB,CADmE,CAXvC,CAcrC,iCAAkC8C,QAAqC,CAAChB,CAAD,CAAO9B,CAAP,CAAmB,CACxF,MAAyB4C,KAAAA,EAAzB,GAAI5C,CAAA,CAAW8B,CAAX,CAAJ,CACSlD,CAAA,CAAmB,CAAnB,CADT,CAIOuB,CAAA,CAAY2B,CAAKjC,CAAAA,IAAjB,CAAuBG,CAAvB,CALiF,CAdrD,CAqBrC,uBAAwB+C,QAA2B,CAACjB,CAAD;AAAO9B,CAAP,CAAmB,CACpE,GAAyB,CAAzB,GAAI8B,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,GAuWiB,KAvWjB,GACgBT,CAsWRrD,CAAAA,IAvWR,EAuWwC,SAvWxC,GACgBqD,CAsWerD,CAAAA,IAvW/B,EAuWmE,KAvWnE,GACgBqD,CAsW0CrD,CAAAA,IAvW1D,EAuWkG,CAvWlG,GACgBqD,CAsWkEb,CAAAA,IAAKsB,CAAAA,MAvWvF,EAuWF,CAOA,IAAK,IAAIE,EAAI,CAAb,CAAgBA,CAAhB,CA7WkBX,CA6WOb,CAAAA,IAAKsB,CAAAA,MAA9B,CAAsC,EAAEE,CAAxC,CA7WkBX,CA8WXb,CAAAA,IAAL,CAAUwB,CAAV,CAAA,CAAe7D,CAAA,CAAmB,CAAnB,CA9WCkD,EAiXbkB,CAAAA,OAAL,EAAeC,CAAAA,QAAf,EACA,MAAU1B,MAAJ,CAAU,oCAAV,CAAN,CAZA,CAnWE,GAAyBqB,IAAAA,EAAzB,GAAI5C,CAAA,CAAW8B,CAAX,CAAJ,CACE,MAAOlD,EAAA,CAAmB,CAAnB,CAGT,KAAIsE,EAAOpB,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAX,CAEIkC,EAAM,CAAA,CAENC,EAAAA,CAAW,CAAA,CAIf,QAAQtB,CAAKrD,CAAAA,IAAb,EACE,KAAK,MAAL,CAEE0E,CAAA,CAAM,CAAA,CACN,KAAAE,EAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAD,CAAO,IAAI1D,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwBA,CAAA,CAAmB,CAAnB,CAAxB,CAAhC,CAAP,CAA7B,CAAxB,CAAlC,CACjB,MAEF,MAAK,MAAL,CACA,KAAK,SAAL,CAEE,GAAyB,CAAzB,GAAIkD,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,CACEY,CACA,CADM,CAAA,CACN,CAAAE,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIW,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAD,CAAzB,CAAxB,CAAlC,CAFnB;IAGO,IAAyB,CAAzB,GAAIpB,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,CAA4B,CAEjC,IAAAe,EAAO,IAAI9D,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwBkD,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAxB,CAAhC,CAEPjB,EAAA,CAAWsD,CAAX,CAAA,CAAmBtD,CAAA,CAAW8B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAX,CACnB,OAAOd,EAAA,CAAY,IAAIX,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAD,CAAOI,CAAP,CAA7B,CAAZ,CAAwDtD,CAAxD,CAL0B,CAQnC,KAEF,MAAK,OAAL,CACEsD,CAAA,CAAO1E,CAAA,CAAmB,EAAnB,CAIT,MAAK,KAAL,CACE,GAAI,CAAC0E,CAAL,EAAkC,CAAlC,GAAaxB,CAAKb,CAAAA,IAAKsB,CAAAA,MAAvB,CAEEc,CACA,CADiBH,CAAKK,CAAAA,KAAL,EACjB,CAAAJ,CAAA,CAAM,CAAA,CAHR,KAIO,IAAyB,CAAzB,GAAIrB,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,EAA8Be,CAA9B,EAA2D,CAA3D,GAAsCxB,CAAKb,CAAAA,IAAKsB,CAAAA,MAAhD,EAA6FK,IAAAA,EAA7F,GAAgE5C,CAAA,CAAW8B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAX,CAAhE,CAELoC,CACA,CADiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe,IAAIhE,CAAJ,CAAiB,KAAjB,CAAwB,CAAC+D,CAAD,EAASxB,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAT,CAAxB,CAAf,CAAlC,CACjB,CAAAkC,CAAA,CAAM,CAAA,CAHD,KAIA,IAAyB,CAAzB,GAAIrB,CAAKb,CAAAA,IAAKsB,CAAAA,MAAd,CAEL,MAAOpC,EAAA,CAAY,IAAIX,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAD,CAAxB,CAAD,CAAkC,IAAI3D,CAAJ,CAAiB,KAAjB,CAAwB,CAACuC,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAD,CAAxB,CAAlC,CAAhC,CAAZ,CAAyHjB,CAAzH,CAGT,MAEF,MAAK,KAAL,CAGE,MAFAA,EAAA,CAAWsD,CAAX,CAEO,CAFYtD,CAAA,CAAW8B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAX,CAEZ,CAAAd,CAAA,CAAY,IAAIX,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB;AAA6B,CAAC0D,CAAD,CAAOpB,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAP,CAA7B,CAAZ,CAAgEjB,CAAhE,CAET,MAAK,KAAL,CAEEqD,CAAA,CAAiB,IAAI9D,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CACjB,MAEF,MAAK,KAAL,CAEEF,CAAA,CAAiB,IAAI9D,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CACjB,MAEF,MAAK,KAAL,CAEEF,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,YAAtB,CAAoC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAApC,CACjB,MAEF,MAAK,KAAL,CAEEF,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0C3E,CAAA,CAAmB,CAAnB,CAA1C,CAA7B,CACjB,MAEF,MAAK,KAAL,CAEEyE,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACsC,CAAD,CAAO,IAAIvC,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAP,CAAlC,CACjB,MAEF,MAAK,KAAL,CAEEH,CAAA,CAAW,CAAA,CACXC,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACsC,CAAD,CAAO,IAAIvC,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAP,CAAlC,CACjB,MAEF,MAAK,KAAL,CAEEH,CAAA,CAAW,CAAA,CACXC,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0C3E,CAAA,CAAmB,CAAnB,CAA1C,CAA7B,CACjB,MAEF,MAAK,MAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB;AAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAxB,CAAlC,CAAD,CAAzB,CACjB,MAEF,MAAK,MAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAxB,CAAlC,CAAD,CAAzB,CACjB,MAEF,MAAK,MAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAA7B,CACjB,MAEF,MAAK,MAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0C,IAAIhE,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAAlC,CAAD,CAAzB,CAA1C,CAAlC,CACjB,MAEF,MAAK,MAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0C,IAAIhE,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB;AAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAAlC,CAAD,CAAzB,CAA1C,CAAlC,CACjB,MAEF,MAAK,MAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAA7B,CACjB,MAEF,MAAK,MAAL,CAEEyE,CAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CACjB,MAEF,MAAK,MAAL,CAEEF,CAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CACjB,MAEF,MAAK,MAAL,CAEEF,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAID,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CAAD,CAA2C3E,CAAA,CAAmB,CAAnB,CAA3C,CAA7B,CACjB,MAEF,MAAK,MAAL,CAEEwE,CAAA,CAAW,CAAA,CACXC,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACsC,CAAD,CAAO,IAAIvC,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CAAP,CAAlC,CACjB,MAEF,MAAK,MAAL,CAEEH,CAAA,CAAW,CAAA,CACXC,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACsC,CAAD,CAAO,IAAIvC,CAAJ,CAAiB,MAAjB,CAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CAAP,CAAlC,CACjB,MAEF,MAAK,MAAL,CAEEH,CAAA,CAAW,CAAA,CACXC,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAID,CAAJ,CAAiB,MAAjB;AAAyB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAzB,CAAD,CAA2C3E,CAAA,CAAmB,CAAnB,CAA3C,CAA7B,CACjB,MAEF,MAAK,OAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAA7B,CAAD,CAAzB,CACjB,MAEF,MAAK,OAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI9D,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAAlC,CAAD,CAAzB,CACjB,MAEF,MAAK,OAAL,CAEEuE,CAAA,CAAM,CAAA,CACNE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAxB,CAAlC,CACjB,MAEF,MAAK,OAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe,IAAIhE,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAxB,CAAlC,CAAD,CAAzB,CAAf,CAAlC,CACjB,MAEF,MAAK,OAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB;AAAkC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAAC2D,CAAKK,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0C,IAAIhE,CAAJ,CAAiB,MAAjB,CAAyB,CAAC,IAAIC,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAD,CAAsEA,CAAA,CAAmB,CAAnB,CAAtE,CAA7B,CAAD,CAAzB,CAA1C,CAAlC,CACjB,MAEF,MAAK,OAAL,CAGEwE,CAAA,CADAD,CACA,CADM,CAAA,CAENE,EAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACZ,CAAA,CAAmB,CAAnB,CAAD,CAAwB,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAxB,CAAlC,CACjB,MAEF,MAAK,KAAL,CAEEyE,CAAA,CAAiB,IAAI7D,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAAC,IAAID,CAAJ,CAAiB,IAAIG,CAAJ,CAAe,KAAf,CAAjB,CAAwC,CAACwD,CAAKK,CAAAA,KAAL,EAAD,CAAxC,CAAD,CAA0DL,CAAKK,CAAAA,KAAL,EAA1D,CAAhC,CACjB,MAIF,SACE,KAAUhC,MAAJ,CAAU,YAAV,CAAyBO,CAAKrD,CAAAA,IAA9B,CAAqC,4EAArC,CAAN,CA7MJ,CAkNI0E,CAAJ,EACEK,CACA,CADK,GACL,CAAAC,CAAA,CAAO,QAFT,GAIED,CACA,CADK,GACL,CAAAC,CAAA,CAAO,UALT,CAYIC,EAAAA,CAAkBvD,CAAA,CAAY+C,CAAZ,CAAkBlD,CAAlB,CAElBoD,EAAJ,GACEM,CADF,CACoB,IAAIlE,CAAJ,CAAiB,GAAjB,CAAsB,YAAtB,CAAoC,CAACkE,CAAD,CAApC,CADpB,CAIA,OAAO,KAAIlE,CAAJ,CAAiBgE,CAAjB;AAAqBC,CAArB,CAA2B,CAACC,CAAD,CAAkBL,CAAlB,CAA3B,CArP6D,CArBjC,CA4QrC,uBAAwBM,QAA2B,CAAC7B,CAAD,CAAO9B,CAAP,CAAmB,CACpE,GAAyB4C,IAAAA,EAAzB,GAAI5C,CAAA,CAAW8B,CAAX,CAAJ,CACE,MAAOlD,EAAA,CAAmB,CAAnB,CAGT,IAAgB,GAAhB,GAAIkD,CAAK0B,CAAAA,EAAT,CAEE,MAAO,KAAIhE,CAAJ,CAAiBsC,CAAK0B,CAAAA,EAAtB,CAA0B1B,CAAK8B,CAAAA,EAA/B,CAAmC9B,CAAKb,CAAAA,IAAK4C,CAAAA,GAAV,CAAc,QAAS,CAACC,CAAD,CAAM,CACrE,MAAO3D,EAAA,CAAY2D,CAAZ,CAAiB9D,CAAjB,CAD8D,CAA7B,CAAnC,CAKT,IAAgB,GAAhB,GAAI8B,CAAK0B,CAAAA,EAAT,CAAqB,CAEnB,GAAI1B,CAAKiC,CAAAA,OAAL,EAAJ,CACE,MAAO,KAAIvE,CAAJ,CAAiBsC,CAAK0B,CAAAA,EAAtB,CAA0B1B,CAAK8B,CAAAA,EAA/B,CAAmC,CAACzD,CAAA,CAAY2B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAZ,CAA0BjB,CAA1B,CAAD,CAAnC,CAIT,IAAI8B,CAAKkC,CAAAA,QAAL,EAAJ,CACE,MAAO,KAAIxE,CAAJ,CAAiBsC,CAAK0B,CAAAA,EAAtB,CAA0B1B,CAAK8B,CAAAA,EAA/B,CAAmC,CAACzD,CAAA,CAAY2B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAZ,CAA0BjB,CAA1B,CAAD,CAAwCG,CAAA,CAAY2B,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAAZ,CAA0BjB,CAA1B,CAAxC,CAAnC,CARU,CAYrB,GAAgB,GAAhB,GAAI8B,CAAK0B,CAAAA,EAAT,CAAqB,CAEnB,IAAIS,EAAgBnC,CAAKb,CAAAA,IAAKiD,CAAAA,MAAV,CAAiB,QAAS,CAACJ,CAAD,CAAM,CAClD,MAA2BlB,KAAAA,EAA3B,GAAO5C,CAAA,CAAW8D,CAAX,CAD2C,CAAhC,CAIpB,IAA2B,CAA3B,CAAIG,CAAc1B,CAAAA,MAAlB,CAA8B,CAC5B,IAAI4B,EAAmBrC,CAAKb,CAAAA,IAAKiD,CAAAA,MAAV,CAAiB,QAAS,CAACJ,CAAD,CAAM,CACrD,MAA2BlB,KAAAA,EAA3B,GAAO5C,CAAA,CAAW8D,CAAX,CAD8C,CAAhC,CAGnBM,EAAAA,CAA8C,CAA5B,GAAAD,CAAiB5B,CAAAA,MAAjB,CAAgC4B,CAAA,CAAiB,CAAjB,CAAhC,CAAsD,IAAI3E,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC2E,CAAlC,CACxEE,EAAAA,CAAUJ,CAAcrC,CAAAA,MAAd,CAAqBzB,CAAA,CAAYiE,CAAZ,CAA6BpE,CAA7B,CAArB,CACd,OAAO,KAAIR,CAAJ,CAAiB,GAAjB;AAAsB,UAAtB,CAAkC6E,CAAlC,CANqB,CAU9B,MAAO,KAAI7E,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6BsC,CAAKb,CAAAA,IAAK4C,CAAAA,GAAV,CAAc,QAAS,CAACS,CAAD,CAAW,CACpE,MAAO,KAAI9E,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkCsC,CAAKb,CAAAA,IAAK4C,CAAAA,GAAV,CAAc,QAAS,CAACU,CAAD,CAAW,CACzE,MAAOA,EAAA,GAAaD,CAAb,CAAwBnE,CAAA,CAAYoE,CAAZ,CAAsBvE,CAAtB,CAAxB,CAA4DuE,CAAShB,CAAAA,KAAT,EADM,CAAlC,CAAlC,CAD6D,CAAlC,CAA7B,CAhBY,CAuBrB,GAAgB,GAAhB,GAAIzB,CAAK0B,CAAAA,EAAT,EAAuB1B,CAAKkC,CAAAA,QAAL,EAAvB,CAIE,MAHId,EAGJ,CAHWpB,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAGX,CAFIqC,CAEJ,CAFWxB,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAEX,CAAyB2B,IAAAA,EAAzB,GAAI5C,CAAA,CAAWsD,CAAX,CAAJ,CACS,IAAI9D,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAACW,CAAA,CAAY+C,CAAZ,CAAkBlD,CAAlB,CAAD,CAAgCsD,CAAhC,CAAhC,CADT,CAKyBV,IAAAA,EAAzB,GAAI5C,CAAA,CAAWkD,CAAX,CAAJ,CACS,IAAI1D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,YAAtB,CAAoC,CAAC0D,CAAD,CAApC,CAAD,CAA8C,IAAI1D,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAACW,CAAA,CAAYmD,CAAZ,CAAkBtD,CAAlB,CAAD,CAAgC,IAAIR,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC8D,CAAKC,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAAhC,CAAhC,CAA9C,CAAlC,CADT,CAKO,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACW,CAAA,CAAY+C,CAAZ,CAAkBlD,CAAlB,CAAD,CAAgCsD,CAAKC,CAAAA,KAAL,EAAhC,CAAlC,CAAD,CAAmF,IAAI/D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC0D,CAAKK,CAAAA,KAAL,EAAD,CAAepD,CAAA,CAAYmD,CAAZ,CAAkBtD,CAAlB,CAAf,CAAlC,CAAnF,CAAlC,CAAD;AAA0M,IAAIR,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC8D,CAAKC,CAAAA,KAAL,EAAD,CAAe3E,CAAA,CAAmB,CAAnB,CAAf,CAA7B,CAA1M,CAAhC,CAGT,IAAgB,GAAhB,GAAIkD,CAAK0B,CAAAA,EAAT,EAAuB1B,CAAKkC,CAAAA,QAAL,EAAvB,CAAwC,CAClCQ,CAAAA,CAAO1C,CAAKb,CAAAA,IAAL,CAAU,CAAV,CACPwD,EAAAA,CAAQ3C,CAAKb,CAAAA,IAAL,CAAU,CAAV,CAEZ,IAAyB2B,IAAAA,EAAzB,GAAI5C,CAAA,CAAWwE,CAAX,CAAJ,CAEE,MAAI,CAAC,CAAA,CAAGlG,CAAI6C,CAAAA,cAAR,EAAwBqD,CAAxB,CAAJ,GAAsClF,CAAA,CAAOkF,CAAKpG,CAAAA,KAAZ,CAAtC,EAA4DiB,CAAA,CAAMmF,CAAKpG,CAAAA,KAAX,CAAkB,CAAlB,CAA5D,EACSQ,CAAA,CAAmB,CAAnB,CADT,CAKO,IAAIY,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACsC,CAAD,CAAO,IAAItC,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAAC,IAAID,CAAJ,CAAiB,KAAjB,CAAwB,CAACiF,CAAKjB,CAAAA,KAAL,EAAD,CAAxB,CAAD,CAA0CpD,CAAA,CAAYsE,CAAMlB,CAAAA,KAAN,EAAZ,CAA2BvD,CAA3B,CAA1C,CAAlC,CAAP,CAAlC,CAGT,IAA0B4C,IAAAA,EAA1B,GAAI5C,CAAA,CAAWyE,CAAX,CAAJ,CAAqC,CACnC,GAAI,CAAC,CAAA,CAAGnG,CAAI6C,CAAAA,cAAR,EAAwBsD,CAAxB,CAAJ,CAAoC,CAElC,GAAInF,CAAA,CAAOmF,CAAMrG,CAAAA,KAAb,CAAJ,CACE,MAAOQ,EAAA,CAAmB,CAAnB,CAIT,IAAIS,CAAA,CAAMoF,CAAMrG,CAAAA,KAAZ,CAAmB,CAAnB,CAAJ,CACE,MAAO+B,EAAA,CAAYqE,CAAZ,CAAkBxE,CAAlB,CARyB,CAapC,IAAI0E,EAAc,IAAIlF,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAACgF,CAAKjB,CAAAA,KAAL,EAAD,CAAe,IAAI/D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACiF,CAAD,CAAQ7F,CAAA,CAAmB,CAAnB,CAAR,CAAlC,CAAf,CAA7B,CAClB,OAAO,KAAIY,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACiF,CAAMlB,CAAAA,KAAN,EAAD,CAAgB,IAAI/D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACW,CAAA,CAAYqE,CAAZ,CAAkBxE,CAAlB,CAAD,CAAgC0E,CAAhC,CAAlC,CAAhB,CAAlC,CAf4B,CAmBrC,MAAO,KAAIlF,CAAJ,CAAiB,GAAjB;AAAsB,UAAtB,CAAkC,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAACgF,CAAKjB,CAAAA,KAAL,EAAD,CAAekB,CAAMlB,CAAAA,KAAN,EAAf,CAA7B,CAAD,CAA8D,IAAI/D,CAAJ,CAAiB,GAAjB,CAAsB,KAAtB,CAA6B,CAAC,IAAIA,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACW,CAAA,CAAYqE,CAAZ,CAAkBxE,CAAlB,CAAD,CAAgC,IAAIR,CAAJ,CAAiB,GAAjB,CAAsB,QAAtB,CAAgC,CAACiF,CAAMlB,CAAAA,KAAN,EAAD,CAAgBiB,CAAKjB,CAAAA,KAAL,EAAhB,CAAhC,CAAhC,CAAlC,CAAD,CAAqI,IAAI/D,CAAJ,CAAiB,GAAjB,CAAsB,UAAtB,CAAkC,CAACW,CAAA,CAAYsE,CAAZ,CAAmBzE,CAAnB,CAAD,CAAiC,IAAIT,CAAJ,CAAiB,KAAjB,CAAwB,CAACiF,CAAKjB,CAAAA,KAAL,EAAD,CAAxB,CAAjC,CAAlC,CAArI,CAA7B,CAA9D,CAAlC,CAjC+B,CAoCxC,KAAUhC,MAAJ,CAAU,YAAV,CAAyBO,CAAK0B,CAAAA,EAA9B,CAAmC,4EAAnC,CAAN,CApGoE,CA5QjC,CAArB,CAwZlB,OAAO7D,EApmBuF,CAA1D,CAsmBtC1B,EAAQI,CAAAA,gBAAR,CAA2BA,CApnBmC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/derivative.js\"],\n\"sourcesContent\":[\"shadow$provide[567] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createDerivative = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'derivative';\\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\\nvar createDerivative = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      config = _ref.config,\\n      parse = _ref.parse,\\n      simplify = _ref.simplify,\\n      equal = _ref.equal,\\n      isZero = _ref.isZero,\\n      numeric = _ref.numeric,\\n      ConstantNode = _ref.ConstantNode,\\n      FunctionNode = _ref.FunctionNode,\\n      OperatorNode = _ref.OperatorNode,\\n      ParenthesisNode = _ref.ParenthesisNode,\\n      SymbolNode = _ref.SymbolNode;\\n\\n  /**\\n   * Takes the derivative of an expression expressed in parser Nodes.\\n   * The derivative will be taken over the supplied variable in the\\n   * second parameter. If there are multiple variables in the expression,\\n   * it will return a partial derivative.\\n   *\\n   * This uses rules of differentiation which can be found here:\\n   *\\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\\n   *\\n   * Syntax:\\n   *\\n   *     derivative(expr, variable)\\n   *     derivative(expr, variable, options)\\n   *\\n   * Examples:\\n   *\\n   *     math.derivative('x^2', 'x')                     // Node {2 * x}\\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)\\n   *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}\\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\\n   *     const f = math.parse('x^2')\\n   *     const x = math.parse('x')\\n   *     math.derivative(f, x)                           // Node {2 * x}\\n   *\\n   * See also:\\n   *\\n   *     simplify, parse, evaluate\\n   *\\n   * @param  {Node | string} expr           The expression to differentiate\\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\\n   * @param  {{simplify: boolean}} [options]\\n   *                         There is one option available, `simplify`, which\\n   *                         is true by default. When false, output will not\\n   *                         be simplified.\\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\\n   */\\n  var derivative = typed('derivative', {\\n    'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {\\n      var constNodes = {};\\n      constTag(constNodes, expr, variable.name);\\n\\n      var res = _derivative(expr, constNodes);\\n\\n      return options.simplify ? simplify(res) : res;\\n    },\\n    'Node, SymbolNode': function NodeSymbolNode(expr, variable) {\\n      return this(expr, variable, {\\n        simplify: true\\n      });\\n    },\\n    'string, SymbolNode': function stringSymbolNode(expr, variable) {\\n      return this(parse(expr), variable);\\n    },\\n    'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {\\n      return this(parse(expr), variable, options);\\n    },\\n    'string, string': function stringString(expr, variable) {\\n      return this(parse(expr), parse(variable));\\n    },\\n    'string, string, Object': function stringStringObject(expr, variable, options) {\\n      return this(parse(expr), parse(variable), options);\\n    },\\n    'Node, string': function NodeString(expr, variable) {\\n      return this(expr, parse(variable));\\n    },\\n    'Node, string, Object': function NodeStringObject(expr, variable, options) {\\n      return this(expr, parse(variable), options);\\n    } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments\\n\\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\\n      let res = expr\\n      for (let i = 0; i < order; i++) {\\n        let constNodes = {}\\n        constTag(constNodes, expr, variable.name)\\n        res = _derivative(res, constNodes)\\n      }\\n      return res\\n    }\\n    */\\n\\n  });\\n  derivative._simplify = true;\\n\\n  derivative.toTex = function (deriv) {\\n    return _derivTex.apply(null, deriv.args);\\n  }; // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\\n  // NOTE: the optional \\\"order\\\" parameter here is currently unused\\n\\n\\n  var _derivTex = typed('_derivTex', {\\n    'Node, SymbolNode': function NodeSymbolNode(expr, x) {\\n      if ((0, _is.isConstantNode)(expr) && (0, _is.typeOf)(expr.value) === 'string') {\\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\\n      } else {\\n        return _derivTex(expr.toString(), x.toString(), 1);\\n      }\\n    },\\n    'Node, ConstantNode': function NodeConstantNode(expr, x) {\\n      if ((0, _is.typeOf)(x.value) === 'string') {\\n        return _derivTex(expr, parse(x.value));\\n      } else {\\n        throw new Error(\\\"The second parameter to 'derivative' is a non-string constant\\\");\\n      }\\n    },\\n    'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {\\n      return _derivTex(expr.toString(), x.name, order.value);\\n    },\\n    'string, string, number': function stringStringNumber(expr, x, order) {\\n      var d;\\n\\n      if (order === 1) {\\n        d = '{d\\\\\\\\over d' + x + '}';\\n      } else {\\n        d = '{d^{' + order + '}\\\\\\\\over d' + x + '^{' + order + '}}';\\n      }\\n\\n      return d + \\\"\\\\\\\\left[\\\".concat(expr, \\\"\\\\\\\\right]\\\");\\n    }\\n  });\\n  /**\\n   * Does a depth-first search on the expression tree to identify what Nodes\\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\\n   * constNodes. Classification is done as follows:\\n   *\\n   *   1. ConstantNodes are constants.\\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\\n   *      in the subtree it is not constant.\\n   *\\n   * @param  {Object} constNodes  Holds the nodes that are constant\\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\\n   * @param  {string} varName     Variable that we are differentiating\\n   * @return {boolean}  if node is constant\\n   */\\n  // TODO: can we rewrite constTag into a pure function?\\n\\n\\n  var constTag = typed('constTag', {\\n    'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {\\n      constNodes[node] = true;\\n      return true;\\n    },\\n    'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {\\n      // Treat other variables like constants. For reasoning, see:\\n      //   https://en.wikipedia.org/wiki/Partial_derivative\\n      if (node.name !== varName) {\\n        constNodes[node] = true;\\n        return true;\\n      }\\n\\n      return false;\\n    },\\n    'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {\\n      return constTag(constNodes, node.content, varName);\\n    },\\n    'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {\\n      if (node.params.indexOf(varName) === -1) {\\n        constNodes[node] = true;\\n        return true;\\n      }\\n\\n      return constTag(constNodes, node.expr, varName);\\n    },\\n    'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {\\n      if (node.args.length > 0) {\\n        var isConst = constTag(constNodes, node.args[0], varName);\\n\\n        for (var i = 1; i < node.args.length; ++i) {\\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\\n        }\\n\\n        if (isConst) {\\n          constNodes[node] = true;\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    }\\n  });\\n  /**\\n   * Applies differentiation rules.\\n   *\\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\\n   * @param  {Object} constNodes  Holds the nodes that are constant\\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\\n   */\\n\\n  var _derivative = typed('_derivative', {\\n    'ConstantNode, Object': function ConstantNodeObject(node) {\\n      return createConstantNode(0);\\n    },\\n    'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {\\n      if (constNodes[node] !== undefined) {\\n        return createConstantNode(0);\\n      }\\n\\n      return createConstantNode(1);\\n    },\\n    'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {\\n      return new ParenthesisNode(_derivative(node.content, constNodes));\\n    },\\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {\\n      if (constNodes[node] !== undefined) {\\n        return createConstantNode(0);\\n      }\\n\\n      return _derivative(node.expr, constNodes);\\n    },\\n    'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {\\n      if (node.args.length !== 1) {\\n        funcArgsCheck(node);\\n      }\\n\\n      if (constNodes[node] !== undefined) {\\n        return createConstantNode(0);\\n      }\\n\\n      var arg0 = node.args[0];\\n      var arg1;\\n      var div = false; // is output a fraction?\\n\\n      var negative = false; // is output negative?\\n\\n      var funcDerivative;\\n\\n      switch (node.name) {\\n        case 'cbrt':\\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\\n          div = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\\n          break;\\n\\n        case 'sqrt':\\n        case 'nthRoot':\\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\\n          if (node.args.length === 1) {\\n            div = true;\\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\\n          } else if (node.args.length === 2) {\\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?\\n\\n            constNodes[arg1] = constNodes[node.args[1]];\\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\\n          }\\n\\n          break;\\n\\n        case 'log10':\\n          arg1 = createConstantNode(10);\\n\\n        /* fall through! */\\n\\n        case 'log':\\n          if (!arg1 && node.args.length === 1) {\\n            // d/dx(log(x)) = 1 / x\\n            funcDerivative = arg0.clone();\\n            div = true;\\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\\n            div = true;\\n          } else if (node.args.length === 2) {\\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\\n          }\\n\\n          break;\\n\\n        case 'pow':\\n          constNodes[arg1] = constNodes[node.args[1]]; // Pass to pow operator node parser\\n\\n          return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\\n\\n        case 'exp':\\n          // d/dx(e^x) = e^x\\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\\n          break;\\n\\n        case 'sin':\\n          // d/dx(sin(x)) = cos(x)\\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\\n          break;\\n\\n        case 'cos':\\n          // d/dx(cos(x)) = -sin(x)\\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\\n          break;\\n\\n        case 'tan':\\n          // d/dx(tan(x)) = sec(x)^2\\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\\n          break;\\n\\n        case 'sec':\\n          // d/dx(sec(x)) = sec(x)tan(x)\\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\\n          break;\\n\\n        case 'csc':\\n          // d/dx(csc(x)) = -csc(x)cot(x)\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\\n          break;\\n\\n        case 'cot':\\n          // d/dx(cot(x)) = -csc(x)^2\\n          negative = true;\\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\\n          break;\\n\\n        case 'asin':\\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\\n          div = true;\\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\\n          break;\\n\\n        case 'acos':\\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\\n          div = true;\\n          negative = true;\\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\\n          break;\\n\\n        case 'atan':\\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\\n          div = true;\\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\\n          break;\\n\\n        case 'asec':\\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\\n          div = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\\n          break;\\n\\n        case 'acsc':\\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\\n          div = true;\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\\n          break;\\n\\n        case 'acot':\\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\\n          div = true;\\n          negative = true;\\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\\n          break;\\n\\n        case 'sinh':\\n          // d/dx(sinh(x)) = cosh(x)\\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\\n          break;\\n\\n        case 'cosh':\\n          // d/dx(cosh(x)) = sinh(x)\\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\\n          break;\\n\\n        case 'tanh':\\n          // d/dx(tanh(x)) = sech(x)^2\\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\\n          break;\\n\\n        case 'sech':\\n          // d/dx(sech(x)) = -sech(x)tanh(x)\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\\n          break;\\n\\n        case 'csch':\\n          // d/dx(csch(x)) = -csch(x)coth(x)\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\\n          break;\\n\\n        case 'coth':\\n          // d/dx(coth(x)) = -csch(x)^2\\n          negative = true;\\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\\n          break;\\n\\n        case 'asinh':\\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\\n          div = true;\\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\\n          break;\\n\\n        case 'acosh':\\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\\n          div = true;\\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\\n          break;\\n\\n        case 'atanh':\\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\\n          div = true;\\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\\n          break;\\n\\n        case 'asech':\\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\\n          div = true;\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\\n          break;\\n\\n        case 'acsch':\\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\\n          div = true;\\n          negative = true;\\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\\n          break;\\n\\n        case 'acoth':\\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\\n          div = true;\\n          negative = true;\\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\\n          break;\\n\\n        case 'abs':\\n          // d/dx(abs(x)) = abs(x)/x\\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\\n          break;\\n\\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\\n\\n        default:\\n          throw new Error('Function \\\"' + node.name + '\\\" is not supported by derivative, or a wrong number of arguments is passed');\\n      }\\n\\n      var op, func;\\n\\n      if (div) {\\n        op = '/';\\n        func = 'divide';\\n      } else {\\n        op = '*';\\n        func = 'multiply';\\n      }\\n      /* Apply chain rule to all functions:\\n         F(x)  = f(g(x))\\n         F'(x) = g'(x)*f'(g(x)) */\\n\\n\\n      var chainDerivative = _derivative(arg0, constNodes);\\n\\n      if (negative) {\\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\\n      }\\n\\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\\n    },\\n    'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {\\n      if (constNodes[node] !== undefined) {\\n        return createConstantNode(0);\\n      }\\n\\n      if (node.op === '+') {\\n        // d/dx(sum(f(x)) = sum(f'(x))\\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\\n          return _derivative(arg, constNodes);\\n        }));\\n      }\\n\\n      if (node.op === '-') {\\n        // d/dx(+/-f(x)) = +/-f'(x)\\n        if (node.isUnary()) {\\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\\n        } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\\n\\n\\n        if (node.isBinary()) {\\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\\n        }\\n      }\\n\\n      if (node.op === '*') {\\n        // d/dx(c*f(x)) = c*f'(x)\\n        var constantTerms = node.args.filter(function (arg) {\\n          return constNodes[arg] !== undefined;\\n        });\\n\\n        if (constantTerms.length > 0) {\\n          var nonConstantTerms = node.args.filter(function (arg) {\\n            return constNodes[arg] === undefined;\\n          });\\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\\n          return new OperatorNode('*', 'multiply', newArgs);\\n        } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\\n\\n\\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\\n          }));\\n        }));\\n      }\\n\\n      if (node.op === '/' && node.isBinary()) {\\n        var arg0 = node.args[0];\\n        var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c\\n\\n        if (constNodes[arg1] !== undefined) {\\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\\n        } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\\n\\n\\n        if (constNodes[arg0] !== undefined) {\\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\\n        } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\\n\\n\\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\\n      }\\n\\n      if (node.op === '^' && node.isBinary()) {\\n        var _arg = node.args[0];\\n        var _arg2 = node.args[1];\\n\\n        if (constNodes[_arg] !== undefined) {\\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\\n          if ((0, _is.isConstantNode)(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\\n            return createConstantNode(0);\\n          } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\\n\\n\\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\\n        }\\n\\n        if (constNodes[_arg2] !== undefined) {\\n          if ((0, _is.isConstantNode)(_arg2)) {\\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\\n            if (isZero(_arg2.value)) {\\n              return createConstantNode(0);\\n            } // Ignore exponent; f(x)^1 = f(x)\\n\\n\\n            if (equal(_arg2.value, 1)) {\\n              return _derivative(_arg, constNodes);\\n            }\\n          } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\\n\\n\\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\\n        } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\\n\\n\\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\\n      }\\n\\n      throw new Error('Operator \\\"' + node.op + '\\\" is not supported by derivative, or a wrong number of arguments is passed');\\n    }\\n  });\\n  /**\\n   * Ensures the number of arguments for a function are correct,\\n   * and will throw an error otherwise.\\n   *\\n   * @param {FunctionNode} node\\n   */\\n\\n\\n  function funcArgsCheck(node) {\\n    // TODO add min, max etc\\n    if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {\\n      return;\\n    } // There should be an incorrect number of arguments if we reach here\\n    // Change all args to constants to avoid unidentified\\n    // symbol error when compiling function\\n\\n\\n    for (var i = 0; i < node.args.length; ++i) {\\n      node.args[i] = createConstantNode(0);\\n    }\\n\\n    node.compile().evaluate();\\n    throw new Error('Expected TypeError, but none found');\\n  }\\n  /**\\n   * Helper function to create a constant node with a specific type\\n   * (number, BigNumber, Fraction)\\n   * @param {number} value\\n   * @param {string} [valueType]\\n   * @return {ConstantNode}\\n   */\\n\\n\\n  function createConstantNode(value, valueType) {\\n    return new ConstantNode(numeric(value, valueType || config.number));\\n  }\\n\\n  return derivative;\\n});\\nexports.createDerivative = createDerivative;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createDerivative\",\"_is\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"createConstantNode\",\"valueType\",\"ConstantNode\",\"numeric\",\"config\",\"number\",\"typed\",\"parse\",\"simplify\",\"equal\",\"isZero\",\"FunctionNode\",\"OperatorNode\",\"ParenthesisNode\",\"SymbolNode\",\"derivative\",\"NodeSymbolNodeObject\",\"expr\",\"variable\",\"options\",\"constNodes\",\"constTag\",\"res\",\"_derivative\",\"NodeSymbolNode\",\"stringSymbolNode\",\"stringSymbolNodeObject\",\"stringString\",\"stringStringObject\",\"NodeString\",\"NodeStringObject\",\"_simplify\",\"toTex\",\"derivative.toTex\",\"deriv\",\"_derivTex\",\"apply\",\"args\",\"x\",\"isConstantNode\",\"typeOf\",\"toString\",\"NodeConstantNode\",\"Error\",\"NodeSymbolNodeConstantNode\",\"order\",\"stringStringNumber\",\"d\",\"concat\",\"ObjectConstantNodeString\",\"node\",\"ObjectSymbolNodeString\",\"varName\",\"ObjectParenthesisNodeString\",\"content\",\"ObjectFunctionAssignmentNodeString\",\"params\",\"indexOf\",\"ObjectFunctionNodeOperatorNodeString\",\"length\",\"isConst\",\"i\",\"ConstantNodeObject\",\"SymbolNodeObject\",\"undefined\",\"ParenthesisNodeObject\",\"FunctionAssignmentNodeObject\",\"FunctionNodeObject\",\"compile\",\"evaluate\",\"arg0\",\"div\",\"negative\",\"funcDerivative\",\"arg1\",\"clone\",\"op\",\"func\",\"chainDerivative\",\"OperatorNodeObject\",\"fn\",\"map\",\"arg\",\"isUnary\",\"isBinary\",\"constantTerms\",\"filter\",\"nonConstantTerms\",\"nonConstantNode\",\"newArgs\",\"argOuter\",\"argInner\",\"_arg\",\"_arg2\",\"powMinusOne\"]\n}\n"]