["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/object.js"],"~:js","shadow$provide[15]=function(c,b,y,a){function q(r){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(v){return typeof v}:function(v){return v&&\"function\"===typeof Symbol&&v.constructor===Symbol&&v!==Symbol.prototype?\"symbol\":typeof v};return q(r)}function f(r){var v=q(r);if(\"number\"===v||\"string\"===v||\"boolean\"===v||null===r||void 0===r)return r;if(\"function\"===typeof r.clone)return r.clone();if(Array.isArray(r))return r.map(function(C){return f(C)});\nif(r instanceof Date)return new Date(r.valueOf());if((0,n.isBigNumber)(r))return r;if(r instanceof RegExp)throw new TypeError(\"Cannot clone \"+r);return u(r,f)}function u(r,v){var C={},z;for(z in r)d(r,z)&&(C[z]=v(r[z]));return C}function k(r,v){if(Array.isArray(v))throw new TypeError(\"Arrays are not supported by deepExtend\");for(var C in v)if(!(!d(v,C)||C in Object.prototype||C in Function.prototype))if(v[C]&&v[C].constructor===Object)void 0===r[C]&&(r[C]={}),r[C]&&r[C].constructor===Object?k(r[C],\nv[C]):r[C]=v[C];else{if(Array.isArray(v[C]))throw new TypeError(\"Arrays are not supported by deepExtend\");r[C]=v[C]}return r}function t(r,v){var C;if(Array.isArray(r)){if(!Array.isArray(v)||r.length!==v.length)return!1;var z=0;for(C=r.length;z<C;z++)if(!t(r[z],v[z]))return!1;return!0}if(\"function\"===typeof r)return r===v;if(r instanceof Object){if(Array.isArray(v)||!(v instanceof Object))return!1;for(z in r)if(!(z in v&&t(r[z],v[z])))return!1;for(z in v)if(!(z in r&&t(r[z],v[z])))return!1;return!0}return r===\nv}function p(r,v){for(var C in r)if(d(r,C)){var z=r[C];\"object\"===q(z)&&null!==z?p(z,v):v[C]=z}}function g(r,v){if(v&&\"string\"===typeof v)return g(r,v.split(\".\"));if(v)for(var C=0;C<v.length;C++){var z=v[C];z in r||(r[z]={});r=r[z]}return r}function d(r,v){return r&&Object.hasOwnProperty.call(r,v)}function l(r,v){if(\"string\"===typeof v)return-1!==v.indexOf(\".\")?l(r,v.split(\".\")):r[v];for(var C=0;C<v.length;C++){var z=v[C];r=r?r[z]:void 0}return r}function h(r,v,C){if(\"string\"===typeof v){if(-1!==\nv.indexOf(\".\"))return h(r,v.split(\".\"),C);r[v]=C;return r}for(var z=r,w=0;w<v.length-1;w++){var B=v[w];void 0===z[B]&&(z[B]={});z=z[B]}0<v.length&&(z[v[v.length-1]]=C);return r}Object.defineProperty(a,\"__esModule\",{value:!0});a.clone=f;a.mapObject=u;a.extend=function(r,v){for(var C in v)d(v,C)&&(r[C]=v[C]);return r};a.deepExtend=k;a.deepStrictEqual=t;a.deepFlatten=function(r){var v={};p(r,v);return v};a.canDefineProperty=function(){try{if(Object.defineProperty)return Object.defineProperty({},\"x\",\n{get:function(){}}),!0}catch(r){}return!1};a.lazy=function(r,v,C){var z=!0,w;Object.defineProperty(r,v,{get:function(){z&&(w=C(),z=!1);return w},set:function(B){w=B;z=!1},configurable:!0,enumerable:!0})};a.traverse=g;a.hasOwnProperty=d;a.isLegacyFactory=function(r){return r&&\"function\"===typeof r.factory};a.get=l;a.set=h;a.pick=function(r,v,C){for(var z={},w=0;w<v.length;w++){var B=v[w],x=l(r,B);void 0!==x&&h(z,B,C?C(x,B):x)}return z};a.pickShallow=function(r,v){for(var C={},z=0;z<v.length;z++){var w=\nv[z],B=r[w];void 0!==B&&(C[w]=B)}return C};a.values=function(r){return Object.keys(r).map(function(v){return r[v]})};var n=b(14)}","~:source","shadow$provide[15] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.mapObject = mapObject;\nexports.extend = extend;\nexports.deepExtend = deepExtend;\nexports.deepStrictEqual = deepStrictEqual;\nexports.deepFlatten = deepFlatten;\nexports.canDefineProperty = canDefineProperty;\nexports.lazy = lazy;\nexports.traverse = traverse;\nexports.hasOwnProperty = hasOwnProperty;\nexports.isLegacyFactory = isLegacyFactory;\nexports.get = get;\nexports.set = set;\nexports.pick = pick;\nexports.pickShallow = pickShallow;\nexports.values = values;\n\nvar _is = require(\"./is.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Clone an object\n *\n *     clone(x)\n *\n * Can clone any primitive type, array, and object.\n * If x has a function clone, this function will be invoked to clone the object.\n *\n * @param {*} x\n * @return {*} clone\n */\nfunction clone(x) {\n  var type = _typeof(x); // immutable primitive types\n\n\n  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {\n    return x;\n  } // use clone function of the object when available\n\n\n  if (typeof x.clone === 'function') {\n    return x.clone();\n  } // array\n\n\n  if (Array.isArray(x)) {\n    return x.map(function (value) {\n      return clone(value);\n    });\n  }\n\n  if (x instanceof Date) return new Date(x.valueOf());\n  if ((0, _is.isBigNumber)(x)) return x; // bignumbers are immutable\n\n  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp\n  // object\n\n  return mapObject(x, clone);\n}\n/**\n * Apply map to all properties of an object\n * @param {Object} object\n * @param {function} callback\n * @return {Object} Returns a copy of the object with mapped properties\n */\n\n\nfunction mapObject(object, callback) {\n  var clone = {};\n\n  for (var key in object) {\n    if (hasOwnProperty(object, key)) {\n      clone[key] = callback(object[key]);\n    }\n  }\n\n  return clone;\n}\n/**\n * Extend object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\n\n\nfunction extend(a, b) {\n  for (var prop in b) {\n    if (hasOwnProperty(b, prop)) {\n      a[prop] = b[prop];\n    }\n  }\n\n  return a;\n}\n/**\n * Deep extend an object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @returns {Object}\n */\n\n\nfunction deepExtend(a, b) {\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    // We check against prop not being in Object.prototype or Function.prototype\n    // to prevent polluting for example Object.__proto__.\n    if (hasOwnProperty(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n\n        if (a[prop] && a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop]);\n        } else {\n          a[prop] = b[prop];\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        a[prop] = b[prop];\n      }\n    }\n  }\n\n  return a;\n}\n/**\n * Deep test equality of all fields in two pairs of arrays or objects.\n * Compares values and functions strictly (ie. 2 is not the same as '2').\n * @param {Array | Object} a\n * @param {Array | Object} b\n * @returns {boolean}\n */\n\n\nfunction deepStrictEqual(a, b) {\n  var prop, i, len;\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!deepStrictEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (typeof a === 'function') {\n    return a === b;\n  } else if (a instanceof Object) {\n    if (Array.isArray(b) || !(b instanceof Object)) {\n      return false;\n    }\n\n    for (prop in a) {\n      // noinspection JSUnfilteredForInLoop\n      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    for (prop in b) {\n      // noinspection JSUnfilteredForInLoop\n      if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return a === b;\n  }\n}\n/**\n * Recursively flatten a nested object.\n * @param {Object} nestedObject\n * @return {Object} Returns the flattened object\n */\n\n\nfunction deepFlatten(nestedObject) {\n  var flattenedObject = {};\n\n  _deepFlatten(nestedObject, flattenedObject);\n\n  return flattenedObject;\n} // helper function used by deepFlatten\n\n\nfunction _deepFlatten(nestedObject, flattenedObject) {\n  for (var prop in nestedObject) {\n    if (hasOwnProperty(nestedObject, prop)) {\n      var value = nestedObject[prop];\n\n      if (_typeof(value) === 'object' && value !== null) {\n        _deepFlatten(value, flattenedObject);\n      } else {\n        flattenedObject[prop] = value;\n      }\n    }\n  }\n}\n/**\n * Test whether the current JavaScript engine supports Object.defineProperty\n * @returns {boolean} returns true if supported\n */\n\n\nfunction canDefineProperty() {\n  // test needed for broken IE8 implementation\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty({}, 'x', {\n        get: function get() {}\n      });\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n}\n/**\n * Attach a lazy loading property to a constant.\n * The given function `fn` is called once when the property is first requested.\n *\n * @param {Object} object         Object where to add the property\n * @param {string} prop           Property name\n * @param {Function} valueResolver Function returning the property value. Called\n *                                without arguments.\n */\n\n\nfunction lazy(object, prop, valueResolver) {\n  var _uninitialized = true;\n\n  var _value;\n\n  Object.defineProperty(object, prop, {\n    get: function get() {\n      if (_uninitialized) {\n        _value = valueResolver();\n        _uninitialized = false;\n      }\n\n      return _value;\n    },\n    set: function set(value) {\n      _value = value;\n      _uninitialized = false;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n/**\n * Traverse a path into an object.\n * When a namespace is missing, it will be created\n * @param {Object} object\n * @param {string | string[]} path   A dot separated string like 'name.space'\n * @return {Object} Returns the object at the end of the path\n */\n\n\nfunction traverse(object, path) {\n  if (path && typeof path === 'string') {\n    return traverse(object, path.split('.'));\n  }\n\n  var obj = object;\n\n  if (path) {\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (!(key in obj)) {\n        obj[key] = {};\n      }\n\n      obj = obj[key];\n    }\n  }\n\n  return obj;\n}\n/**\n * A safe hasOwnProperty\n * @param {Object} object\n * @param {string} property\n */\n\n\nfunction hasOwnProperty(object, property) {\n  return object && Object.hasOwnProperty.call(object, property);\n}\n/**\n * Test whether an object is a factory. a factory has fields:\n *\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\n * - name: string (optional)\n * - path: string    A dot separated path (optional)\n * - math: boolean   If true (false by default), the math namespace is passed\n *                   as fifth argument of the factory function\n *\n * @param {*} object\n * @returns {boolean}\n */\n\n\nfunction isLegacyFactory(object) {\n  return object && typeof object.factory === 'function';\n}\n/**\n * Get a nested property from an object\n * @param {Object} object\n * @param {string | string[]} path\n * @returns {Object}\n */\n\n\nfunction get(object, path) {\n  if (typeof path === 'string') {\n    if (isPath(path)) {\n      return get(object, path.split('.'));\n    } else {\n      return object[path];\n    }\n  }\n\n  var child = object;\n\n  for (var i = 0; i < path.length; i++) {\n    var key = path[i];\n    child = child ? child[key] : undefined;\n  }\n\n  return child;\n}\n/**\n * Set a nested property in an object\n * Mutates the object itself\n * If the path doesn't exist, it will be created\n * @param {Object} object\n * @param {string | string[]} path\n * @param {*} value\n * @returns {Object}\n */\n\n\nfunction set(object, path, value) {\n  if (typeof path === 'string') {\n    if (isPath(path)) {\n      return set(object, path.split('.'), value);\n    } else {\n      object[path] = value;\n      return object;\n    }\n  }\n\n  var child = object;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    var key = path[i];\n\n    if (child[key] === undefined) {\n      child[key] = {};\n    }\n\n    child = child[key];\n  }\n\n  if (path.length > 0) {\n    var lastKey = path[path.length - 1];\n    child[lastKey] = value;\n  }\n\n  return object;\n}\n/**\n * Create an object composed of the picked object properties\n * @param {Object} object\n * @param {string[]} properties\n * @param {function} [transform] Optional value to transform a value when picking it\n * @return {Object}\n */\n\n\nfunction pick(object, properties, transform) {\n  var copy = {};\n\n  for (var i = 0; i < properties.length; i++) {\n    var key = properties[i];\n    var value = get(object, key);\n\n    if (value !== undefined) {\n      set(copy, key, transform ? transform(value, key) : value);\n    }\n  }\n\n  return copy;\n}\n/**\n * Shallow version of pick, creating an object composed of the picked object properties\n * but not for nested properties\n * @param {Object} object\n * @param {string[]} properties\n * @return {Object}\n */\n\n\nfunction pickShallow(object, properties) {\n  var copy = {};\n\n  for (var i = 0; i < properties.length; i++) {\n    var key = properties[i];\n    var value = object[key];\n\n    if (value !== undefined) {\n      copy[key] = value;\n    }\n  }\n\n  return copy;\n}\n\nfunction values(object) {\n  return Object.keys(object).map(function (key) {\n    return object[key];\n  });\n} // helper function to test whether a string contains a path like 'user.name'\n\n\nfunction isPath(str) {\n  return str.indexOf('.') !== -1;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is"]],"~:properties",["^5",["canDefineProperty","values","deepFlatten","isLegacyFactory","deepExtend","hasOwnProperty","pick","x","__esModule","pickShallow","configurable","deepStrictEqual","value","traverse","enumerable","clone","extend","lazy","set","mapObject","get"]],"~:compiled-at",1619135723705,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$object.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/object.js\"],\n\"sourcesContent\":[\"shadow$provide[15] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.clone = clone;\\nexports.mapObject = mapObject;\\nexports.extend = extend;\\nexports.deepExtend = deepExtend;\\nexports.deepStrictEqual = deepStrictEqual;\\nexports.deepFlatten = deepFlatten;\\nexports.canDefineProperty = canDefineProperty;\\nexports.lazy = lazy;\\nexports.traverse = traverse;\\nexports.hasOwnProperty = hasOwnProperty;\\nexports.isLegacyFactory = isLegacyFactory;\\nexports.get = get;\\nexports.set = set;\\nexports.pick = pick;\\nexports.pickShallow = pickShallow;\\nexports.values = values;\\n\\nvar _is = require(\\\"./is.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * Clone an object\\n *\\n *     clone(x)\\n *\\n * Can clone any primitive type, array, and object.\\n * If x has a function clone, this function will be invoked to clone the object.\\n *\\n * @param {*} x\\n * @return {*} clone\\n */\\nfunction clone(x) {\\n  var type = _typeof(x); // immutable primitive types\\n\\n\\n  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {\\n    return x;\\n  } // use clone function of the object when available\\n\\n\\n  if (typeof x.clone === 'function') {\\n    return x.clone();\\n  } // array\\n\\n\\n  if (Array.isArray(x)) {\\n    return x.map(function (value) {\\n      return clone(value);\\n    });\\n  }\\n\\n  if (x instanceof Date) return new Date(x.valueOf());\\n  if ((0, _is.isBigNumber)(x)) return x; // bignumbers are immutable\\n\\n  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp\\n  // object\\n\\n  return mapObject(x, clone);\\n}\\n/**\\n * Apply map to all properties of an object\\n * @param {Object} object\\n * @param {function} callback\\n * @return {Object} Returns a copy of the object with mapped properties\\n */\\n\\n\\nfunction mapObject(object, callback) {\\n  var clone = {};\\n\\n  for (var key in object) {\\n    if (hasOwnProperty(object, key)) {\\n      clone[key] = callback(object[key]);\\n    }\\n  }\\n\\n  return clone;\\n}\\n/**\\n * Extend object a with the properties of object b\\n * @param {Object} a\\n * @param {Object} b\\n * @return {Object} a\\n */\\n\\n\\nfunction extend(a, b) {\\n  for (var prop in b) {\\n    if (hasOwnProperty(b, prop)) {\\n      a[prop] = b[prop];\\n    }\\n  }\\n\\n  return a;\\n}\\n/**\\n * Deep extend an object a with the properties of object b\\n * @param {Object} a\\n * @param {Object} b\\n * @returns {Object}\\n */\\n\\n\\nfunction deepExtend(a, b) {\\n  // TODO: add support for Arrays to deepExtend\\n  if (Array.isArray(b)) {\\n    throw new TypeError('Arrays are not supported by deepExtend');\\n  }\\n\\n  for (var prop in b) {\\n    // We check against prop not being in Object.prototype or Function.prototype\\n    // to prevent polluting for example Object.__proto__.\\n    if (hasOwnProperty(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {\\n      if (b[prop] && b[prop].constructor === Object) {\\n        if (a[prop] === undefined) {\\n          a[prop] = {};\\n        }\\n\\n        if (a[prop] && a[prop].constructor === Object) {\\n          deepExtend(a[prop], b[prop]);\\n        } else {\\n          a[prop] = b[prop];\\n        }\\n      } else if (Array.isArray(b[prop])) {\\n        throw new TypeError('Arrays are not supported by deepExtend');\\n      } else {\\n        a[prop] = b[prop];\\n      }\\n    }\\n  }\\n\\n  return a;\\n}\\n/**\\n * Deep test equality of all fields in two pairs of arrays or objects.\\n * Compares values and functions strictly (ie. 2 is not the same as '2').\\n * @param {Array | Object} a\\n * @param {Array | Object} b\\n * @returns {boolean}\\n */\\n\\n\\nfunction deepStrictEqual(a, b) {\\n  var prop, i, len;\\n\\n  if (Array.isArray(a)) {\\n    if (!Array.isArray(b)) {\\n      return false;\\n    }\\n\\n    if (a.length !== b.length) {\\n      return false;\\n    }\\n\\n    for (i = 0, len = a.length; i < len; i++) {\\n      if (!deepStrictEqual(a[i], b[i])) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  } else if (typeof a === 'function') {\\n    return a === b;\\n  } else if (a instanceof Object) {\\n    if (Array.isArray(b) || !(b instanceof Object)) {\\n      return false;\\n    }\\n\\n    for (prop in a) {\\n      // noinspection JSUnfilteredForInLoop\\n      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {\\n        return false;\\n      }\\n    }\\n\\n    for (prop in b) {\\n      // noinspection JSUnfilteredForInLoop\\n      if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  } else {\\n    return a === b;\\n  }\\n}\\n/**\\n * Recursively flatten a nested object.\\n * @param {Object} nestedObject\\n * @return {Object} Returns the flattened object\\n */\\n\\n\\nfunction deepFlatten(nestedObject) {\\n  var flattenedObject = {};\\n\\n  _deepFlatten(nestedObject, flattenedObject);\\n\\n  return flattenedObject;\\n} // helper function used by deepFlatten\\n\\n\\nfunction _deepFlatten(nestedObject, flattenedObject) {\\n  for (var prop in nestedObject) {\\n    if (hasOwnProperty(nestedObject, prop)) {\\n      var value = nestedObject[prop];\\n\\n      if (_typeof(value) === 'object' && value !== null) {\\n        _deepFlatten(value, flattenedObject);\\n      } else {\\n        flattenedObject[prop] = value;\\n      }\\n    }\\n  }\\n}\\n/**\\n * Test whether the current JavaScript engine supports Object.defineProperty\\n * @returns {boolean} returns true if supported\\n */\\n\\n\\nfunction canDefineProperty() {\\n  // test needed for broken IE8 implementation\\n  try {\\n    if (Object.defineProperty) {\\n      Object.defineProperty({}, 'x', {\\n        get: function get() {}\\n      });\\n      return true;\\n    }\\n  } catch (e) {}\\n\\n  return false;\\n}\\n/**\\n * Attach a lazy loading property to a constant.\\n * The given function `fn` is called once when the property is first requested.\\n *\\n * @param {Object} object         Object where to add the property\\n * @param {string} prop           Property name\\n * @param {Function} valueResolver Function returning the property value. Called\\n *                                without arguments.\\n */\\n\\n\\nfunction lazy(object, prop, valueResolver) {\\n  var _uninitialized = true;\\n\\n  var _value;\\n\\n  Object.defineProperty(object, prop, {\\n    get: function get() {\\n      if (_uninitialized) {\\n        _value = valueResolver();\\n        _uninitialized = false;\\n      }\\n\\n      return _value;\\n    },\\n    set: function set(value) {\\n      _value = value;\\n      _uninitialized = false;\\n    },\\n    configurable: true,\\n    enumerable: true\\n  });\\n}\\n/**\\n * Traverse a path into an object.\\n * When a namespace is missing, it will be created\\n * @param {Object} object\\n * @param {string | string[]} path   A dot separated string like 'name.space'\\n * @return {Object} Returns the object at the end of the path\\n */\\n\\n\\nfunction traverse(object, path) {\\n  if (path && typeof path === 'string') {\\n    return traverse(object, path.split('.'));\\n  }\\n\\n  var obj = object;\\n\\n  if (path) {\\n    for (var i = 0; i < path.length; i++) {\\n      var key = path[i];\\n\\n      if (!(key in obj)) {\\n        obj[key] = {};\\n      }\\n\\n      obj = obj[key];\\n    }\\n  }\\n\\n  return obj;\\n}\\n/**\\n * A safe hasOwnProperty\\n * @param {Object} object\\n * @param {string} property\\n */\\n\\n\\nfunction hasOwnProperty(object, property) {\\n  return object && Object.hasOwnProperty.call(object, property);\\n}\\n/**\\n * Test whether an object is a factory. a factory has fields:\\n *\\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\\n * - name: string (optional)\\n * - path: string    A dot separated path (optional)\\n * - math: boolean   If true (false by default), the math namespace is passed\\n *                   as fifth argument of the factory function\\n *\\n * @param {*} object\\n * @returns {boolean}\\n */\\n\\n\\nfunction isLegacyFactory(object) {\\n  return object && typeof object.factory === 'function';\\n}\\n/**\\n * Get a nested property from an object\\n * @param {Object} object\\n * @param {string | string[]} path\\n * @returns {Object}\\n */\\n\\n\\nfunction get(object, path) {\\n  if (typeof path === 'string') {\\n    if (isPath(path)) {\\n      return get(object, path.split('.'));\\n    } else {\\n      return object[path];\\n    }\\n  }\\n\\n  var child = object;\\n\\n  for (var i = 0; i < path.length; i++) {\\n    var key = path[i];\\n    child = child ? child[key] : undefined;\\n  }\\n\\n  return child;\\n}\\n/**\\n * Set a nested property in an object\\n * Mutates the object itself\\n * If the path doesn't exist, it will be created\\n * @param {Object} object\\n * @param {string | string[]} path\\n * @param {*} value\\n * @returns {Object}\\n */\\n\\n\\nfunction set(object, path, value) {\\n  if (typeof path === 'string') {\\n    if (isPath(path)) {\\n      return set(object, path.split('.'), value);\\n    } else {\\n      object[path] = value;\\n      return object;\\n    }\\n  }\\n\\n  var child = object;\\n\\n  for (var i = 0; i < path.length - 1; i++) {\\n    var key = path[i];\\n\\n    if (child[key] === undefined) {\\n      child[key] = {};\\n    }\\n\\n    child = child[key];\\n  }\\n\\n  if (path.length > 0) {\\n    var lastKey = path[path.length - 1];\\n    child[lastKey] = value;\\n  }\\n\\n  return object;\\n}\\n/**\\n * Create an object composed of the picked object properties\\n * @param {Object} object\\n * @param {string[]} properties\\n * @param {function} [transform] Optional value to transform a value when picking it\\n * @return {Object}\\n */\\n\\n\\nfunction pick(object, properties, transform) {\\n  var copy = {};\\n\\n  for (var i = 0; i < properties.length; i++) {\\n    var key = properties[i];\\n    var value = get(object, key);\\n\\n    if (value !== undefined) {\\n      set(copy, key, transform ? transform(value, key) : value);\\n    }\\n  }\\n\\n  return copy;\\n}\\n/**\\n * Shallow version of pick, creating an object composed of the picked object properties\\n * but not for nested properties\\n * @param {Object} object\\n * @param {string[]} properties\\n * @return {Object}\\n */\\n\\n\\nfunction pickShallow(object, properties) {\\n  var copy = {};\\n\\n  for (var i = 0; i < properties.length; i++) {\\n    var key = properties[i];\\n    var value = object[key];\\n\\n    if (value !== undefined) {\\n      copy[key] = value;\\n    }\\n  }\\n\\n  return copy;\\n}\\n\\nfunction values(object) {\\n  return Object.keys(object).map(function (key) {\\n    return object[key];\\n  });\\n} // helper function to test whether a string contains a path like 'user.name'\\n\\n\\nfunction isPath(str) {\\n  return str.indexOf('.') !== -1;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"clone\",\"x\",\"type\",\"undefined\",\"Array\",\"isArray\",\"map\",\"value\",\"Date\",\"valueOf\",\"_is\",\"isBigNumber\",\"RegExp\",\"TypeError\",\"mapObject\",\"object\",\"callback\",\"key\",\"hasOwnProperty\",\"deepExtend\",\"a\",\"b\",\"prop\",\"Object\",\"Function\",\"deepStrictEqual\",\"len\",\"length\",\"i\",\"_deepFlatten\",\"nestedObject\",\"flattenedObject\",\"traverse\",\"path\",\"split\",\"property\",\"call\",\"get\",\"indexOf\",\"child\",\"set\",\"lastKey\",\"defineProperty\",\"extend\",\"deepFlatten\",\"canDefineProperty\",\"e\",\"lazy\",\"valueResolver\",\"_uninitialized\",\"_value\",\"configurable\",\"enumerable\",\"isLegacyFactory\",\"factory\",\"pick\",\"properties\",\"transform\",\"copy\",\"pickShallow\",\"values\",\"keys\"]\n}\n"]