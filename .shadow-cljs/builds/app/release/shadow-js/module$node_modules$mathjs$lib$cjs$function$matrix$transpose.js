["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/transpose.js"],"~:js","shadow$provide[149]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createTranspose=void 0;var q=b(15),f=b(21);c=b(25);c=(0,c.factory)(\"transpose\",[\"typed\",\"matrix\"],function(u){var k=u.typed,t=u.matrix;return k(\"transpose\",{Array:function(p){return this(t(p)).valueOf()},Matrix:function(p){var g=p.size();switch(g.length){case 1:var d=p.clone();break;case 2:var l=g[0],h=g[1];if(0===h)throw new RangeError(\"Cannot transpose a 2D matrix with no columns (size: \"+(0,f.format)(g)+\")\");\nswitch(p.storage()){case \"dense\":g=p._data;d=[];for(var n,r=0;r<h;r++){n=d[r]=[];for(var v=0;v<l;v++)n[v]=(0,q.clone)(g[v][r])}d=p.createDenseMatrix({data:d,size:[h,l],datatype:p._datatype});break;case \"sparse\":g=p._values;d=p._index;n=p._ptr;r=g?[]:void 0;v=[];for(var C=[],z=[],w=0;w<l;w++)z[w]=0;var B;w=0;for(B=d.length;w<B;w++)z[d[w]]++;for(B=w=0;B<l;B++)C.push(w),w+=z[B],z[B]=C[B];C.push(w);for(w=0;w<h;w++){B=n[w+1];for(var x=n[w];x<B;x++){var D=z[d[x]]++;v[D]=w;g&&(r[D]=(0,q.clone)(g[x]))}}d=\np.createSparseMatrix({values:r,index:v,ptr:C,size:[h,l],datatype:p._datatype})}break;default:throw new RangeError(\"Matrix must be a vector or two dimensional (size: \"+(0,f.format)(this._size)+\")\");}return d},any:function(p){return(0,q.clone)(p)}})});a.createTranspose=c}","~:source","shadow$provide[149] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTranspose = void 0;\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nvar createTranspose = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix;\n\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed('transpose', {\n    Array: function Array(x) {\n      // use dense matrix implementation\n      return this(matrix(x)).valueOf();\n    },\n    Matrix: function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          {\n            // rows and columns\n            var rows = size[0];\n            var columns = size[1]; // check columns\n\n            if (columns === 0) {\n              // throw exception\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + (0, _string.format)(size) + ')');\n            } // process storage format\n\n\n            switch (x.storage()) {\n              case 'dense':\n                c = _denseTranspose(x, rows, columns);\n                break;\n\n              case 'sparse':\n                c = _sparseTranspose(x, rows, columns);\n                break;\n            }\n          }\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + (0, _string.format)(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    any: function any(x) {\n      return (0, _object.clone)(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = (0, _object.clone)(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = (0, _object.clone)(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});\nexports.createTranspose = createTranspose;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["values","index","createTranspose","__esModule","any","value","Matrix","datatype","size","Array","ptr","data"]],"~:compiled-at",1619135723889,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$transpose.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/transpose.js\"],\n\"sourcesContent\":[\"shadow$provide[149] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createTranspose = void 0;\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'transpose';\\nvar dependencies = ['typed', 'matrix'];\\nvar createTranspose = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix;\\n\\n  /**\\n   * Transpose a matrix. All values of the matrix are reflected over its\\n   * main diagonal. Only applicable to two dimensional matrices containing\\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\\n   * vectors and scalars return the input unchanged.\\n   *\\n   * Syntax:\\n   *\\n   *     math.transpose(x)\\n   *\\n   * Examples:\\n   *\\n   *     const A = [[1, 2, 3], [4, 5, 6]]\\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\\n   *\\n   * See also:\\n   *\\n   *     diag, inv, subset, squeeze\\n   *\\n   * @param {Array | Matrix} x  Matrix to be transposed\\n   * @return {Array | Matrix}   The transposed matrix\\n   */\\n  return typed('transpose', {\\n    Array: function Array(x) {\\n      // use dense matrix implementation\\n      return this(matrix(x)).valueOf();\\n    },\\n    Matrix: function Matrix(x) {\\n      // matrix size\\n      var size = x.size(); // result\\n\\n      var c; // process dimensions\\n\\n      switch (size.length) {\\n        case 1:\\n          // vector\\n          c = x.clone();\\n          break;\\n\\n        case 2:\\n          {\\n            // rows and columns\\n            var rows = size[0];\\n            var columns = size[1]; // check columns\\n\\n            if (columns === 0) {\\n              // throw exception\\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + (0, _string.format)(size) + ')');\\n            } // process storage format\\n\\n\\n            switch (x.storage()) {\\n              case 'dense':\\n                c = _denseTranspose(x, rows, columns);\\n                break;\\n\\n              case 'sparse':\\n                c = _sparseTranspose(x, rows, columns);\\n                break;\\n            }\\n          }\\n          break;\\n\\n        default:\\n          // multi dimensional\\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + (0, _string.format)(this._size) + ')');\\n      }\\n\\n      return c;\\n    },\\n    // scalars\\n    any: function any(x) {\\n      return (0, _object.clone)(x);\\n    }\\n  });\\n\\n  function _denseTranspose(m, rows, columns) {\\n    // matrix array\\n    var data = m._data; // transposed matrix data\\n\\n    var transposed = [];\\n    var transposedRow; // loop columns\\n\\n    for (var j = 0; j < columns; j++) {\\n      // initialize row\\n      transposedRow = transposed[j] = []; // loop rows\\n\\n      for (var i = 0; i < rows; i++) {\\n        // set data\\n        transposedRow[i] = (0, _object.clone)(data[i][j]);\\n      }\\n    } // return matrix\\n\\n\\n    return m.createDenseMatrix({\\n      data: transposed,\\n      size: [columns, rows],\\n      datatype: m._datatype\\n    });\\n  }\\n\\n  function _sparseTranspose(m, rows, columns) {\\n    // matrix arrays\\n    var values = m._values;\\n    var index = m._index;\\n    var ptr = m._ptr; // result matrices\\n\\n    var cvalues = values ? [] : undefined;\\n    var cindex = [];\\n    var cptr = []; // row counts\\n\\n    var w = [];\\n\\n    for (var x = 0; x < rows; x++) {\\n      w[x] = 0;\\n    } // vars\\n\\n\\n    var p, l, j; // loop values in matrix\\n\\n    for (p = 0, l = index.length; p < l; p++) {\\n      // number of values in row\\n      w[index[p]]++;\\n    } // cumulative sum\\n\\n\\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\\n\\n    for (var i = 0; i < rows; i++) {\\n      // update cptr\\n      cptr.push(sum); // update sum\\n\\n      sum += w[i]; // update w\\n\\n      w[i] = cptr[i];\\n    } // update cptr\\n\\n\\n    cptr.push(sum); // loop columns\\n\\n    for (j = 0; j < columns; j++) {\\n      // values & index in column\\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\\n        // C values & index\\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\\n\\n        cindex[q] = j; // check we need to process values (pattern matrix)\\n\\n        if (values) {\\n          cvalues[q] = (0, _object.clone)(values[k]);\\n        }\\n      }\\n    } // return matrix\\n\\n\\n    return m.createSparseMatrix({\\n      values: cvalues,\\n      index: cindex,\\n      ptr: cptr,\\n      size: [columns, rows],\\n      datatype: m._datatype\\n    });\\n  }\\n});\\nexports.createTranspose = createTranspose;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createTranspose\",\"_object\",\"_string\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"matrix\",\"Array\",\"x\",\"valueOf\",\"Matrix\",\"size\",\"length\",\"c\",\"clone\",\"rows\",\"columns\",\"RangeError\",\"format\",\"storage\",\"data\",\"_data\",\"transposed\",\"transposedRow\",\"j\",\"i\",\"createDenseMatrix\",\"datatype\",\"_datatype\",\"values\",\"_values\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"cvalues\",\"undefined\",\"cindex\",\"cptr\",\"w\",\"l\",\"p\",\"sum\",\"push\",\"k1\",\"k\",\"k0\",\"q\",\"createSparseMatrix\",\"_size\",\"any\"]\n}\n"]