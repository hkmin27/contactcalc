["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/matrix/Range.js"],"~:js","shadow$provide[34]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createRangeClass=void 0;var q=b(14),f=b(19);c=b(25);c=(0,c.factory)(\"Range\",[],function(){function u(k,t,p){if(!(this instanceof u))throw new SyntaxError(\"Constructor must be called with the new operator\");var g=null!==k&&void 0!==k,d=null!==t&&void 0!==t,l=null!==p&&void 0!==p;if(g)if((0,q.isBigNumber)(k))k=k.toNumber();else if(\"number\"!==typeof k)throw new TypeError(\"Parameter start must be a number\");if(d)if((0,\nq.isBigNumber)(t))t=t.toNumber();else if(\"number\"!==typeof t)throw new TypeError(\"Parameter end must be a number\");if(l)if((0,q.isBigNumber)(p))p=p.toNumber();else if(\"number\"!==typeof p)throw new TypeError(\"Parameter step must be a number\");this.start=g?parseFloat(k):0;this.end=d?parseFloat(t):0;this.step=l?parseFloat(p):1}u.prototype.type=\"Range\";u.prototype.isRange=!0;u.parse=function(k){if(\"string\"!==typeof k)return null;k=k.split(\":\").map(function(t){return parseFloat(t)});if(k.some(function(t){return isNaN(t)}))return null;\nswitch(k.length){case 2:return new u(k[0],k[1]);case 3:return new u(k[0],k[2],k[1]);default:return null}};u.prototype.clone=function(){return new u(this.start,this.end,this.step)};u.prototype.size=function(){var k=0,t=this.step,p=this.end-this.start;(0,f.sign)(t)===(0,f.sign)(p)?k=Math.ceil(p/t):0===p&&(k=0);isNaN(k)&&(k=0);return[k]};u.prototype.min=function(){var k=this.size()[0];if(0<k)return 0<this.step?this.start:this.start+(k-1)*this.step};u.prototype.max=function(){var k=this.size()[0];if(0<\nk)return 0<this.step?this.start+(k-1)*this.step:this.start};u.prototype.forEach=function(k){var t=this.start,p=this.step,g=this.end,d=0;if(0<p)for(;t<g;)k(t,[d],this),t+=p,d++;else if(0>p)for(;t>g;)k(t,[d],this),t+=p,d++};u.prototype.map=function(k){var t=[];this.forEach(function(p,g,d){t[g[0]]=k(p,g,d)});return t};u.prototype.toArray=function(){var k=[];this.forEach(function(t,p){k[p[0]]=t});return k};u.prototype.valueOf=function(){return this.toArray()};u.prototype.format=function(k){var t=(0,f.format)(this.start,\nk);1!==this.step&&(t+=\":\"+(0,f.format)(this.step,k));return t+=\":\"+(0,f.format)(this.end,k)};u.prototype.toString=function(){return this.format()};u.prototype.toJSON=function(){return{mathjs:\"Range\",start:this.start,end:this.end,step:this.step}};u.fromJSON=function(k){return new u(k.start,k.end,k.step)};return u},{isClass:!0});a.createRangeClass=c}","~:source","shadow$provide[34] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRangeClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Range';\nvar dependencies = [];\nvar createRangeClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function () {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *\n   *     const range = new Range(start, end)\n   *     const range = new Range(start, end, step)\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x)\n   *     })\n   *     range.map(function (x) {\n   *         return math.sin(x)\n   *     })\n   *     range.toArray()\n   *\n   * Example usage:\n   *\n   *     const c = new Range(2, 6)       // 2:1:5\n   *     c.toArray()                     // [2, 3, 4, 5]\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    var hasStart = start !== null && start !== undefined;\n    var hasEnd = end !== null && end !== undefined;\n    var hasStep = step !== null && step !== undefined;\n\n    if (hasStart) {\n      if ((0, _is.isBigNumber)(start)) {\n        start = start.toNumber();\n      } else if (typeof start !== 'number') {\n        throw new TypeError('Parameter start must be a number');\n      }\n    }\n\n    if (hasEnd) {\n      if ((0, _is.isBigNumber)(end)) {\n        end = end.toNumber();\n      } else if (typeof end !== 'number') {\n        throw new TypeError('Parameter end must be a number');\n      }\n    }\n\n    if (hasStep) {\n      if ((0, _is.isBigNumber)(step)) {\n        step = step.toNumber();\n      } else if (typeof step !== 'number') {\n        throw new TypeError('Parameter step must be a number');\n      }\n    }\n\n    this.start = hasStart ? parseFloat(start) : 0;\n    this.end = hasEnd ? parseFloat(end) : 0;\n    this.step = hasStep ? parseFloat(step) : 1;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n\n\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n\n\n  Range.prototype.size = function () {\n    var len = 0;\n    var start = this.start;\n    var step = this.step;\n    var end = this.end;\n    var diff = end - start;\n\n    if ((0, _number.sign)(step) === (0, _number.sign)(diff)) {\n      len = Math.ceil(diff / step);\n    } else if (diff === 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n\n    return [len];\n  };\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n\n\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      } else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n\n\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      } else {\n        // negative step\n        return this.start;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n\n\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Range.prototype.format = function (options) {\n    var str = (0, _number.format)(this.start, options);\n\n    if (this.step !== 1) {\n      str += ':' + (0, _number.format)(this.step, options);\n    }\n\n    str += ':' + (0, _number.format)(this.end, options);\n    return str;\n  };\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n\n\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n\n\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n\n\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}, {\n  isClass: true\n});\nexports.createRangeClass = createRangeClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","min","forEach","valueOf","createRangeClass","fromJSON","isClass","__esModule","max","toString","value","isRange","start","mathjs","type","clone","parse","size","toArray","end","format","step","toJSON"]],"~:compiled-at",1619135723742,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$matrix$Range.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/matrix/Range.js\"],\n\"sourcesContent\":[\"shadow$provide[34] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createRangeClass = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'Range';\\nvar dependencies = [];\\nvar createRangeClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function () {\\n  /**\\n   * Create a range. A range has a start, step, and end, and contains functions\\n   * to iterate over the range.\\n   *\\n   * A range can be constructed as:\\n   *\\n   *     const range = new Range(start, end)\\n   *     const range = new Range(start, end, step)\\n   *\\n   * To get the result of the range:\\n   *     range.forEach(function (x) {\\n   *         console.log(x)\\n   *     })\\n   *     range.map(function (x) {\\n   *         return math.sin(x)\\n   *     })\\n   *     range.toArray()\\n   *\\n   * Example usage:\\n   *\\n   *     const c = new Range(2, 6)       // 2:1:5\\n   *     c.toArray()                     // [2, 3, 4, 5]\\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\\n   *\\n   * @class Range\\n   * @constructor Range\\n   * @param {number} start  included lower bound\\n   * @param {number} end    excluded upper bound\\n   * @param {number} [step] step size, default value is 1\\n   */\\n  function Range(start, end, step) {\\n    if (!(this instanceof Range)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    var hasStart = start !== null && start !== undefined;\\n    var hasEnd = end !== null && end !== undefined;\\n    var hasStep = step !== null && step !== undefined;\\n\\n    if (hasStart) {\\n      if ((0, _is.isBigNumber)(start)) {\\n        start = start.toNumber();\\n      } else if (typeof start !== 'number') {\\n        throw new TypeError('Parameter start must be a number');\\n      }\\n    }\\n\\n    if (hasEnd) {\\n      if ((0, _is.isBigNumber)(end)) {\\n        end = end.toNumber();\\n      } else if (typeof end !== 'number') {\\n        throw new TypeError('Parameter end must be a number');\\n      }\\n    }\\n\\n    if (hasStep) {\\n      if ((0, _is.isBigNumber)(step)) {\\n        step = step.toNumber();\\n      } else if (typeof step !== 'number') {\\n        throw new TypeError('Parameter step must be a number');\\n      }\\n    }\\n\\n    this.start = hasStart ? parseFloat(start) : 0;\\n    this.end = hasEnd ? parseFloat(end) : 0;\\n    this.step = hasStep ? parseFloat(step) : 1;\\n  }\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  Range.prototype.type = 'Range';\\n  Range.prototype.isRange = true;\\n  /**\\n   * Parse a string into a range,\\n   * The string contains the start, optional step, and end, separated by a colon.\\n   * If the string does not contain a valid range, null is returned.\\n   * For example str='0:2:11'.\\n   * @memberof Range\\n   * @param {string} str\\n   * @return {Range | null} range\\n   */\\n\\n  Range.parse = function (str) {\\n    if (typeof str !== 'string') {\\n      return null;\\n    }\\n\\n    var args = str.split(':');\\n    var nums = args.map(function (arg) {\\n      return parseFloat(arg);\\n    });\\n    var invalid = nums.some(function (num) {\\n      return isNaN(num);\\n    });\\n\\n    if (invalid) {\\n      return null;\\n    }\\n\\n    switch (nums.length) {\\n      case 2:\\n        return new Range(nums[0], nums[1]);\\n\\n      case 3:\\n        return new Range(nums[0], nums[2], nums[1]);\\n\\n      default:\\n        return null;\\n    }\\n  };\\n  /**\\n   * Create a clone of the range\\n   * @return {Range} clone\\n   */\\n\\n\\n  Range.prototype.clone = function () {\\n    return new Range(this.start, this.end, this.step);\\n  };\\n  /**\\n   * Retrieve the size of the range.\\n   * Returns an array containing one number, the number of elements in the range.\\n   * @memberof Range\\n   * @returns {number[]} size\\n   */\\n\\n\\n  Range.prototype.size = function () {\\n    var len = 0;\\n    var start = this.start;\\n    var step = this.step;\\n    var end = this.end;\\n    var diff = end - start;\\n\\n    if ((0, _number.sign)(step) === (0, _number.sign)(diff)) {\\n      len = Math.ceil(diff / step);\\n    } else if (diff === 0) {\\n      len = 0;\\n    }\\n\\n    if (isNaN(len)) {\\n      len = 0;\\n    }\\n\\n    return [len];\\n  };\\n  /**\\n   * Calculate the minimum value in the range\\n   * @memberof Range\\n   * @return {number | undefined} min\\n   */\\n\\n\\n  Range.prototype.min = function () {\\n    var size = this.size()[0];\\n\\n    if (size > 0) {\\n      if (this.step > 0) {\\n        // positive step\\n        return this.start;\\n      } else {\\n        // negative step\\n        return this.start + (size - 1) * this.step;\\n      }\\n    } else {\\n      return undefined;\\n    }\\n  };\\n  /**\\n   * Calculate the maximum value in the range\\n   * @memberof Range\\n   * @return {number | undefined} max\\n   */\\n\\n\\n  Range.prototype.max = function () {\\n    var size = this.size()[0];\\n\\n    if (size > 0) {\\n      if (this.step > 0) {\\n        // positive step\\n        return this.start + (size - 1) * this.step;\\n      } else {\\n        // negative step\\n        return this.start;\\n      }\\n    } else {\\n      return undefined;\\n    }\\n  };\\n  /**\\n   * Execute a callback function for each value in the range.\\n   * @memberof Range\\n   * @param {function} callback   The callback method is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Range being traversed.\\n   */\\n\\n\\n  Range.prototype.forEach = function (callback) {\\n    var x = this.start;\\n    var step = this.step;\\n    var end = this.end;\\n    var i = 0;\\n\\n    if (step > 0) {\\n      while (x < end) {\\n        callback(x, [i], this);\\n        x += step;\\n        i++;\\n      }\\n    } else if (step < 0) {\\n      while (x > end) {\\n        callback(x, [i], this);\\n        x += step;\\n        i++;\\n      }\\n    }\\n  };\\n  /**\\n   * Execute a callback function for each value in the Range, and return the\\n   * results as an array\\n   * @memberof Range\\n   * @param {function} callback   The callback method is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Matrix being traversed.\\n   * @returns {Array} array\\n   */\\n\\n\\n  Range.prototype.map = function (callback) {\\n    var array = [];\\n    this.forEach(function (value, index, obj) {\\n      array[index[0]] = callback(value, index, obj);\\n    });\\n    return array;\\n  };\\n  /**\\n   * Create an Array with a copy of the Ranges data\\n   * @memberof Range\\n   * @returns {Array} array\\n   */\\n\\n\\n  Range.prototype.toArray = function () {\\n    var array = [];\\n    this.forEach(function (value, index) {\\n      array[index[0]] = value;\\n    });\\n    return array;\\n  };\\n  /**\\n   * Get the primitive value of the Range, a one dimensional array\\n   * @memberof Range\\n   * @returns {Array} array\\n   */\\n\\n\\n  Range.prototype.valueOf = function () {\\n    // TODO: implement a caching mechanism for range.valueOf()\\n    return this.toArray();\\n  };\\n  /**\\n   * Get a string representation of the range, with optional formatting options.\\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\\n   * @memberof Range\\n   * @param {Object | number | function} [options]  Formatting options. See\\n   *                                                lib/utils/number:format for a\\n   *                                                description of the available\\n   *                                                options.\\n   * @returns {string} str\\n   */\\n\\n\\n  Range.prototype.format = function (options) {\\n    var str = (0, _number.format)(this.start, options);\\n\\n    if (this.step !== 1) {\\n      str += ':' + (0, _number.format)(this.step, options);\\n    }\\n\\n    str += ':' + (0, _number.format)(this.end, options);\\n    return str;\\n  };\\n  /**\\n   * Get a string representation of the range.\\n   * @memberof Range\\n   * @returns {string}\\n   */\\n\\n\\n  Range.prototype.toString = function () {\\n    return this.format();\\n  };\\n  /**\\n   * Get a JSON representation of the range\\n   * @memberof Range\\n   * @returns {Object} Returns a JSON object structured as:\\n   *                   `{\\\"mathjs\\\": \\\"Range\\\", \\\"start\\\": 2, \\\"end\\\": 4, \\\"step\\\": 1}`\\n   */\\n\\n\\n  Range.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'Range',\\n      start: this.start,\\n      end: this.end,\\n      step: this.step\\n    };\\n  };\\n  /**\\n   * Instantiate a Range from a JSON object\\n   * @memberof Range\\n   * @param {Object} json A JSON object structured as:\\n   *                      `{\\\"mathjs\\\": \\\"Range\\\", \\\"start\\\": 2, \\\"end\\\": 4, \\\"step\\\": 1}`\\n   * @return {Range}\\n   */\\n\\n\\n  Range.fromJSON = function (json) {\\n    return new Range(json.start, json.end, json.step);\\n  };\\n\\n  return Range;\\n}, {\\n  isClass: true\\n});\\nexports.createRangeClass = createRangeClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createRangeClass\",\"_is\",\"_number\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"Range\",\"start\",\"end\",\"step\",\"SyntaxError\",\"hasStart\",\"undefined\",\"hasEnd\",\"hasStep\",\"isBigNumber\",\"toNumber\",\"TypeError\",\"parseFloat\",\"prototype\",\"type\",\"isRange\",\"parse\",\"Range.parse\",\"str\",\"nums\",\"split\",\"args\",\"map\",\"arg\",\"some\",\"invalid\",\"num\",\"isNaN\",\"length\",\"clone\",\"Range.prototype.clone\",\"size\",\"Range.prototype.size\",\"len\",\"diff\",\"sign\",\"Math\",\"ceil\",\"min\",\"Range.prototype.min\",\"max\",\"Range.prototype.max\",\"forEach\",\"Range.prototype.forEach\",\"callback\",\"x\",\"i\",\"Range.prototype.map\",\"array\",\"index\",\"obj\",\"toArray\",\"Range.prototype.toArray\",\"valueOf\",\"Range.prototype.valueOf\",\"format\",\"Range.prototype.format\",\"options\",\"toString\",\"Range.prototype.toString\",\"toJSON\",\"Range.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"Range.fromJSON\",\"json\",\"isClass\"]\n}\n"]