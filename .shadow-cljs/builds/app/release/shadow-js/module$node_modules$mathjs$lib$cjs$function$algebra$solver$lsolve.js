["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/solver/lsolve.js"],"~:js","shadow$provide[173]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createLsolve=void 0;c=b(25);var q=b(172);b=(0,c.factory)(\"lsolve\",\"typed matrix divideScalar multiplyScalar subtract equalScalar DenseMatrix\".split(\" \"),function(f){function u(r,v){v=n(r,v,!0);v=v._data;var C=r._size[0],z=r._size[1],w=[];r=r._data;for(var B=0;B<z;B++){var x=v[B][0]||0;if(l(x,0))x=0;else{var D=r[B][B];if(l(D,0))throw Error(\"Linear system cannot be solved since matrix is singular\");x=p(x,D);for(D=\nB+1;D<C;D++)v[D]=[d(v[D][0]||0,g(x,r[D][B]))]}w[B]=[x]}return new h({data:w,size:[C,1]})}var k=f.typed,t=f.matrix,p=f.divideScalar,g=f.multiplyScalar,d=f.subtract,l=f.equalScalar,h=f.DenseMatrix,n=(0,q.createSolveValidation)({DenseMatrix:h});return k(\"lsolve\",{\"SparseMatrix, Array | Matrix\":function(r,v){v=n(r,v,!0);v=v._data;var C=r._size[0],z=r._size[1],w=r._values,B=r._index;r=r._ptr;for(var x=[],D=0;D<z;D++){var F=v[D][0]||0;if(l(F,0))x[D]=[0];else{for(var E=0,G=[],I=[],L=r[D+1],M=r[D];M<L;M++){var S=\nB[M];S===D?E=w[M]:S>D&&(G.push(w[M]),I.push(S))}if(l(E,0))throw Error(\"Linear system cannot be solved since matrix is singular\");F=p(F,E);E=0;for(L=I.length;E<L;E++)M=I[E],v[M]=[d(v[M][0]||0,g(F,G[E]))];x[D]=[F]}}return new h({data:x,size:[C,1]})},\"DenseMatrix, Array | Matrix\":function(r,v){return u(r,v)},\"Array, Array | Matrix\":function(r,v){r=t(r);return u(r,v).valueOf()}})});a.createLsolve=b}","~:source","shadow$provide[173] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLsolve = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createLsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lsolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var r = _denseForwardSubstitution(m, b);\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      var xj = void 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = mdata[j][j];\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // degenerate row, we can choose any value\n        xj = 0;\n      }\n\n      x[j] = [xj];\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // matrix values & indices (column j)\n\n        var jValues = [];\n        var jIndices = []; // first and last index in the column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j]\n\n        for (var k = firstIndex; k < lastIndex; k++) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        var xj = divideScalar(bj, vjj);\n\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\n        }\n\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});\nexports.createLsolve = createLsolve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["DenseMatrix","createLsolve","__esModule","value","size","data"]],"~:compiled-at",1619135723901,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$lsolve.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,YAAR,CAAuB,IAAK,EAExBC,EAAAA,CAAWP,CAAA,CAAQ,EAAR,CAEf,KAAIQ,EAAmBR,CAAA,CAAQ,GAAR,CAInBM,EAAAA,CAA8B,CAAC,CAAA,CAAGC,CAASE,CAAAA,OAAb,EAFvBC,QAEuB,CADfC,2EAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CACe,CAA0C,QAAS,CAACC,CAAD,CAAO,CAoD1FC,QAASA,EAAyB,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAEvCA,CAAA,CAAIC,CAAA,CAAgBF,CAAhB,CAAmBC,CAAnB,CAAsB,CAAA,CAAtB,CACAE,EAAAA,CAAQF,CAAEG,CAAAA,KACd,KAAIC,EAAOL,CAAEM,CAAAA,KAAF,CAAQ,CAAR,CAAX,CACIC,EAAUP,CAAEM,CAAAA,KAAF,CAAQ,CAAR,CADd,CAGIE,EAAI,EACJC,EAAAA,CAAQT,CAAEI,CAAAA,KAEd,KAAK,IAAIM,EAAI,CAAb,CAAgBA,CAAhB,CAAoBH,CAApB,CAA6BG,CAAA,EAA7B,CAAkC,CAChC,IAAIC,EAAKR,CAAA,CAAMO,CAAN,CAAA,CAAS,CAAT,CAALC,EAAoB,CAGxB,IAAKC,CAAA,CAAYD,CAAZ,CAAgB,CAAhB,CAAL,CAeEE,CAAA,CAAK,CAfP,KAAyB,CAEvB,IAAIC,EAAML,CAAA,CAAMC,CAAN,CAAA,CAASA,CAAT,CAEV,IAAIE,CAAA,CAAYE,CAAZ,CAAiB,CAAjB,CAAJ,CACE,KAAUC,MAAJ,CAAU,yDAAV,CAAN,CAGFF,CAAA,CAAKG,CAAA,CAAaL,CAAb,CAAiBG,CAAjB,CAEL,KAASG,CAAT;AAAaP,CAAb,CAAiB,CAAjB,CAAoBO,CAApB,CAAwBZ,CAAxB,CAA8BY,CAAA,EAA9B,CACEd,CAAA,CAAMc,CAAN,CAAA,CAAW,CAACC,CAAA,CAASf,CAAA,CAAMc,CAAN,CAAA,CAAS,CAAT,CAAT,EAAwB,CAAxB,CAA2BE,CAAA,CAAeN,CAAf,CAAmBJ,CAAA,CAAMQ,CAAN,CAAA,CAASP,CAAT,CAAnB,CAA3B,CAAD,CAXU,CAkBzBF,CAAA,CAAEE,CAAF,CAAA,CAAO,CAACG,CAAD,CAtByB,CAyBlC,MAAO,KAAIO,CAAJ,CAAgB,CACrBC,KAAMb,CADe,CAErBc,KAAM,CAACjB,CAAD,CAAO,CAAP,CAFe,CAAhB,CAnCgC,CApDiD,IACtFkB,EAAQzB,CAAKyB,CAAAA,KADyE,CAEtFC,EAAS1B,CAAK0B,CAAAA,MAFwE,CAGtFR,EAAelB,CAAKkB,CAAAA,YAHkE,CAItFG,EAAiBrB,CAAKqB,CAAAA,cAJgE,CAKtFD,EAAWpB,CAAKoB,CAAAA,QALsE,CAMtFN,EAAcd,CAAKc,CAAAA,WANmE,CAOtFQ,EAActB,CAAKsB,CAAAA,WAPmE,CAQtFlB,EAAkB,CAAC,CAAA,CAAGR,CAAiB+B,CAAAA,qBAArB,EAA4C,CAChEL,YAAaA,CADmD,CAA5C,CA4BtB,OAAOG,EAAA,CAtCE3B,QAsCF,CAAY,CACjB,+BAAgC8B,QAAgC,CAAC1B,CAAD,CAAIC,CAAJ,CAAO,CA0DvEA,CAAA,CAAIC,CAAA,CAzDgCF,CAyDhC,CAzDmCC,CAyDnC,CAAsB,CAAA,CAAtB,CACAE,EAAAA,CAAQF,CAAEG,CAAAA,KACd,KAAIC,EA3DgCL,CA2DvBM,CAAAA,KAAF,CAAQ,CAAR,CAAX,CACIC,EA5DgCP,CA4DpBM,CAAAA,KAAF,CAAQ,CAAR,CADd,CAEIqB,EA7DgC3B,CA6DrB4B,CAAAA,OAFf,CAGIC,EA9DgC7B,CA8DtB8B,CAAAA,MACVC,EAAAA,CA/DgC/B,CA+DxBgC,CAAAA,IAIZ,KAFA,IAAIxB,EAAI,EAAR,CAESE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBH,CAApB,CAA6BG,CAAA,EAA7B,CAAkC,CAChC,IAAIC,EAAKR,CAAA,CAAMO,CAAN,CAAA,CAAS,CAAT,CAALC,EAAoB,CAExB,IAAKC,CAAA,CAAYD,CAAZ,CAAgB,CAAhB,CAAL,CAqCEH,CAAA,CAAEE,CAAF,CAAA,CAAO,CAAC,CAAD,CArCT,KAAyB,CAUvB,IARA,IAAII,EAAM,CAAV,CAEImB,EAAU,EAFd,CAGIC,EAAW,EAHf,CAMIC,EAAYJ,CAAA,CAAIrB,CAAJ,CAAQ,CAAR,CANhB,CAQS0B,EAHQL,CAAAM,CAAI3B,CAAJ2B,CAGjB,CAAyBD,CAAzB,CAA6BD,CAA7B,CAAwCC,CAAA,EAAxC,CAA6C,CAC3C,IAAInB;AAAIY,CAAA,CAAMO,CAAN,CAEJnB,EAAJ,GAAUP,CAAV,CACEI,CADF,CACQa,CAAA,CAAOS,CAAP,CADR,CAEWnB,CAFX,CAEeP,CAFf,GAIEuB,CAAQK,CAAAA,IAAR,CAAaX,CAAA,CAAOS,CAAP,CAAb,CACA,CAAAF,CAASI,CAAAA,IAAT,CAAcrB,CAAd,CALF,CAH2C,CAa7C,GAAIL,CAAA,CAAYE,CAAZ,CAAiB,CAAjB,CAAJ,CACE,KAAUC,MAAJ,CAAU,yDAAV,CAAN,CAGEF,CAAAA,CAAKG,CAAA,CAAaL,CAAb,CAAiBG,CAAjB,CAEAyB,EAAAA,CAAK,CAAd,KAAiBC,CAAjB,CAAqBN,CAASO,CAAAA,MAA9B,CAAsCF,CAAtC,CAA2CC,CAA3C,CAA8CD,CAAA,EAA9C,CACMG,CACJ,CADSR,CAAA,CAASK,CAAT,CACT,CAAApC,CAAA,CAAMuC,CAAN,CAAA,CAAY,CAACxB,CAAA,CAASf,CAAA,CAAMuC,CAAN,CAAA,CAAU,CAAV,CAAT,EAAyB,CAAzB,CAA4BvB,CAAA,CAAeN,CAAf,CAAmBoB,CAAA,CAAQM,CAAR,CAAnB,CAA5B,CAAD,CAGd/B,EAAA,CAAEE,CAAF,CAAA,CAAO,CAACG,CAAD,CAlCgB,CAHO,CAnEhC,MA+GK,KAAIO,CAAJ,CAAgB,CACrBC,KAAMb,CADe,CAErBc,KAAM,CAACjB,CAAD,CAAO,CAAP,CAFe,CAAhB,CAhHgE,CADtD,CAIjB,8BAA+BsC,QAA+B,CAAC3C,CAAD,CAAIC,CAAJ,CAAO,CACnE,MAAOF,EAAA,CAA0BC,CAA1B,CAA6BC,CAA7B,CAD4D,CAJpD,CAOjB,wBAAyB2C,QAAyB,CAACC,CAAD,CAAI5C,CAAJ,CAAO,CACnDD,CAAAA,CAAIwB,CAAA,CAAOqB,CAAP,CAIR,OAFQ9C,EAAA+C,CAA0B9C,CAA1B8C,CAA6B7C,CAA7B6C,CAECC,CAAAA,OAAF,EALgD,CAPxC,CAAZ,CApCmF,CAA1D,CA2JlC3D,EAAQI,CAAAA,YAAR,CAAuBA,CAzKuC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/solver/lsolve.js\"],\n\"sourcesContent\":[\"shadow$provide[173] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createLsolve = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _solveValidation = require(\\\"./utils/solveValidation.js\\\");\\n\\nvar name = 'lsolve';\\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\\nvar createLsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divideScalar = _ref.divideScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      subtract = _ref.subtract,\\n      equalScalar = _ref.equalScalar,\\n      DenseMatrix = _ref.DenseMatrix;\\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\\n    DenseMatrix: DenseMatrix\\n  });\\n  /**\\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\\n   *\\n   * `L * x = b`\\n   *\\n   * Syntax:\\n   *\\n   *    math.lsolve(L, b)\\n   *\\n   * Examples:\\n   *\\n   *    const a = [[-2, 3], [2, 1]]\\n   *    const b = [11, 9]\\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\\n   *\\n   * See also:\\n   *\\n   *    lsolveAll, lup, slu, usolve, lusolve\\n   *\\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\\n   * @param {Matrix, Array} b       A column vector with the b values\\n   *\\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\\n   */\\n\\n  return typed(name, {\\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\\n      return _sparseForwardSubstitution(m, b);\\n    },\\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\\n      return _denseForwardSubstitution(m, b);\\n    },\\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\\n      var m = matrix(a);\\n\\n      var r = _denseForwardSubstitution(m, b);\\n\\n      return r.valueOf();\\n    }\\n  });\\n\\n  function _denseForwardSubstitution(m, b) {\\n    // validate matrix and vector, return copy of column vector b\\n    b = solveValidation(m, b, true);\\n    var bdata = b._data;\\n    var rows = m._size[0];\\n    var columns = m._size[1]; // result\\n\\n    var x = [];\\n    var mdata = m._data; // loop columns\\n\\n    for (var j = 0; j < columns; j++) {\\n      var bj = bdata[j][0] || 0;\\n      var xj = void 0;\\n\\n      if (!equalScalar(bj, 0)) {\\n        // non-degenerate row, find solution\\n        var vjj = mdata[j][j];\\n\\n        if (equalScalar(vjj, 0)) {\\n          throw new Error('Linear system cannot be solved since matrix is singular');\\n        }\\n\\n        xj = divideScalar(bj, vjj); // loop rows\\n\\n        for (var i = j + 1; i < rows; i++) {\\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\\n        }\\n      } else {\\n        // degenerate row, we can choose any value\\n        xj = 0;\\n      }\\n\\n      x[j] = [xj];\\n    }\\n\\n    return new DenseMatrix({\\n      data: x,\\n      size: [rows, 1]\\n    });\\n  }\\n\\n  function _sparseForwardSubstitution(m, b) {\\n    // validate matrix and vector, return copy of column vector b\\n    b = solveValidation(m, b, true);\\n    var bdata = b._data;\\n    var rows = m._size[0];\\n    var columns = m._size[1];\\n    var values = m._values;\\n    var index = m._index;\\n    var ptr = m._ptr; // result\\n\\n    var x = []; // loop columns\\n\\n    for (var j = 0; j < columns; j++) {\\n      var bj = bdata[j][0] || 0;\\n\\n      if (!equalScalar(bj, 0)) {\\n        // non-degenerate row, find solution\\n        var vjj = 0; // matrix values & indices (column j)\\n\\n        var jValues = [];\\n        var jIndices = []; // first and last index in the column\\n\\n        var firstIndex = ptr[j];\\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j]\\n\\n        for (var k = firstIndex; k < lastIndex; k++) {\\n          var i = index[k]; // check row (rows are not sorted!)\\n\\n          if (i === j) {\\n            vjj = values[k];\\n          } else if (i > j) {\\n            // store lower triangular\\n            jValues.push(values[k]);\\n            jIndices.push(i);\\n          }\\n        } // at this point we must have a value in vjj\\n\\n\\n        if (equalScalar(vjj, 0)) {\\n          throw new Error('Linear system cannot be solved since matrix is singular');\\n        }\\n\\n        var xj = divideScalar(bj, vjj);\\n\\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\\n          var _i = jIndices[_k];\\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\\n        }\\n\\n        x[j] = [xj];\\n      } else {\\n        // degenerate row, we can choose any value\\n        x[j] = [0];\\n      }\\n    }\\n\\n    return new DenseMatrix({\\n      data: x,\\n      size: [rows, 1]\\n    });\\n  }\\n});\\nexports.createLsolve = createLsolve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createLsolve\",\"_factory\",\"_solveValidation\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_denseForwardSubstitution\",\"m\",\"b\",\"solveValidation\",\"bdata\",\"_data\",\"rows\",\"_size\",\"columns\",\"x\",\"mdata\",\"j\",\"bj\",\"equalScalar\",\"xj\",\"vjj\",\"Error\",\"divideScalar\",\"i\",\"subtract\",\"multiplyScalar\",\"DenseMatrix\",\"data\",\"size\",\"typed\",\"matrix\",\"createSolveValidation\",\"SparseMatrixArrayMatrix\",\"values\",\"_values\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"jValues\",\"jIndices\",\"lastIndex\",\"k\",\"firstIndex\",\"push\",\"_k\",\"l\",\"length\",\"_i\",\"DenseMatrixArrayMatrix\",\"ArrayArrayMatrix\",\"a\",\"r\",\"valueOf\"]\n}\n"]