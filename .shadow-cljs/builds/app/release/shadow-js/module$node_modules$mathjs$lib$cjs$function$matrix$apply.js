["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/apply.js"],"~:js","shadow$provide[73]=function(c,b,y,a){function q(t,p,g){if(0>=p){if(Array.isArray(t[0])){var d=t.length;var l=t[0].length;var h,n,r=[];for(n=0;n<l;n++){var v=[];for(h=0;h<d;h++)v.push(t[h][n]);r.push(v)}l=[];for(d=0;d<r.length;d++)l[d]=q(r[d],p-1,g);return l}return g(t)}l=[];for(d=0;d<t.length;d++)l[d]=q(t[d],p-1,g);return l}Object.defineProperty(a,\"__esModule\",{value:!0});a.createApply=void 0;c=b(25);var f=b(24),u=b(14),k=b(23);b=(0,c.factory)(\"apply\",[\"typed\",\"isInteger\"],function(t){var p=t.typed,\ng=t.isInteger;return p(\"apply\",{\"Array | Matrix, number | BigNumber, function\":function(d,l,h){if(!g(l))throw new TypeError(\"Integer number expected for dimension\");var n=Array.isArray(d)?(0,f.arraySize)(d):d.size();if(0>l||l>=n.length)throw new k.IndexError(l,n.length);return(0,u.isMatrix)(d)?d.create(q(d.valueOf(),l,h)):q(d,l,h)}})});a.createApply=b}","~:source","shadow$provide[73] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createApply = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _IndexError = require(\"../../error/IndexError.js\");\n\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nvar createApply = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isInteger = _ref.isInteger;\n\n  /**\n   * Apply a function that maps an array to a scalar\n   * along a given axis of a matrix or array.\n   * Returns a new matrix or array with one less dimension than the input.\n   *\n   * Syntax:\n   *\n   *     math.apply(A, dim, callback)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [3, 4]]\n   *    const sum = math.sum\n   *\n   *    math.apply(A, 0, sum)             // returns [4, 6]\n   *    math.apply(A, 1, sum)             // returns [3, 7]\n   *\n   * See also:\n   *\n   *    map, filter, forEach\n   *\n   * @param {Array | Matrix} array   The input Matrix\n   * @param {number} dim             The dimension along which the callback is applied\n   * @param {Function} callback      The callback function that is applied. This Function\n   *                                 should take an array or 1-d matrix as an input and\n   *                                 return a number.\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\n   */\n  return typed(name, {\n    'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n\n      var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\n\n      if (dim < 0 || dim >= size.length) {\n        throw new _IndexError.IndexError(dim, size.length);\n      }\n\n      if ((0, _is.isMatrix)(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback));\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n});\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nexports.createApply = createApply;\n\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$error$IndexError","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createApply","__esModule","value"]],"~:compiled-at",1619135723768,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$apply.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/apply.js\"],\n\"sourcesContent\":[\"shadow$provide[73] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createApply = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _IndexError = require(\\\"../../error/IndexError.js\\\");\\n\\nvar name = 'apply';\\nvar dependencies = ['typed', 'isInteger'];\\nvar createApply = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      isInteger = _ref.isInteger;\\n\\n  /**\\n   * Apply a function that maps an array to a scalar\\n   * along a given axis of a matrix or array.\\n   * Returns a new matrix or array with one less dimension than the input.\\n   *\\n   * Syntax:\\n   *\\n   *     math.apply(A, dim, callback)\\n   *\\n   * Where:\\n   *\\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\\n   *\\n   * Examples:\\n   *\\n   *    const A = [[1, 2], [3, 4]]\\n   *    const sum = math.sum\\n   *\\n   *    math.apply(A, 0, sum)             // returns [4, 6]\\n   *    math.apply(A, 1, sum)             // returns [3, 7]\\n   *\\n   * See also:\\n   *\\n   *    map, filter, forEach\\n   *\\n   * @param {Array | Matrix} array   The input Matrix\\n   * @param {number} dim             The dimension along which the callback is applied\\n   * @param {Function} callback      The callback function that is applied. This Function\\n   *                                 should take an array or 1-d matrix as an input and\\n   *                                 return a number.\\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\\n   */\\n  return typed(name, {\\n    'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {\\n      if (!isInteger(dim)) {\\n        throw new TypeError('Integer number expected for dimension');\\n      }\\n\\n      var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\\n\\n      if (dim < 0 || dim >= size.length) {\\n        throw new _IndexError.IndexError(dim, size.length);\\n      }\\n\\n      if ((0, _is.isMatrix)(mat)) {\\n        return mat.create(_apply(mat.valueOf(), dim, callback));\\n      } else {\\n        return _apply(mat, dim, callback);\\n      }\\n    }\\n  });\\n});\\n/**\\n * Recursively reduce a matrix\\n * @param {Array} mat\\n * @param {number} dim\\n * @param {Function} callback\\n * @returns {Array} ret\\n * @private\\n */\\n\\nexports.createApply = createApply;\\n\\nfunction _apply(mat, dim, callback) {\\n  var i, ret, tran;\\n\\n  if (dim <= 0) {\\n    if (!Array.isArray(mat[0])) {\\n      return callback(mat);\\n    } else {\\n      tran = _switch(mat);\\n      ret = [];\\n\\n      for (i = 0; i < tran.length; i++) {\\n        ret[i] = _apply(tran[i], dim - 1, callback);\\n      }\\n\\n      return ret;\\n    }\\n  } else {\\n    ret = [];\\n\\n    for (i = 0; i < mat.length; i++) {\\n      ret[i] = _apply(mat[i], dim - 1, callback);\\n    }\\n\\n    return ret;\\n  }\\n}\\n/**\\n * Transpose a matrix\\n * @param {Array} mat\\n * @returns {Array} ret\\n * @private\\n */\\n\\n\\nfunction _switch(mat) {\\n  var I = mat.length;\\n  var J = mat[0].length;\\n  var i, j;\\n  var ret = [];\\n\\n  for (j = 0; j < J; j++) {\\n    var tmp = [];\\n\\n    for (i = 0; i < I; i++) {\\n      tmp.push(mat[i][j]);\\n    }\\n\\n    ret.push(tmp);\\n  }\\n\\n  return ret;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_apply\",\"mat\",\"dim\",\"callback\",\"Array\",\"isArray\",\"I\",\"length\",\"J\",\"i\",\"j\",\"ret\",\"tmp\",\"push\",\"Object\",\"defineProperty\",\"value\",\"createApply\",\"_factory\",\"_array\",\"_is\",\"_IndexError\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"isInteger\",\"ArrayMatrixNumberBigNumberFunction\",\"TypeError\",\"size\",\"arraySize\",\"IndexError\",\"isMatrix\",\"create\",\"valueOf\"]\n}\n"]