["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/log1p.js"],"~:js","shadow$provide[168]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createLog1p=void 0;c=b(25);var q=b(38),f=b(19);b=(0,c.factory)(\"log1p\",[\"typed\",\"config\",\"divideScalar\",\"log\",\"Complex\"],function(u){function k(h){var n=h.re+1;return new l(Math.log(Math.sqrt(n*n+h.im*h.im)),Math.atan2(h.im,n))}var t=u.typed,p=u.config,g=u.divideScalar,d=u.log,l=u.Complex;return t(\"log1p\",{number:function(h){return-1<=h||p.predictable?(0,f.log1p)(h):k(new l(h,0))},Complex:k,BigNumber:function(h){var n=\nh.plus(1);return!n.isNegative()||p.predictable?n.ln():k(new l(h.toNumber(),0))},\"Array | Matrix\":function(h){return(0,q.deepMap)(h,this)},\"any, any\":function(h,n){return g(this(h),d(n))}})});a.createLog1p=b}","~:source","shadow$provide[168] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLog1p = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _collection = require(\"../../utils/collection.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar name = 'log1p';\nvar dependencies = ['typed', 'config', 'divideScalar', 'log', 'Complex'];\nvar createLog1p = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      divideScalar = _ref.divideScalar,\n      log = _ref.log,\n      Complex = _ref.Complex;\n\n  /**\n   * Calculate the logarithm of a `value+1`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log1p(x)\n   *    math.log1p(x, base)\n   *\n   * Examples:\n   *\n   *    math.log1p(2.5)                 // returns 1.252762968495368\n   *    math.exp(math.log1p(1.4))       // returns 2.4\n   *\n   *    math.pow(10, 4)                 // returns 10000\n   *    math.log1p(9999, 10)            // returns 4\n   *    math.log1p(9999) / math.log(10) // returns 4\n   *\n   * See also:\n   *\n   *    exp, log, log2, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm of `x+1`.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x+1` is calculated.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the logarithm of `x+1`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= -1 || config.predictable) {\n        return (0, _number.log1p)(x);\n      } else {\n        // negative value -> complex value computation\n        return _log1pComplex(new Complex(x, 0));\n      }\n    },\n    Complex: _log1pComplex,\n    BigNumber: function BigNumber(x) {\n      var y = x.plus(1);\n\n      if (!y.isNegative() || config.predictable) {\n        return y.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log1pComplex(new Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return (0, _collection.deepMap)(x, this);\n    },\n    'any, any': function anyAny(x, base) {\n      // calculate logarithm for a specified base, log1p(x, base)\n      return divideScalar(this(x), log(base));\n    }\n  });\n  /**\n   * Calculate the natural logarithm of a complex number + 1\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n\n  function _log1pComplex(x) {\n    var xRe1p = x.re + 1;\n    return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));\n  }\n});\nexports.createLog1p = createLog1p;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$collection","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["Complex","__esModule","value","number","createLog1p","BigNumber"]],"~:compiled-at",1619135723899,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$log1p.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,WAAR,CAAsB,IAAK,EAEvBC,EAAAA,CAAWP,CAAA,CAAQ,EAAR,CAEf,KAAIQ,EAAcR,CAAA,CAAQ,EAAR,CAAlB,CAEIS,EAAUT,CAAA,CAAQ,EAAR,CAIVM,EAAAA,CAA6B,CAAC,CAAA,CAAGC,CAASG,CAAAA,OAAb,EAFtBC,OAEsB,CADdC,CAAC,OAADA,CAAU,QAAVA,CAAoB,cAApBA,CAAoC,KAApCA,CAA2C,SAA3CA,CACc,CAA0C,QAAS,CAACC,CAAD,CAAO,CAyEzFC,QAASA,EAAa,CAACC,CAAD,CAAI,CACxB,IAAIC,EAAQD,CAAEE,CAAAA,EAAVD,CAAe,CACnB,OAAO,KAAIE,CAAJ,CAAYC,IAAKC,CAAAA,GAAL,CAASD,IAAKE,CAAAA,IAAL,CAAUL,CAAV,CAAkBA,CAAlB,CAA0BD,CAAEO,CAAAA,EAA5B,CAAiCP,CAAEO,CAAAA,EAAnC,CAAT,CAAZ,CAA8DH,IAAKI,CAAAA,KAAL,CAAWR,CAAEO,CAAAA,EAAb,CAAiBN,CAAjB,CAA9D,CAFiB,CAzE+D,IACrFQ,EAAQX,CAAKW,CAAAA,KADwE,CAErFC,EAASZ,CAAKY,CAAAA,MAFuE,CAGrFC,EAAeb,CAAKa,CAAAA,YAHiE,CAIrFN,EAAMP,CAAKO,CAAAA,GAJ0E,CAKrFF,EAAUL,CAAKK,CAAAA,OAiCnB,OAAOM,EAAA,CAxCEb,OAwCF,CAAY,CACjBgB,OAAQA,QAAe,CAACZ,CAAD,CAAI,CACzB,MAAS,EAAT,EAAIA,CAAJ,EAAeU,CAAOG,CAAAA,WAAtB,CACS,CAAC,CAAA,CAAGnB,CAAQoB,CAAAA,KAAZ,EAAmBd,CAAnB,CADT,CAISD,CAAA,CAAc,IAAII,CAAJ,CAAYH,CAAZ,CAAe,CAAf,CAAd,CALgB,CADV,CASjBG,QAASJ,CATQ,CAUjBgB,UAAWA,QAAkB,CAACf,CAAD,CAAI,CAC/B,IAAIgB;AAAIhB,CAAEiB,CAAAA,IAAF,CAAO,CAAP,CAER,OAAI,CAACD,CAAEE,CAAAA,UAAF,EAAL,EAAuBR,CAAOG,CAAAA,WAA9B,CACSG,CAAEG,CAAAA,EAAF,EADT,CAISpB,CAAA,CAAc,IAAII,CAAJ,CAAYH,CAAEoB,CAAAA,QAAF,EAAZ,CAA0B,CAA1B,CAAd,CAPsB,CAVhB,CAoBjB,iBAAkBC,QAAoB,CAACrB,CAAD,CAAI,CACxC,MAAO,CAAC,CAAA,CAAGP,CAAY6B,CAAAA,OAAhB,EAAyBtB,CAAzB,CAA4B,IAA5B,CADiC,CApBzB,CAuBjB,WAAYuB,QAAe,CAACvB,CAAD,CAAIwB,CAAJ,CAAU,CAEnC,MAAOb,EAAA,CAAa,IAAA,CAAKX,CAAL,CAAb,CAAsBK,CAAA,CAAImB,CAAJ,CAAtB,CAF4B,CAvBpB,CAAZ,CAtCkF,CAA1D,CA8EjCrC,EAAQI,CAAAA,WAAR,CAAsBA,CA9FwC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/log1p.js\"],\n\"sourcesContent\":[\"shadow$provide[168] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createLog1p = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _collection = require(\\\"../../utils/collection.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar name = 'log1p';\\nvar dependencies = ['typed', 'config', 'divideScalar', 'log', 'Complex'];\\nvar createLog1p = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      config = _ref.config,\\n      divideScalar = _ref.divideScalar,\\n      log = _ref.log,\\n      Complex = _ref.Complex;\\n\\n  /**\\n   * Calculate the logarithm of a `value+1`.\\n   *\\n   * For matrices, the function is evaluated element wise.\\n   *\\n   * Syntax:\\n   *\\n   *    math.log1p(x)\\n   *    math.log1p(x, base)\\n   *\\n   * Examples:\\n   *\\n   *    math.log1p(2.5)                 // returns 1.252762968495368\\n   *    math.exp(math.log1p(1.4))       // returns 2.4\\n   *\\n   *    math.pow(10, 4)                 // returns 10000\\n   *    math.log1p(9999, 10)            // returns 4\\n   *    math.log1p(9999) / math.log(10) // returns 4\\n   *\\n   * See also:\\n   *\\n   *    exp, log, log2, log10\\n   *\\n   * @param {number | BigNumber | Complex | Array | Matrix} x\\n   *            Value for which to calculate the logarithm of `x+1`.\\n   * @param {number | BigNumber | Complex} [base=e]\\n   *            Optional base for the logarithm. If not provided, the natural\\n   *            logarithm of `x+1` is calculated.\\n   * @return {number | BigNumber | Complex | Array | Matrix}\\n   *            Returns the logarithm of `x+1`\\n   */\\n  return typed(name, {\\n    number: function number(x) {\\n      if (x >= -1 || config.predictable) {\\n        return (0, _number.log1p)(x);\\n      } else {\\n        // negative value -> complex value computation\\n        return _log1pComplex(new Complex(x, 0));\\n      }\\n    },\\n    Complex: _log1pComplex,\\n    BigNumber: function BigNumber(x) {\\n      var y = x.plus(1);\\n\\n      if (!y.isNegative() || config.predictable) {\\n        return y.ln();\\n      } else {\\n        // downgrade to number, return Complex valued result\\n        return _log1pComplex(new Complex(x.toNumber(), 0));\\n      }\\n    },\\n    'Array | Matrix': function ArrayMatrix(x) {\\n      return (0, _collection.deepMap)(x, this);\\n    },\\n    'any, any': function anyAny(x, base) {\\n      // calculate logarithm for a specified base, log1p(x, base)\\n      return divideScalar(this(x), log(base));\\n    }\\n  });\\n  /**\\n   * Calculate the natural logarithm of a complex number + 1\\n   * @param {Complex} x\\n   * @returns {Complex}\\n   * @private\\n   */\\n\\n  function _log1pComplex(x) {\\n    var xRe1p = x.re + 1;\\n    return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));\\n  }\\n});\\nexports.createLog1p = createLog1p;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createLog1p\",\"_factory\",\"_collection\",\"_number\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_log1pComplex\",\"x\",\"xRe1p\",\"re\",\"Complex\",\"Math\",\"log\",\"sqrt\",\"im\",\"atan2\",\"typed\",\"config\",\"divideScalar\",\"number\",\"predictable\",\"log1p\",\"BigNumber\",\"y\",\"plus\",\"isNegative\",\"ln\",\"toNumber\",\"ArrayMatrix\",\"deepMap\",\"anyAny\",\"base\"]\n}\n"]