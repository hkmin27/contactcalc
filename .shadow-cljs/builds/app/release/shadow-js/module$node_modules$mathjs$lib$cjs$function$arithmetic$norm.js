["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/norm.js"],"~:js","shadow$provide[244]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createNorm=void 0;c=b(25);c=(0,c.factory)(\"norm\",\"typed abs add pow conj sqrt multiply equalScalar larger smaller matrix ctranspose eigs\".split(\" \"),function(q){function f(I){var L=0;I.forEach(function(M){M=n(M);x(M,L)&&(L=M)},!0);return L}function u(I){var L;I.forEach(function(M){M=n(M);if(!L||D(M,L))L=M},!0);return L||0}function k(I,L){if(L===Number.POSITIVE_INFINITY||\"inf\"===L)return f(I);if(L===Number.NEGATIVE_INFINITY||\n\"-inf\"===L)return u(I);if(\"fro\"===L)return l(I,2);if(\"number\"===typeof L&&!isNaN(L)){if(!B(L,0)){var M=0;I.forEach(function(S){M=r(v(n(S),L),M)},!0);return v(M,1/L)}return Number.POSITIVE_INFINITY}throw Error(\"Unsupported parameter value\");}function t(I){var L=0;I.forEach(function(M,S){L=r(L,w(M,C(M)))});return n(z(L))}function p(I){var L=[],M=0;I.forEach(function(S,P){P=P[1];S=r(L[P]||0,n(S));x(S,M)&&(M=S);L[P]=S},!0);return M}function g(I){var L=[],M=0;I.forEach(function(S,P){P=P[0];S=r(L[P]||0,\nn(S));x(S,M)&&(M=S);L[P]=S},!0);return M}function d(I,L){if(1===L)return p(I);if(L===Number.POSITIVE_INFINITY||\"inf\"===L)return g(I);if(\"fro\"===L)return t(I);if(2===L){L=I.size();if(L[0]!==L[1])throw new RangeError(\"Invalid matrix dimensions\");L=E(I);I=w(L,I);I=G(I).values;I=I.get([I.size()[0]-1]);return n(z(I))}throw Error(\"Unsupported parameter value \"+L);}function l(I,L){var M=I.size();if(1===M.length)return k(I,L);if(2===M.length){if(M[0]&&M[1])return d(I,L);throw new RangeError(\"Invalid matrix dimensions\");\n}}var h=q.typed,n=q.abs,r=q.add,v=q.pow,C=q.conj,z=q.sqrt,w=q.multiply,B=q.equalScalar,x=q.larger,D=q.smaller,F=q.matrix,E=q.ctranspose,G=q.eigs;return h(\"norm\",{number:Math.abs,Complex:function(I){return I.abs()},BigNumber:function(I){return I.abs()},\"boolean\":function(I){return Math.abs(I)},Array:function(I){return l(F(I),2)},Matrix:function(I){return l(I,2)},\"number | Complex | BigNumber | boolean, number | BigNumber | string\":function(I){return this(I)},\"Array, number | BigNumber | string\":function(I,\nL){return l(F(I),L)},\"Matrix, number | BigNumber | string\":function(I,L){return l(I,L)}})});a.createNorm=c}","~:source","shadow$provide[244] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNorm = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'norm';\nvar dependencies = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];\nvar createNorm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      pow = _ref.pow,\n      conj = _ref.conj,\n      sqrt = _ref.sqrt,\n      multiply = _ref.multiply,\n      equalScalar = _ref.equalScalar,\n      larger = _ref.larger,\n      smaller = _ref.smaller,\n      matrix = _ref.matrix,\n      ctranspose = _ref.ctranspose,\n      eigs = _ref.eigs;\n\n  /**\n   * Calculate the norm of a number, vector or matrix.\n   *\n   * The second parameter p is optional. If not provided, it defaults to 2.\n   *\n   * Syntax:\n   *\n   *    math.norm(x)\n   *    math.norm(x, p)\n   *\n   * Examples:\n   *\n   *    math.abs(-3.5)                         // returns 3.5\n   *    math.norm(-3.5)                        // returns 3.5\n   *\n   *    math.norm(math.complex(3, -4))         // returns 5\n   *\n   *    math.norm([1, 2, -3], Infinity)        // returns 3\n   *    math.norm([1, 2, -3], -Infinity)       // returns 1\n   *\n   *    math.norm([3, 4], 2)                   // returns 5\n   *\n   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6\n   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7\n   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661\n   *\n   * See also:\n   *\n   *    abs, hypot\n   *\n   * @param  {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the norm\n   * @param  {number | BigNumber | string} [p=2]\n   *            Vector space.\n   *            Supported numbers include Infinity and -Infinity.\n   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)\n   * @return {number | BigNumber} the p-norm\n   */\n  return typed(name, {\n    number: Math.abs,\n    Complex: function Complex(x) {\n      return x.abs();\n    },\n    BigNumber: function BigNumber(x) {\n      // norm(x) = abs(x)\n      return x.abs();\n    },\n    \"boolean\": function boolean(x) {\n      // norm(x) = abs(x)\n      return Math.abs(x);\n    },\n    Array: function Array(x) {\n      return _norm(matrix(x), 2);\n    },\n    Matrix: function Matrix(x) {\n      return _norm(x, 2);\n    },\n    'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {\n      // ignore second parameter, TODO: remove the option of second parameter for these types\n      return this(x);\n    },\n    'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {\n      return _norm(matrix(x), p);\n    },\n    'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {\n      return _norm(x, p);\n    }\n  });\n  /**\n   * Calculate the plus infinity norm for a vector\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n  function _vectorNormPlusInfinity(x) {\n    // norm(x, Infinity) = max(abs(x))\n    var pinf = 0; // skip zeros since abs(0) === 0\n\n    x.forEach(function (value) {\n      var v = abs(value);\n\n      if (larger(v, pinf)) {\n        pinf = v;\n      }\n    }, true);\n    return pinf;\n  }\n  /**\n   * Calculate the minus infinity norm for a vector\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _vectorNormMinusInfinity(x) {\n    // norm(x, -Infinity) = min(abs(x))\n    var ninf; // skip zeros since abs(0) === 0\n\n    x.forEach(function (value) {\n      var v = abs(value);\n\n      if (!ninf || smaller(v, ninf)) {\n        ninf = v;\n      }\n    }, true);\n    return ninf || 0;\n  }\n  /**\n   * Calculate the norm for a vector\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _vectorNorm(x, p) {\n    // check p\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\n      return _vectorNormPlusInfinity(x);\n    }\n\n    if (p === Number.NEGATIVE_INFINITY || p === '-inf') {\n      return _vectorNormMinusInfinity(x);\n    }\n\n    if (p === 'fro') {\n      return _norm(x, 2);\n    }\n\n    if (typeof p === 'number' && !isNaN(p)) {\n      // check p != 0\n      if (!equalScalar(p, 0)) {\n        // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p\n        var n = 0; // skip zeros since abs(0) === 0\n\n        x.forEach(function (value) {\n          n = add(pow(abs(value), p), n);\n        }, true);\n        return pow(n, 1 / p);\n      }\n\n      return Number.POSITIVE_INFINITY;\n    } // invalid parameter value\n\n\n    throw new Error('Unsupported parameter value');\n  }\n  /**\n   * Calculate the Frobenius norm for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _matrixNormFrobenius(x) {\n    // norm(x) = sqrt(sum(diag(x'x)))\n    var fro = 0;\n    x.forEach(function (value, index) {\n      fro = add(fro, multiply(value, conj(value)));\n    });\n    return abs(sqrt(fro));\n  }\n  /**\n   * Calculate the norm L1 for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _matrixNormOne(x) {\n    // norm(x) = the largest column sum\n    var c = []; // result\n\n    var maxc = 0; // skip zeros since abs(0) == 0\n\n    x.forEach(function (value, index) {\n      var j = index[1];\n      var cj = add(c[j] || 0, abs(value));\n\n      if (larger(cj, maxc)) {\n        maxc = cj;\n      }\n\n      c[j] = cj;\n    }, true);\n    return maxc;\n  }\n  /**\n   * Calculate the norm L2 for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _matrixNormTwo(x) {\n    // norm(x) = sqrt( max eigenvalue of A*.A)\n    var sizeX = x.size();\n\n    if (sizeX[0] !== sizeX[1]) {\n      throw new RangeError('Invalid matrix dimensions');\n    }\n\n    var tx = ctranspose(x);\n    var squaredX = multiply(tx, x);\n    var eigenVals = eigs(squaredX).values;\n    var rho = eigenVals.get([eigenVals.size()[0] - 1]);\n    return abs(sqrt(rho));\n  }\n  /**\n   * Calculate the infinity norm for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _matrixNormInfinity(x) {\n    // norm(x) = the largest row sum\n    var r = []; // result\n\n    var maxr = 0; // skip zeros since abs(0) == 0\n\n    x.forEach(function (value, index) {\n      var i = index[0];\n      var ri = add(r[i] || 0, abs(value));\n\n      if (larger(ri, maxr)) {\n        maxr = ri;\n      }\n\n      r[i] = ri;\n    }, true);\n    return maxr;\n  }\n  /**\n   * Calculate the norm for a 2D Matrix (M*N)\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _matrixNorm(x, p) {\n    // check p\n    if (p === 1) {\n      return _matrixNormOne(x);\n    }\n\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\n      return _matrixNormInfinity(x);\n    }\n\n    if (p === 'fro') {\n      return _matrixNormFrobenius(x);\n    }\n\n    if (p === 2) {\n      return _matrixNormTwo(x);\n    } // invalid parameter value\n\n\n    throw new Error('Unsupported parameter value ' + p);\n  }\n  /**\n   * Calculate the norm for an array\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n\n\n  function _norm(x, p) {\n    // size\n    var sizeX = x.size(); // check if it is a vector\n\n    if (sizeX.length === 1) {\n      return _vectorNorm(x, p);\n    } // MxN matrix\n\n\n    if (sizeX.length === 2) {\n      if (sizeX[0] && sizeX[1]) {\n        return _matrixNorm(x, p);\n      } else {\n        throw new RangeError('Invalid matrix dimensions');\n      }\n    }\n  }\n});\nexports.createNorm = createNorm;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createNorm","Complex","__esModule","value","number","BigNumber","Matrix","Array"]],"~:compiled-at",1619135723952,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$norm.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/norm.js\"],\n\"sourcesContent\":[\"shadow$provide[244] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createNorm = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'norm';\\nvar dependencies = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];\\nvar createNorm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      abs = _ref.abs,\\n      add = _ref.add,\\n      pow = _ref.pow,\\n      conj = _ref.conj,\\n      sqrt = _ref.sqrt,\\n      multiply = _ref.multiply,\\n      equalScalar = _ref.equalScalar,\\n      larger = _ref.larger,\\n      smaller = _ref.smaller,\\n      matrix = _ref.matrix,\\n      ctranspose = _ref.ctranspose,\\n      eigs = _ref.eigs;\\n\\n  /**\\n   * Calculate the norm of a number, vector or matrix.\\n   *\\n   * The second parameter p is optional. If not provided, it defaults to 2.\\n   *\\n   * Syntax:\\n   *\\n   *    math.norm(x)\\n   *    math.norm(x, p)\\n   *\\n   * Examples:\\n   *\\n   *    math.abs(-3.5)                         // returns 3.5\\n   *    math.norm(-3.5)                        // returns 3.5\\n   *\\n   *    math.norm(math.complex(3, -4))         // returns 5\\n   *\\n   *    math.norm([1, 2, -3], Infinity)        // returns 3\\n   *    math.norm([1, 2, -3], -Infinity)       // returns 1\\n   *\\n   *    math.norm([3, 4], 2)                   // returns 5\\n   *\\n   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6\\n   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7\\n   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661\\n   *\\n   * See also:\\n   *\\n   *    abs, hypot\\n   *\\n   * @param  {number | BigNumber | Complex | Array | Matrix} x\\n   *            Value for which to calculate the norm\\n   * @param  {number | BigNumber | string} [p=2]\\n   *            Vector space.\\n   *            Supported numbers include Infinity and -Infinity.\\n   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)\\n   * @return {number | BigNumber} the p-norm\\n   */\\n  return typed(name, {\\n    number: Math.abs,\\n    Complex: function Complex(x) {\\n      return x.abs();\\n    },\\n    BigNumber: function BigNumber(x) {\\n      // norm(x) = abs(x)\\n      return x.abs();\\n    },\\n    \\\"boolean\\\": function boolean(x) {\\n      // norm(x) = abs(x)\\n      return Math.abs(x);\\n    },\\n    Array: function Array(x) {\\n      return _norm(matrix(x), 2);\\n    },\\n    Matrix: function Matrix(x) {\\n      return _norm(x, 2);\\n    },\\n    'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {\\n      // ignore second parameter, TODO: remove the option of second parameter for these types\\n      return this(x);\\n    },\\n    'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {\\n      return _norm(matrix(x), p);\\n    },\\n    'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {\\n      return _norm(x, p);\\n    }\\n  });\\n  /**\\n   * Calculate the plus infinity norm for a vector\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n  function _vectorNormPlusInfinity(x) {\\n    // norm(x, Infinity) = max(abs(x))\\n    var pinf = 0; // skip zeros since abs(0) === 0\\n\\n    x.forEach(function (value) {\\n      var v = abs(value);\\n\\n      if (larger(v, pinf)) {\\n        pinf = v;\\n      }\\n    }, true);\\n    return pinf;\\n  }\\n  /**\\n   * Calculate the minus infinity norm for a vector\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _vectorNormMinusInfinity(x) {\\n    // norm(x, -Infinity) = min(abs(x))\\n    var ninf; // skip zeros since abs(0) === 0\\n\\n    x.forEach(function (value) {\\n      var v = abs(value);\\n\\n      if (!ninf || smaller(v, ninf)) {\\n        ninf = v;\\n      }\\n    }, true);\\n    return ninf || 0;\\n  }\\n  /**\\n   * Calculate the norm for a vector\\n   * @param {Matrix} x\\n   * @param {number | string} p\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _vectorNorm(x, p) {\\n    // check p\\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\\n      return _vectorNormPlusInfinity(x);\\n    }\\n\\n    if (p === Number.NEGATIVE_INFINITY || p === '-inf') {\\n      return _vectorNormMinusInfinity(x);\\n    }\\n\\n    if (p === 'fro') {\\n      return _norm(x, 2);\\n    }\\n\\n    if (typeof p === 'number' && !isNaN(p)) {\\n      // check p != 0\\n      if (!equalScalar(p, 0)) {\\n        // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p\\n        var n = 0; // skip zeros since abs(0) === 0\\n\\n        x.forEach(function (value) {\\n          n = add(pow(abs(value), p), n);\\n        }, true);\\n        return pow(n, 1 / p);\\n      }\\n\\n      return Number.POSITIVE_INFINITY;\\n    } // invalid parameter value\\n\\n\\n    throw new Error('Unsupported parameter value');\\n  }\\n  /**\\n   * Calculate the Frobenius norm for a matrix\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _matrixNormFrobenius(x) {\\n    // norm(x) = sqrt(sum(diag(x'x)))\\n    var fro = 0;\\n    x.forEach(function (value, index) {\\n      fro = add(fro, multiply(value, conj(value)));\\n    });\\n    return abs(sqrt(fro));\\n  }\\n  /**\\n   * Calculate the norm L1 for a matrix\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _matrixNormOne(x) {\\n    // norm(x) = the largest column sum\\n    var c = []; // result\\n\\n    var maxc = 0; // skip zeros since abs(0) == 0\\n\\n    x.forEach(function (value, index) {\\n      var j = index[1];\\n      var cj = add(c[j] || 0, abs(value));\\n\\n      if (larger(cj, maxc)) {\\n        maxc = cj;\\n      }\\n\\n      c[j] = cj;\\n    }, true);\\n    return maxc;\\n  }\\n  /**\\n   * Calculate the norm L2 for a matrix\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _matrixNormTwo(x) {\\n    // norm(x) = sqrt( max eigenvalue of A*.A)\\n    var sizeX = x.size();\\n\\n    if (sizeX[0] !== sizeX[1]) {\\n      throw new RangeError('Invalid matrix dimensions');\\n    }\\n\\n    var tx = ctranspose(x);\\n    var squaredX = multiply(tx, x);\\n    var eigenVals = eigs(squaredX).values;\\n    var rho = eigenVals.get([eigenVals.size()[0] - 1]);\\n    return abs(sqrt(rho));\\n  }\\n  /**\\n   * Calculate the infinity norm for a matrix\\n   * @param {Matrix} x\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _matrixNormInfinity(x) {\\n    // norm(x) = the largest row sum\\n    var r = []; // result\\n\\n    var maxr = 0; // skip zeros since abs(0) == 0\\n\\n    x.forEach(function (value, index) {\\n      var i = index[0];\\n      var ri = add(r[i] || 0, abs(value));\\n\\n      if (larger(ri, maxr)) {\\n        maxr = ri;\\n      }\\n\\n      r[i] = ri;\\n    }, true);\\n    return maxr;\\n  }\\n  /**\\n   * Calculate the norm for a 2D Matrix (M*N)\\n   * @param {Matrix} x\\n   * @param {number | string} p\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _matrixNorm(x, p) {\\n    // check p\\n    if (p === 1) {\\n      return _matrixNormOne(x);\\n    }\\n\\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\\n      return _matrixNormInfinity(x);\\n    }\\n\\n    if (p === 'fro') {\\n      return _matrixNormFrobenius(x);\\n    }\\n\\n    if (p === 2) {\\n      return _matrixNormTwo(x);\\n    } // invalid parameter value\\n\\n\\n    throw new Error('Unsupported parameter value ' + p);\\n  }\\n  /**\\n   * Calculate the norm for an array\\n   * @param {Matrix} x\\n   * @param {number | string} p\\n   * @returns {number} Returns the norm\\n   * @private\\n   */\\n\\n\\n  function _norm(x, p) {\\n    // size\\n    var sizeX = x.size(); // check if it is a vector\\n\\n    if (sizeX.length === 1) {\\n      return _vectorNorm(x, p);\\n    } // MxN matrix\\n\\n\\n    if (sizeX.length === 2) {\\n      if (sizeX[0] && sizeX[1]) {\\n        return _matrixNorm(x, p);\\n      } else {\\n        throw new RangeError('Invalid matrix dimensions');\\n      }\\n    }\\n  }\\n});\\nexports.createNorm = createNorm;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createNorm\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_vectorNormPlusInfinity\",\"x\",\"pinf\",\"forEach\",\"v\",\"abs\",\"larger\",\"_vectorNormMinusInfinity\",\"ninf\",\"smaller\",\"_vectorNorm\",\"p\",\"Number\",\"POSITIVE_INFINITY\",\"NEGATIVE_INFINITY\",\"_norm\",\"isNaN\",\"equalScalar\",\"n\",\"add\",\"pow\",\"Error\",\"_matrixNormFrobenius\",\"fro\",\"index\",\"multiply\",\"conj\",\"sqrt\",\"_matrixNormOne\",\"c\",\"maxc\",\"j\",\"cj\",\"_matrixNormInfinity\",\"r\",\"maxr\",\"i\",\"ri\",\"_matrixNorm\",\"sizeX\",\"size\",\"RangeError\",\"tx\",\"ctranspose\",\"squaredX\",\"eigenVals\",\"eigs\",\"values\",\"rho\",\"get\",\"length\",\"typed\",\"matrix\",\"number\",\"Math\",\"Complex\",\"BigNumber\",\"boolean\",\"Array\",\"Matrix\",\"numberComplexBigNumberBooleanNumberBigNumberString\",\"ArrayNumberBigNumberString\",\"MatrixNumberBigNumberString\"]\n}\n"]