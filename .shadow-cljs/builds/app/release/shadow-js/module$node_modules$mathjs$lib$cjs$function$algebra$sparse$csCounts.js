["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csCounts.js"],"~:js","shadow$provide[286]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createCsCounts=void 0;c=b(25);var q=b(285);b=(0,c.factory)(\"csCounts\",[\"transpose\"],function(f){var u=f.transpose;return function(k,t,p,g){if(!k||!t||!p)return null;var d=k._size,l=d[0];d=d[1];var h,n,r=4*d+(g?d+l+1:0),v=[],C=2*d,z=3*d,w=4*d,B=5*d+1;for(n=0;n<r;n++)v[n]=-1;r=[];n=u(k);k=n._index;var x=n._ptr;for(n=0;n<d;n++){var D=p[n];for(r[D]=-1===v[z+D]?1:0;-1!==D&&-1===v[z+D];D=t[D])v[z+D]=n}if(g){for(n=0;n<\nd;n++)v[p[n]]=n;for(h=0;h<l;h++){n=d;var F=x[h];for(D=x[h+1];F<D;F++)n=Math.min(n,v[k[F]]);v[B+h]=v[w+n];v[w+n]=h}}for(h=0;h<d;h++)v[0+h]=h;for(n=0;n<d;n++){D=p[n];-1!==t[D]&&r[t[D]]--;for(l=g?v[w+n]:D;-1!==l;l=g?v[B+l]:-1)for(F=x[l];F<x[l+1];F++)h=k[F],h=(0,q.csLeaf)(h,D,v,z,d,C,0),1<=h.jleaf&&r[D]++,2===h.jleaf&&r[h.q]--; -1!==t[D]&&(v[0+D]=t[D])}for(D=0;D<d;D++)-1!==t[D]&&(r[t[D]]+=r[D]);return r}});a.createCsCounts=b}","~:source","shadow$provide[286] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsCounts = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csLeaf = require(\"./csLeaf.js\");\n\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nvar createCsCounts = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var transpose = _ref.transpose;\n\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = (0, _csLeaf.csLeaf)(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});\nexports.createCsCounts = createCsCounts;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createCsCounts","__esModule","value"]],"~:compiled-at",1619135723978,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csCounts.js\"],\n\"sourcesContent\":[\"shadow$provide[286] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCsCounts = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _csLeaf = require(\\\"./csLeaf.js\\\");\\n\\nvar name = 'csCounts';\\nvar dependencies = ['transpose'];\\nvar createCsCounts = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var transpose = _ref.transpose;\\n\\n  /**\\n   * Computes the column counts using the upper triangular part of A.\\n   * It transposes A internally, none of the input parameters are modified.\\n   *\\n   * @param {Matrix} a           The sparse matrix A\\n   *\\n   * @param {Matrix} ata         Count the columns of A'A instead\\n   *\\n   * @return                     An array of size n of the column counts or null on error\\n   *\\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n   */\\n  return function (a, parent, post, ata) {\\n    // check inputs\\n    if (!a || !parent || !post) {\\n      return null;\\n    } // a matrix arrays\\n\\n\\n    var asize = a._size; // rows and columns\\n\\n    var m = asize[0];\\n    var n = asize[1]; // variables\\n\\n    var i, j, k, J, p, p0, p1; // workspace size\\n\\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\\n\\n    var w = []; // (s)\\n\\n    var ancestor = 0; // first n entries\\n\\n    var maxfirst = n; // next n entries\\n\\n    var prevleaf = 2 * n; // next n entries\\n\\n    var first = 3 * n; // next n entries\\n\\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\\n\\n    var next = 5 * n + 1; // last entries in workspace\\n    // clear workspace w[0..s-1]\\n\\n    for (k = 0; k < s; k++) {\\n      w[k] = -1;\\n    } // allocate result\\n\\n\\n    var colcount = []; // (n)\\n    // AT = A'\\n\\n    var at = transpose(a); // at arrays\\n\\n    var tindex = at._index;\\n    var tptr = at._ptr; // find w[first + j]\\n\\n    for (k = 0; k < n; k++) {\\n      j = post[k]; // colcount[j]=1 if j is a leaf\\n\\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\\n\\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\\n        w[first + j] = k;\\n      }\\n    } // initialize ata if needed\\n\\n\\n    if (ata) {\\n      // invert post\\n      for (k = 0; k < n; k++) {\\n        w[post[k]] = k;\\n      } // loop rows (columns in AT)\\n\\n\\n      for (i = 0; i < m; i++) {\\n        // values in column i of AT\\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\\n          k = Math.min(k, w[tindex[p]]);\\n        } // place row i in linked list k\\n\\n\\n        w[next + i] = w[head + k];\\n        w[head + k] = i;\\n      }\\n    } // each node in its own set\\n\\n\\n    for (i = 0; i < n; i++) {\\n      w[ancestor + i] = i;\\n    }\\n\\n    for (k = 0; k < n; k++) {\\n      // j is the kth node in postordered etree\\n      j = post[k]; // check j is not a root\\n\\n      if (parent[j] !== -1) {\\n        colcount[parent[j]]--;\\n      } // J=j for LL'=A case\\n\\n\\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\\n          i = tindex[p];\\n          var r = (0, _csLeaf.csLeaf)(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\\n\\n          if (r.jleaf >= 1) {\\n            colcount[j]++;\\n          } // check account for overlap in q\\n\\n\\n          if (r.jleaf === 2) {\\n            colcount[r.q]--;\\n          }\\n        }\\n      }\\n\\n      if (parent[j] !== -1) {\\n        w[ancestor + j] = parent[j];\\n      }\\n    } // sum up colcount's of each child\\n\\n\\n    for (j = 0; j < n; j++) {\\n      if (parent[j] !== -1) {\\n        colcount[parent[j]] += colcount[j];\\n      }\\n    }\\n\\n    return colcount;\\n  };\\n});\\nexports.createCsCounts = createCsCounts;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCsCounts\",\"_factory\",\"_csLeaf\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"transpose\",\"a\",\"parent\",\"post\",\"ata\",\"asize\",\"_size\",\"m\",\"n\",\"i\",\"k\",\"s\",\"w\",\"prevleaf\",\"first\",\"head\",\"next\",\"colcount\",\"at\",\"tindex\",\"_index\",\"tptr\",\"_ptr\",\"j\",\"p0\",\"p1\",\"p\",\"Math\",\"min\",\"ancestor\",\"J\",\"r\",\"csLeaf\",\"jleaf\",\"q\"]\n}\n"]