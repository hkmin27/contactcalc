["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/string.js"],"~:js","shadow$provide[21]=function(c,b,y,a){function q(d){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(l){return typeof l}:function(l){return l&&\"function\"===typeof Symbol&&l.constructor===Symbol&&l!==Symbol.prototype?\"symbol\":typeof l};return q(d)}function f(d,l){return\"number\"===typeof d?(0,p.format)(d,l):(0,t.isBigNumber)(d)?(0,g.format)(d,l):k(d)?l&&\"decimal\"===l.fraction?d.toString():d.s*d.n+\"/\"+d.d:Array.isArray(d)?u(d,l):(0,t.isString)(d)?'\"'+\nd+'\"':\"function\"===typeof d?d.syntax?String(d.syntax):\"function\":d&&\"object\"===q(d)?\"function\"===typeof d.format?d.format(l):d&&d.toString(l)!=={}.toString()?d.toString(l):\"{\"+Object.keys(d).map(function(h){return'\"'+h+'\": '+f(d[h],l)}).join(\", \")+\"}\":String(d)}function u(d,l){if(Array.isArray(d)){for(var h=\"[\",n=d.length,r=0;r<n;r++)0!==r&&(h+=\", \"),h+=u(d[r],l);return h+\"]\"}return f(d,l)}function k(d){return d&&\"object\"===q(d)&&\"number\"===typeof d.s&&\"number\"===typeof d.n&&\"number\"===typeof d.d||\n!1}Object.defineProperty(a,\"__esModule\",{value:!0});a.endsWith=function(d,l){return d.substring(d.length-l.length,d.length)===l};a.format=f;a.stringify=function(d){d=String(d);for(var l=\"\",h=0;h<d.length;){var n=d.charAt(h);if(\"\\\\\"===n){l+=n;h++;n=d.charAt(h);if(\"\"===n||-1==='\"\\\\/bfnrtu'.indexOf(n))l+=\"\\\\\";l+=n}else l='\"'===n?l+'\\\\\"':l+n;h++}return'\"'+l+'\"'};a.escape=function(d){d=String(d);return d=d.replace(/&/g,\"\\x26amp;\").replace(/\"/g,\"\\x26quot;\").replace(/'/g,\"\\x26#39;\").replace(/</g,\"\\x26lt;\").replace(/>/g,\n\"\\x26gt;\")};a.compareText=function(d,l){if(!(0,t.isString)(d))throw new TypeError(\"Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: \"+(0,t.typeOf)(d)+\", index: 0)\");if(!(0,t.isString)(l))throw new TypeError(\"Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: \"+(0,t.typeOf)(l)+\", index: 1)\");return d===l?0:d>l?1:-1};var t=b(14),p=b(19),g=b(20)}","~:source","shadow$provide[21] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.endsWith = endsWith;\nexports.format = format;\nexports.stringify = stringify;\nexports.escape = escape;\nexports.compareText = compareText;\n\nvar _is = require(\"./is.js\");\n\nvar _number = require(\"./number.js\");\n\nvar _formatter = require(\"./bignumber/formatter.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\nfunction endsWith(text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return text.substring(start, end) === search;\n}\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7)                // '0.2857142857142857'\n *     math.format(math.pi, 3)         // '3.14'\n *     math.format(new Complex(2, 3))  // '2 + 3i'\n *     math.format('hello')            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\n\n\nfunction format(value, options) {\n  if (typeof value === 'number') {\n    return (0, _number.format)(value, options);\n  }\n\n  if ((0, _is.isBigNumber)(value)) {\n    return (0, _formatter.format)(value, options);\n  } // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n\n\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return value.s * value.n + '/' + value.d;\n    } else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if ((0, _is.isString)(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && _typeof(value) === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    } else if (value && value.toString(options) !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString(options);\n    } else {\n      var entries = Object.keys(value).map(function (key) {\n        return '\"' + key + '\": ' + format(value[key], options);\n      });\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n}\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\n\n\nfunction stringify(value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n      c = text.charAt(i);\n\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\'; // no valid escape character -> escape it\n      }\n\n      escaped += c;\n    } else if (c === '\"') {\n      escaped += '\\\\\"';\n    } else {\n      escaped += c;\n    }\n\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n}\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\n\n\nfunction escape(value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return text;\n}\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\n\n\nfunction formatArray(array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n\n    for (var i = 0; i < len; i++) {\n      if (i !== 0) {\n        str += ', ';\n      }\n\n      str += formatArray(array[i], options);\n    }\n\n    str += ']';\n    return str;\n  } else {\n    return format(array, options);\n  }\n}\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction looksLikeFraction(value) {\n  return value && _typeof(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\n}\n/**\n * Compare two strings\n * @param {string} x\n * @param {string} y\n * @returns {number}\n */\n\n\nfunction compareText(x, y) {\n  // we don't want to convert numbers to string, only accept string input\n  if (!(0, _is.isString)(x)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, _is.typeOf)(x) + ', index: 0)');\n  }\n\n  if (!(0, _is.isString)(y)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, _is.typeOf)(y) + ', index: 1)');\n  }\n\n  return x === y ? 0 : x > y ? 1 : -1;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$bignumber$formatter","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is"]],"~:properties",["^5",["endsWith","__esModule","escape","value","stringify","format","compareText"]],"~:compiled-at",1619135723713,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$string.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/string.js\"],\n\"sourcesContent\":[\"shadow$provide[21] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.endsWith = endsWith;\\nexports.format = format;\\nexports.stringify = stringify;\\nexports.escape = escape;\\nexports.compareText = compareText;\\n\\nvar _is = require(\\\"./is.js\\\");\\n\\nvar _number = require(\\\"./number.js\\\");\\n\\nvar _formatter = require(\\\"./bignumber/formatter.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * Check if a text ends with a certain string.\\n * @param {string} text\\n * @param {string} search\\n */\\nfunction endsWith(text, search) {\\n  var start = text.length - search.length;\\n  var end = text.length;\\n  return text.substring(start, end) === search;\\n}\\n/**\\n * Format a value of any type into a string.\\n *\\n * Usage:\\n *     math.format(value)\\n *     math.format(value, precision)\\n *\\n * When value is a function:\\n *\\n * - When the function has a property `syntax`, it returns this\\n *   syntax description.\\n * - In other cases, a string `'function'` is returned.\\n *\\n * When `value` is an Object:\\n *\\n * - When the object contains a property `format` being a function, this\\n *   function is invoked as `value.format(options)` and the result is returned.\\n * - When the object has its own `toString` method, this method is invoked\\n *   and the result is returned.\\n * - In other cases the function will loop over all object properties and\\n *   return JSON object notation like '{\\\"a\\\": 2, \\\"b\\\": 3}'.\\n *\\n * Example usage:\\n *     math.format(2/7)                // '0.2857142857142857'\\n *     math.format(math.pi, 3)         // '3.14'\\n *     math.format(new Complex(2, 3))  // '2 + 3i'\\n *     math.format('hello')            // '\\\"hello\\\"'\\n *\\n * @param {*} value             Value to be stringified\\n * @param {Object | number | Function} [options]  Formatting options. See\\n *                                                lib/utils/number:format for a\\n *                                                description of the available\\n *                                                options.\\n * @return {string} str\\n */\\n\\n\\nfunction format(value, options) {\\n  if (typeof value === 'number') {\\n    return (0, _number.format)(value, options);\\n  }\\n\\n  if ((0, _is.isBigNumber)(value)) {\\n    return (0, _formatter.format)(value, options);\\n  } // note: we use unsafe duck-typing here to check for Fractions, this is\\n  // ok here since we're only invoking toString or concatenating its values\\n\\n\\n  if (looksLikeFraction(value)) {\\n    if (!options || options.fraction !== 'decimal') {\\n      // output as ratio, like '1/3'\\n      return value.s * value.n + '/' + value.d;\\n    } else {\\n      // output as decimal, like '0.(3)'\\n      return value.toString();\\n    }\\n  }\\n\\n  if (Array.isArray(value)) {\\n    return formatArray(value, options);\\n  }\\n\\n  if ((0, _is.isString)(value)) {\\n    return '\\\"' + value + '\\\"';\\n  }\\n\\n  if (typeof value === 'function') {\\n    return value.syntax ? String(value.syntax) : 'function';\\n  }\\n\\n  if (value && _typeof(value) === 'object') {\\n    if (typeof value.format === 'function') {\\n      return value.format(options);\\n    } else if (value && value.toString(options) !== {}.toString()) {\\n      // this object has a non-native toString method, use that one\\n      return value.toString(options);\\n    } else {\\n      var entries = Object.keys(value).map(function (key) {\\n        return '\\\"' + key + '\\\": ' + format(value[key], options);\\n      });\\n      return '{' + entries.join(', ') + '}';\\n    }\\n  }\\n\\n  return String(value);\\n}\\n/**\\n * Stringify a value into a string enclosed in double quotes.\\n * Unescaped double quotes and backslashes inside the value are escaped.\\n * @param {*} value\\n * @return {string}\\n */\\n\\n\\nfunction stringify(value) {\\n  var text = String(value);\\n  var escaped = '';\\n  var i = 0;\\n\\n  while (i < text.length) {\\n    var c = text.charAt(i);\\n\\n    if (c === '\\\\\\\\') {\\n      escaped += c;\\n      i++;\\n      c = text.charAt(i);\\n\\n      if (c === '' || '\\\"\\\\\\\\/bfnrtu'.indexOf(c) === -1) {\\n        escaped += '\\\\\\\\'; // no valid escape character -> escape it\\n      }\\n\\n      escaped += c;\\n    } else if (c === '\\\"') {\\n      escaped += '\\\\\\\\\\\"';\\n    } else {\\n      escaped += c;\\n    }\\n\\n    i++;\\n  }\\n\\n  return '\\\"' + escaped + '\\\"';\\n}\\n/**\\n * Escape special HTML characters\\n * @param {*} value\\n * @return {string}\\n */\\n\\n\\nfunction escape(value) {\\n  var text = String(value);\\n  text = text.replace(/&/g, '&amp;').replace(/\\\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\\n  return text;\\n}\\n/**\\n * Recursively format an n-dimensional matrix\\n * Example output: \\\"[[1, 2], [3, 4]]\\\"\\n * @param {Array} array\\n * @param {Object | number | Function} [options]  Formatting options. See\\n *                                                lib/utils/number:format for a\\n *                                                description of the available\\n *                                                options.\\n * @returns {string} str\\n */\\n\\n\\nfunction formatArray(array, options) {\\n  if (Array.isArray(array)) {\\n    var str = '[';\\n    var len = array.length;\\n\\n    for (var i = 0; i < len; i++) {\\n      if (i !== 0) {\\n        str += ', ';\\n      }\\n\\n      str += formatArray(array[i], options);\\n    }\\n\\n    str += ']';\\n    return str;\\n  } else {\\n    return format(array, options);\\n  }\\n}\\n/**\\n * Check whether a value looks like a Fraction (unsafe duck-type check)\\n * @param {*} value\\n * @return {boolean}\\n */\\n\\n\\nfunction looksLikeFraction(value) {\\n  return value && _typeof(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\\n}\\n/**\\n * Compare two strings\\n * @param {string} x\\n * @param {string} y\\n * @returns {number}\\n */\\n\\n\\nfunction compareText(x, y) {\\n  // we don't want to convert numbers to string, only accept string input\\n  if (!(0, _is.isString)(x)) {\\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, _is.typeOf)(x) + ', index: 0)');\\n  }\\n\\n  if (!(0, _is.isString)(y)) {\\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, _is.typeOf)(y) + ', index: 1)');\\n  }\\n\\n  return x === y ? 0 : x > y ? 1 : -1;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"format\",\"value\",\"options\",\"_number\",\"_is\",\"isBigNumber\",\"_formatter\",\"looksLikeFraction\",\"fraction\",\"toString\",\"s\",\"n\",\"d\",\"Array\",\"isArray\",\"formatArray\",\"isString\",\"syntax\",\"String\",\"Object\",\"keys\",\"map\",\"entries\",\"key\",\"join\",\"array\",\"str\",\"len\",\"length\",\"i\",\"defineProperty\",\"endsWith\",\"text\",\"search\",\"substring\",\"stringify\",\"escaped\",\"c\",\"charAt\",\"indexOf\",\"escape\",\"replace\",\"compareText\",\"x\",\"y\",\"TypeError\",\"typeOf\"]\n}\n"]