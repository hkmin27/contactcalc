["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/SymbolNode.js"],"~:js","shadow$provide[269]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSymbolNode=void 0;var q=b(21),f=b(147);c=b(25);var u=b(260);b=(0,c.factory)(\"SymbolNode\",[\"math\",\"?Unit\",\"Node\"],function(k){function t(d){if(!(this instanceof t))throw new SyntaxError(\"Constructor must be called with the new operator\");if(\"string\"!==typeof d)throw new TypeError('String expected for parameter \"name\"');this.name=d}var p=k.math,g=k.Unit;t.prototype=new k.Node;t.prototype.type=\"SymbolNode\";\nt.prototype.isSymbolNode=!0;t.prototype._compile=function(d,l){var h=this.name;if(!0===l[h])return function(r,v,C){return v[h]};if(h in d)return function(r,v,C){return h in r?(0,f.getSafeProperty)(r,h):(0,f.getSafeProperty)(d,h)};var n=g?g.isValuelessUnit(h):!1;return function(r,v,C){return h in r?(0,f.getSafeProperty)(r,h):n?new g(null,h):t.onUndefinedSymbol(h)}};t.prototype.forEach=function(d){};t.prototype.map=function(d){return this.clone()};t.onUndefinedSymbol=function(d){throw Error(\"Undefined symbol \"+\nd);};t.prototype.clone=function(){return new t(this.name)};t.prototype._toString=function(d){return this.name};t.prototype.toHTML=function(d){d=(0,q.escape)(this.name);return\"true\"===d||\"false\"===d?'\\x3cspan class\\x3d\"math-symbol math-boolean\"\\x3e'+d+\"\\x3c/span\\x3e\":\"i\"===d?'\\x3cspan class\\x3d\"math-symbol math-imaginary-symbol\"\\x3e'+d+\"\\x3c/span\\x3e\":\"Infinity\"===d?'\\x3cspan class\\x3d\"math-symbol math-infinity-symbol\"\\x3e'+d+\"\\x3c/span\\x3e\":\"NaN\"===d?'\\x3cspan class\\x3d\"math-symbol math-nan-symbol\"\\x3e'+\nd+\"\\x3c/span\\x3e\":\"null\"===d?'\\x3cspan class\\x3d\"math-symbol math-null-symbol\"\\x3e'+d+\"\\x3c/span\\x3e\":\"undefined\"===d?'\\x3cspan class\\x3d\"math-symbol math-undefined-symbol\"\\x3e'+d+\"\\x3c/span\\x3e\":'\\x3cspan class\\x3d\"math-symbol\"\\x3e'+d+\"\\x3c/span\\x3e\"};t.prototype.toJSON=function(){return{mathjs:\"SymbolNode\",name:this.name}};t.fromJSON=function(d){return new t(d.name)};t.prototype._toTex=function(d){d=!1;\"undefined\"===typeof p[this.name]&&g&&g.isValuelessUnit(this.name)&&(d=!0);d=(0,u.toSymbol)(this.name,\nd);return\"\\\\\"===d[0]?d:\" \"+d};return t},{isClass:!0,isNode:!0});a.createSymbolNode=b}","~:source","shadow$provide[269] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSymbolNode = void 0;\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nvar createSymbolNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Unit = _ref.Unit,\n      Node = _ref.Node;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : (0, _customs.getSafeProperty)(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = (0, _string.escape)(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = (0, _latex.toSymbol)(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createSymbolNode = createSymbolNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$latex","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","createSymbolNode","onUndefinedSymbol","forEach","fromJSON","isClass","toHTML","prototype","_toString","isNode","_toTex","__esModule","isSymbolNode","name","value","mathjs","type","clone","_compile","toJSON"]],"~:compiled-at",1619135723969,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$SymbolNode.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/SymbolNode.js\"],\n\"sourcesContent\":[\"shadow$provide[269] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSymbolNode = void 0;\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _latex = require(\\\"../../utils/latex.js\\\");\\n\\nvar name = 'SymbolNode';\\nvar dependencies = ['math', '?Unit', 'Node'];\\nvar createSymbolNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var math = _ref.math,\\n      Unit = _ref.Unit,\\n      Node = _ref.Node;\\n\\n  /**\\n   * Check whether some name is a valueless unit like \\\"inch\\\".\\n   * @param {string} name\\n   * @return {boolean}\\n   */\\n  function isValuelessUnit(name) {\\n    return Unit ? Unit.isValuelessUnit(name) : false;\\n  }\\n  /**\\n   * @constructor SymbolNode\\n   * @extends {Node}\\n   * A symbol node can hold and resolve a symbol\\n   * @param {string} name\\n   * @extends {Node}\\n   */\\n\\n\\n  function SymbolNode(name) {\\n    if (!(this instanceof SymbolNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // validate input\\n\\n\\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \\\"name\\\"');\\n    this.name = name;\\n  }\\n\\n  SymbolNode.prototype = new Node();\\n  SymbolNode.prototype.type = 'SymbolNode';\\n  SymbolNode.prototype.isSymbolNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  SymbolNode.prototype._compile = function (math, argNames) {\\n    var name = this.name;\\n\\n    if (argNames[name] === true) {\\n      // this is a FunctionAssignment argument\\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\\n      return function (scope, args, context) {\\n        return args[name];\\n      };\\n    } else if (name in math) {\\n      return function (scope, args, context) {\\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : (0, _customs.getSafeProperty)(math, name);\\n      };\\n    } else {\\n      var isUnit = isValuelessUnit(name);\\n      return function (scope, args, context) {\\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\\n      };\\n    }\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\\n  };\\n  /**\\n   * Create a new SymbolNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\\n   * @returns {SymbolNode} Returns a clone of the node\\n   */\\n\\n\\n  SymbolNode.prototype.map = function (callback) {\\n    return this.clone();\\n  };\\n  /**\\n   * Throws an error 'Undefined symbol {name}'\\n   * @param {string} name\\n   */\\n\\n\\n  SymbolNode.onUndefinedSymbol = function (name) {\\n    throw new Error('Undefined symbol ' + name);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {SymbolNode}\\n   */\\n\\n\\n  SymbolNode.prototype.clone = function () {\\n    return new SymbolNode(this.name);\\n  };\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  SymbolNode.prototype._toString = function (options) {\\n    return this.name;\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  SymbolNode.prototype.toHTML = function (options) {\\n    var name = (0, _string.escape)(this.name);\\n\\n    if (name === 'true' || name === 'false') {\\n      return '<span class=\\\"math-symbol math-boolean\\\">' + name + '</span>';\\n    } else if (name === 'i') {\\n      return '<span class=\\\"math-symbol math-imaginary-symbol\\\">' + name + '</span>';\\n    } else if (name === 'Infinity') {\\n      return '<span class=\\\"math-symbol math-infinity-symbol\\\">' + name + '</span>';\\n    } else if (name === 'NaN') {\\n      return '<span class=\\\"math-symbol math-nan-symbol\\\">' + name + '</span>';\\n    } else if (name === 'null') {\\n      return '<span class=\\\"math-symbol math-null-symbol\\\">' + name + '</span>';\\n    } else if (name === 'undefined') {\\n      return '<span class=\\\"math-symbol math-undefined-symbol\\\">' + name + '</span>';\\n    }\\n\\n    return '<span class=\\\"math-symbol\\\">' + name + '</span>';\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  SymbolNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'SymbolNode',\\n      name: this.name\\n    };\\n  };\\n  /**\\n   * Instantiate a SymbolNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"SymbolNode\\\", name: \\\"x\\\"}`,\\n   *                       where mathjs is optional\\n   * @returns {SymbolNode}\\n   */\\n\\n\\n  SymbolNode.fromJSON = function (json) {\\n    return new SymbolNode(json.name);\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  SymbolNode.prototype._toTex = function (options) {\\n    var isUnit = false;\\n\\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\\n      isUnit = true;\\n    }\\n\\n    var symbol = (0, _latex.toSymbol)(this.name, isUnit);\\n\\n    if (symbol[0] === '\\\\\\\\') {\\n      // no space needed if the symbol starts with '\\\\'\\n      return symbol;\\n    } // the space prevents symbols from breaking stuff like '\\\\cdot' if it's written right before the symbol\\n\\n\\n    return ' ' + symbol;\\n  };\\n\\n  return SymbolNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createSymbolNode = createSymbolNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSymbolNode\",\"_string\",\"_customs\",\"_factory\",\"_latex\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"SymbolNode\",\"SyntaxError\",\"TypeError\",\"math\",\"Unit\",\"prototype\",\"Node\",\"type\",\"isSymbolNode\",\"_compile\",\"SymbolNode.prototype._compile\",\"argNames\",\"scope\",\"args\",\"context\",\"getSafeProperty\",\"isUnit\",\"isValuelessUnit\",\"onUndefinedSymbol\",\"forEach\",\"SymbolNode.prototype.forEach\",\"callback\",\"map\",\"SymbolNode.prototype.map\",\"clone\",\"SymbolNode.onUndefinedSymbol\",\"Error\",\"SymbolNode.prototype.clone\",\"_toString\",\"SymbolNode.prototype._toString\",\"options\",\"toHTML\",\"SymbolNode.prototype.toHTML\",\"escape\",\"toJSON\",\"SymbolNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"SymbolNode.fromJSON\",\"json\",\"_toTex\",\"SymbolNode.prototype._toTex\",\"symbol\",\"toSymbol\",\"isClass\",\"isNode\"]\n}\n"]