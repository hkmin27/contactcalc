["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/nthRoots.js"],"~:js","shadow$provide[169]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createNthRoots=void 0;c=b(25);c=(0,c.factory)(\"nthRoots\",[\"config\",\"typed\",\"divideScalar\",\"Complex\"],function(q){function f(p,g){if(0>g)throw Error(\"Root must be greater than zero\");if(0===g)throw Error(\"Root must be non-zero\");if(0!==g%1)throw Error(\"Root must be an integer\");if(0===p||0===p.abs())return[new k(0,0)];var d=\"number\"===typeof p;if(d||0===p.re||0===p.im)var l=d?2*+(0>p):0===p.im?2*+(0>p.re):2*+(0>\np.im)+1;d=p.arg();var h=p.abs();p=[];h=Math.pow(h,1/g);for(var n=0;n<g;n++){var r=(l+4*n)/g;r===Math.round(r)?p.push(t[r%4](h)):p.push(new k({r:h,phi:(d+2*Math.PI*n)/g}))}return p}var u=q.typed,k=q.Complex,t=[function(p){return new k(p,0)},function(p){return new k(0,p)},function(p){return new k(-p,0)},function(p){return new k(0,-p)}];return u(\"nthRoots\",{Complex:function(p){return f(p,2)},\"Complex, number\":f})});a.createNthRoots=c}","~:source","shadow$provide[169] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNthRoots = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'nthRoots';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nvar createNthRoots = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      divideScalar = _ref.divideScalar,\n      Complex = _ref.Complex;\n\n  /**\n   * Each function here returns a real multiple of i as a Complex value.\n   * @param  {number} val\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\n   */\n  // This is used to fix float artifacts for zero-valued components.\n  var _calculateExactResult = [function realPos(val) {\n    return new Complex(val, 0);\n  }, function imagPos(val) {\n    return new Complex(0, val);\n  }, function realNeg(val) {\n    return new Complex(-val, 0);\n  }, function imagNeg(val) {\n    return new Complex(0, -val);\n  }];\n  /**\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\n   * @param  {Complex} a\n   * @param  {number} root\n   * @return {Array} array of n Complex Roots\n   */\n\n  function _nthComplexRoots(a, root) {\n    if (root < 0) throw new Error('Root must be greater than zero');\n    if (root === 0) throw new Error('Root must be non-zero');\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\n    var aIsNumeric = typeof a === 'number';\n    var offset; // determine the offset (argument of a)/(pi/2)\n\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\n      if (aIsNumeric) {\n        offset = 2 * +(a < 0); // numeric value on the real axis\n      } else if (a.im === 0) {\n        offset = 2 * +(a.re < 0); // complex value on the real axis\n      } else {\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\n      }\n    }\n\n    var arg = a.arg();\n    var abs = a.abs();\n    var roots = [];\n    var r = Math.pow(abs, 1 / root);\n\n    for (var k = 0; k < root; k++) {\n      var halfPiFactor = (offset + 4 * k) / root;\n      /**\n       * If (offset + 4*k)/root is an integral multiple of pi/2\n       * then we can produce a more exact result.\n       */\n\n      if (halfPiFactor === Math.round(halfPiFactor)) {\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\n        continue;\n      }\n\n      roots.push(new Complex({\n        r: r,\n        phi: (arg + 2 * Math.PI * k) / root\n      }));\n    }\n\n    return roots;\n  }\n  /**\n   * Calculate the nth roots of a value.\n   * An nth root of a positive real number A,\n   * is a positive real solution of the equation \"x^root = A\".\n   * This function returns an array of complex values.\n   *\n   * Syntax:\n   *\n   *    math.nthRoots(x)\n   *    math.nthRoots(x, root)\n   *\n   * Examples:\n   *\n   *    math.nthRoots(1)\n   *    // returns [\n   *    //   {re: 1, im: 0},\n   *    //   {re: -1, im: 0}\n   *    // ]\n   *    nthRoots(1, 3)\n   *    // returns [\n   *    //   { re: 1, im: 0 },\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\n   *    ]\n   *\n   * See also:\n   *\n   *    nthRoot, pow, sqrt\n   *\n   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex}            Rounded value\n   */\n\n\n  return typed(name, {\n    Complex: function Complex(x) {\n      return _nthComplexRoots(x, 2);\n    },\n    'Complex, number': _nthComplexRoots\n  });\n});\nexports.createNthRoots = createNthRoots;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["Complex","__esModule","value","r","phi","createNthRoots"]],"~:compiled-at",1619135723899,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$nthRoots.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/nthRoots.js\"],\n\"sourcesContent\":[\"shadow$provide[169] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createNthRoots = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'nthRoots';\\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\\nvar createNthRoots = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      config = _ref.config,\\n      divideScalar = _ref.divideScalar,\\n      Complex = _ref.Complex;\\n\\n  /**\\n   * Each function here returns a real multiple of i as a Complex value.\\n   * @param  {number} val\\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\\n   */\\n  // This is used to fix float artifacts for zero-valued components.\\n  var _calculateExactResult = [function realPos(val) {\\n    return new Complex(val, 0);\\n  }, function imagPos(val) {\\n    return new Complex(0, val);\\n  }, function realNeg(val) {\\n    return new Complex(-val, 0);\\n  }, function imagNeg(val) {\\n    return new Complex(0, -val);\\n  }];\\n  /**\\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\\n   * @param  {Complex} a\\n   * @param  {number} root\\n   * @return {Array} array of n Complex Roots\\n   */\\n\\n  function _nthComplexRoots(a, root) {\\n    if (root < 0) throw new Error('Root must be greater than zero');\\n    if (root === 0) throw new Error('Root must be non-zero');\\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\\n    var aIsNumeric = typeof a === 'number';\\n    var offset; // determine the offset (argument of a)/(pi/2)\\n\\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\\n      if (aIsNumeric) {\\n        offset = 2 * +(a < 0); // numeric value on the real axis\\n      } else if (a.im === 0) {\\n        offset = 2 * +(a.re < 0); // complex value on the real axis\\n      } else {\\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\\n      }\\n    }\\n\\n    var arg = a.arg();\\n    var abs = a.abs();\\n    var roots = [];\\n    var r = Math.pow(abs, 1 / root);\\n\\n    for (var k = 0; k < root; k++) {\\n      var halfPiFactor = (offset + 4 * k) / root;\\n      /**\\n       * If (offset + 4*k)/root is an integral multiple of pi/2\\n       * then we can produce a more exact result.\\n       */\\n\\n      if (halfPiFactor === Math.round(halfPiFactor)) {\\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\\n        continue;\\n      }\\n\\n      roots.push(new Complex({\\n        r: r,\\n        phi: (arg + 2 * Math.PI * k) / root\\n      }));\\n    }\\n\\n    return roots;\\n  }\\n  /**\\n   * Calculate the nth roots of a value.\\n   * An nth root of a positive real number A,\\n   * is a positive real solution of the equation \\\"x^root = A\\\".\\n   * This function returns an array of complex values.\\n   *\\n   * Syntax:\\n   *\\n   *    math.nthRoots(x)\\n   *    math.nthRoots(x, root)\\n   *\\n   * Examples:\\n   *\\n   *    math.nthRoots(1)\\n   *    // returns [\\n   *    //   {re: 1, im: 0},\\n   *    //   {re: -1, im: 0}\\n   *    // ]\\n   *    nthRoots(1, 3)\\n   *    // returns [\\n   *    //   { re: 1, im: 0 },\\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\\n   *    ]\\n   *\\n   * See also:\\n   *\\n   *    nthRoot, pow, sqrt\\n   *\\n   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded\\n   * @return {number | BigNumber | Fraction | Complex}            Rounded value\\n   */\\n\\n\\n  return typed(name, {\\n    Complex: function Complex(x) {\\n      return _nthComplexRoots(x, 2);\\n    },\\n    'Complex, number': _nthComplexRoots\\n  });\\n});\\nexports.createNthRoots = createNthRoots;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createNthRoots\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_nthComplexRoots\",\"a\",\"root\",\"Error\",\"abs\",\"Complex\",\"aIsNumeric\",\"re\",\"im\",\"offset\",\"arg\",\"roots\",\"r\",\"Math\",\"pow\",\"k\",\"halfPiFactor\",\"round\",\"push\",\"_calculateExactResult\",\"phi\",\"PI\",\"typed\",\"realPos\",\"val\",\"imagPos\",\"realNeg\",\"imagNeg\",\"x\"]\n}\n"]