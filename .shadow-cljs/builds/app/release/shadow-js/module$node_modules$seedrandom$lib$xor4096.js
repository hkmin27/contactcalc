["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/seedrandom/lib/xor4096.js"],"~:js","shadow$provide[548]=function(c,b,y,a){(function(q,f,u){function k(g){var d=this;d.next=function(){var l=d.w,h=d.X,n=d.i;d.w=l=l+1640531527|0;var r=h[n+34&127];var v=h[n=n+1&127];r^=r<<13;v^=v<<17;r=h[n]=r^r>>>15^v^v>>>12;d.i=n;return r+(l^l>>>16)|0};(function(l,h){var n,r,v=[],C=128;if(h===(h|0)){var z=h;h=null}else h+=\"\\x00\",z=0,C=Math.max(C,h.length);var w=0;for(n=-32;n<C;++n)if(h&&(z^=h.charCodeAt((n+32)%h.length)),0===n&&(r=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,0<=n){r=r+1640531527|0;var B=\nv[n&127]^=z+r;w=0==B?w+1:0}128<=w&&(v[(h&&h.length||0)&127]=-1);w=127;for(n=512;0<n;--n)z=v[w+34&127],B=v[w=w+1&127],z^=z<<13,B^=B<<17,z^=z>>>15,B^=B>>>12,v[w]=z^B;l.w=r;l.X=v;l.i=w})(d,g)}function t(g,d){d.i=g.i;d.w=g.w;d.X=g.X.slice();return d}function p(g,d){null==g&&(g=+new Date);var l=new k(g);g=d&&d.state;d=function(){return(l.next()>>>0)/4294967296};d.double=function(){do{var h=l.next()>>>11,n=(l.next()>>>0)/4294967296;h=(h+n)/2097152}while(0===h);return h};d.int32=l.next;d.quick=d;g&&(g.X&&\nt(g,l),d.state=function(){return t(l,{})});return d}f&&f.exports?f.exports=p:u&&u.amd?u(function(){return p}):this.xor4096=p})(this,\"object\"==typeof y&&y,\"function\"==typeof define&&define)}","~:source","shadow$provide[548] = function(global,require,module,exports) {\n// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    var w = me.w,\n        X = me.X, i = me.i, t, v;\n    // Update Weyl generator.\n    me.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    me.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  };\n\n  function init(me, seed) {\n    var t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    me.w = w;\n    me.X = X;\n    me.i = i;\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.i = f.i;\n  t.w = f.w;\n  t.X = f.X.slice();\n  return t;\n};\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.X) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xor4096 = impl;\n}\n\n})(\n  this,                                     // window object or global\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["w","next","int32","quick","i","state","double","X","xor4096"]],"~:compiled-at",1619135724029,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$seedrandom$lib$xor4096.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/seedrandom/lib/xor4096.js\"],\n\"sourcesContent\":[\"shadow$provide[548] = function(global,require,module,exports) {\\n// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\\n//\\n// This fast non-cryptographic random number generator is designed for\\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\\n// generator with a Weyl generator, and it passes all common batteries\\n// of stasticial tests for randomness while consuming only a few nanoseconds\\n// for each prng generated.  For background on the generator, see Brent's\\n// paper: \\\"Some long-period random number generators using shifts and xors.\\\"\\n// http://arxiv.org/pdf/1004.3115v1.pdf\\n//\\n// Usage:\\n//\\n// var xor4096 = require('xor4096');\\n// random = xor4096(1);                        // Seed with int32 or string.\\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\\n//\\n// For nonzero numeric keys, this impelementation provides a sequence\\n// identical to that by Brent's xorgens 3 implementaion in C.  This\\n// implementation also provides for initalizing the generator with\\n// string seeds, or for saving and restoring the state of the generator.\\n//\\n// On Chrome, this prng benchmarks about 2.1 times slower than\\n// Javascript's built-in Math.random().\\n\\n(function(global, module, define) {\\n\\nfunction XorGen(seed) {\\n  var me = this;\\n\\n  // Set up generator function.\\n  me.next = function() {\\n    var w = me.w,\\n        X = me.X, i = me.i, t, v;\\n    // Update Weyl generator.\\n    me.w = w = (w + 0x61c88647) | 0;\\n    // Update xor generator.\\n    v = X[(i + 34) & 127];\\n    t = X[i = ((i + 1) & 127)];\\n    v ^= v << 13;\\n    t ^= t << 17;\\n    v ^= v >>> 15;\\n    t ^= t >>> 12;\\n    // Update Xor generator array state.\\n    v = X[i] = v ^ t;\\n    me.i = i;\\n    // Result is the combination.\\n    return (v + (w ^ (w >>> 16))) | 0;\\n  };\\n\\n  function init(me, seed) {\\n    var t, v, i, j, w, X = [], limit = 128;\\n    if (seed === (seed | 0)) {\\n      // Numeric seeds initialize v, which is used to generates X.\\n      v = seed;\\n      seed = null;\\n    } else {\\n      // String seeds are mixed into v and X one character at a time.\\n      seed = seed + '\\\\0';\\n      v = 0;\\n      limit = Math.max(limit, seed.length);\\n    }\\n    // Initialize circular array and weyl value.\\n    for (i = 0, j = -32; j < limit; ++j) {\\n      // Put the unicode characters into the array, and shuffle them.\\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\\n      // After 32 shuffles, take v as the starting w value.\\n      if (j === 0) w = v;\\n      v ^= v << 10;\\n      v ^= v >>> 15;\\n      v ^= v << 4;\\n      v ^= v >>> 13;\\n      if (j >= 0) {\\n        w = (w + 0x61c88647) | 0;     // Weyl.\\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\\n      }\\n    }\\n    // We have detected all zeroes; make the key nonzero.\\n    if (i >= 128) {\\n      X[(seed && seed.length || 0) & 127] = -1;\\n    }\\n    // Run the generator 512 times to further mix the state before using it.\\n    // Factoring this as a function slows the main generator, so it is just\\n    // unrolled here.  The weyl generator is not advanced while warming up.\\n    i = 127;\\n    for (j = 4 * 128; j > 0; --j) {\\n      v = X[(i + 34) & 127];\\n      t = X[i = ((i + 1) & 127)];\\n      v ^= v << 13;\\n      t ^= t << 17;\\n      v ^= v >>> 15;\\n      t ^= t >>> 12;\\n      X[i] = v ^ t;\\n    }\\n    // Storing state as object members is faster than using closure variables.\\n    me.w = w;\\n    me.X = X;\\n    me.i = i;\\n  }\\n\\n  init(me, seed);\\n}\\n\\nfunction copy(f, t) {\\n  t.i = f.i;\\n  t.w = f.w;\\n  t.X = f.X.slice();\\n  return t;\\n};\\n\\nfunction impl(seed, opts) {\\n  if (seed == null) seed = +(new Date);\\n  var xg = new XorGen(seed),\\n      state = opts && opts.state,\\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\\n  prng.double = function() {\\n    do {\\n      var top = xg.next() >>> 11,\\n          bot = (xg.next() >>> 0) / 0x100000000,\\n          result = (top + bot) / (1 << 21);\\n    } while (result === 0);\\n    return result;\\n  };\\n  prng.int32 = xg.next;\\n  prng.quick = prng;\\n  if (state) {\\n    if (state.X) copy(state, xg);\\n    prng.state = function() { return copy(xg, {}); }\\n  }\\n  return prng;\\n}\\n\\nif (module && module.exports) {\\n  module.exports = impl;\\n} else if (define && define.amd) {\\n  define(function() { return impl; });\\n} else {\\n  this.xor4096 = impl;\\n}\\n\\n})(\\n  this,                                     // window object or global\\n  (typeof module) == 'object' && module,    // present in node.js\\n  (typeof define) == 'function' && define   // present with an AMD loader\\n);\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"define\",\"XorGen\",\"seed\",\"me\",\"next\",\"me.next\",\"w\",\"X\",\"i\",\"v\",\"t\",\"init\",\"j\",\"limit\",\"Math\",\"max\",\"length\",\"charCodeAt\",\"copy\",\"f\",\"slice\",\"impl\",\"opts\",\"Date\",\"xg\",\"state\",\"prng\",\"double\",\"prng.double\",\"top\",\"bot\",\"result\",\"int32\",\"quick\",\"prng.state\",\"amd\",\"xor4096\"]\n}\n"]