["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/RangeNode.js"],"~:js","shadow$provide[267]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createRangeNode=void 0;var q=b(14);c=b(25);var f=b(255);b=(0,c.factory)(\"RangeNode\",[\"Node\"],function(u){function k(p,g,d){if(!(this instanceof k))throw new SyntaxError(\"Constructor must be called with the new operator\");if(!(0,q.isNode)(p))throw new TypeError(\"Node expected\");if(!(0,q.isNode)(g))throw new TypeError(\"Node expected\");if(d&&!(0,q.isNode)(d))throw new TypeError(\"Node expected\");if(3<arguments.length)throw Error(\"Too many arguments\");\nthis.start=p;this.end=g;this.step=d||null}function t(p,g){var d=(0,f.getPrecedence)(p,g),l={},h=(0,f.getPrecedence)(p.start,g);l.start=null!==h&&h<=d||\"all\"===g;p.step&&(h=(0,f.getPrecedence)(p.step,g),l.step=null!==h&&h<=d||\"all\"===g);p=(0,f.getPrecedence)(p.end,g);l.end=null!==p&&p<=d||\"all\"===g;return l}k.prototype=new u.Node;k.prototype.type=\"RangeNode\";k.prototype.isRangeNode=!0;k.prototype.needsEnd=function(){return 0<this.filter(function(p){return(0,q.isSymbolNode)(p)&&\"end\"===p.name}).length};\nk.prototype._compile=function(p,g){var d=p.range,l=this.start._compile(p,g),h=this.end._compile(p,g);if(this.step){var n=this.step._compile(p,g);return function(r,v,C){return d(l(r,v,C),h(r,v,C),n(r,v,C))}}return function(r,v,C){return d(l(r,v,C),h(r,v,C))}};k.prototype.forEach=function(p){p(this.start,\"start\",this);p(this.end,\"end\",this);this.step&&p(this.step,\"step\",this)};k.prototype.map=function(p){return new k(this._ifNode(p(this.start,\"start\",this)),this._ifNode(p(this.end,\"end\",this)),this.step&&\nthis._ifNode(p(this.step,\"step\",this)))};k.prototype.clone=function(){return new k(this.start,this.end,this.step&&this.step)};k.prototype._toString=function(p){var g=t(this,p&&p.parenthesis?p.parenthesis:\"keep\");var d=this.start.toString(p);g.start&&(d=\"(\"+d+\")\");if(this.step){var l=this.step.toString(p);g.step&&(l=\"(\"+l+\")\");d+=\":\"+l}p=this.end.toString(p);g.end&&(p=\"(\"+p+\")\");return d+(\":\"+p)};k.prototype.toJSON=function(){return{mathjs:\"RangeNode\",start:this.start,end:this.end,step:this.step}};\nk.fromJSON=function(p){return new k(p.start,p.end,p.step)};k.prototype.toHTML=function(p){var g=t(this,p&&p.parenthesis?p.parenthesis:\"keep\");var d=this.start.toHTML(p);g.start&&(d='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+d+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e');if(this.step){var l=this.step.toHTML(p);g.step&&(l='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+l+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e');\nd+='\\x3cspan class\\x3d\"math-operator math-range-operator\"\\x3e:\\x3c/span\\x3e'+l}p=this.end.toHTML(p);g.end&&(p='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+p+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e');return d+('\\x3cspan class\\x3d\"math-operator math-range-operator\"\\x3e:\\x3c/span\\x3e'+p)};k.prototype._toTex=function(p){var g=t(this,p&&p.parenthesis?p.parenthesis:\"keep\"),d=this.start.toTex(p);g.start&&(d=\"\\\\left(\".concat(d,\"\\\\right)\"));\nif(this.step){var l=this.step.toTex(p);g.step&&(l=\"\\\\left(\".concat(l,\"\\\\right)\"));d+=\":\"+l}p=this.end.toTex(p);g.end&&(p=\"\\\\left(\".concat(p,\"\\\\right)\"));return d+(\":\"+p)};return k},{isClass:!0,isNode:!0});a.createRangeNode=b}","~:source","shadow$provide[267] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRangeNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nvar createRangeNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!(0, _is.isNode)(start)) throw new TypeError('Node expected');\n    if (!(0, _is.isNode)(end)) throw new TypeError('Node expected');\n    if (step && !(0, _is.isNode)(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return (0, _is.isSymbolNode)(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\n    var parens = {};\n    var startPrecedence = (0, _operators.getPrecedence)(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = (0, _operators.getPrecedence)(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = (0, _operators.getPrecedence)(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createRangeNode = createRangeNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$expression$operators","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createRangeNode","map","forEach","fromJSON","isClass","isRangeNode","toHTML","prototype","_toString","isNode","_toTex","__esModule","value","start","mathjs","type","needsEnd","clone","_compile","end","step","toJSON"]],"~:compiled-at",1619135723968,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$RangeNode.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/RangeNode.js\"],\n\"sourcesContent\":[\"shadow$provide[267] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createRangeNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _operators = require(\\\"../operators.js\\\");\\n\\nvar name = 'RangeNode';\\nvar dependencies = ['Node'];\\nvar createRangeNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Node = _ref.Node;\\n\\n  /**\\n   * @constructor RangeNode\\n   * @extends {Node}\\n   * create a range\\n   * @param {Node} start  included lower-bound\\n   * @param {Node} end    included upper-bound\\n   * @param {Node} [step] optional step\\n   */\\n  function RangeNode(start, end, step) {\\n    if (!(this instanceof RangeNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // validate inputs\\n\\n\\n    if (!(0, _is.isNode)(start)) throw new TypeError('Node expected');\\n    if (!(0, _is.isNode)(end)) throw new TypeError('Node expected');\\n    if (step && !(0, _is.isNode)(step)) throw new TypeError('Node expected');\\n    if (arguments.length > 3) throw new Error('Too many arguments');\\n    this.start = start; // included lower-bound\\n\\n    this.end = end; // included upper-bound\\n\\n    this.step = step || null; // optional step\\n  }\\n\\n  RangeNode.prototype = new Node();\\n  RangeNode.prototype.type = 'RangeNode';\\n  RangeNode.prototype.isRangeNode = true;\\n  /**\\n   * Check whether the RangeNode needs the `end` symbol to be defined.\\n   * This end is the size of the Matrix in current dimension.\\n   * @return {boolean}\\n   */\\n\\n  RangeNode.prototype.needsEnd = function () {\\n    // find all `end` symbols in this RangeNode\\n    var endSymbols = this.filter(function (node) {\\n      return (0, _is.isSymbolNode)(node) && node.name === 'end';\\n    });\\n    return endSymbols.length > 0;\\n  };\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n\\n  RangeNode.prototype._compile = function (math, argNames) {\\n    var range = math.range;\\n\\n    var evalStart = this.start._compile(math, argNames);\\n\\n    var evalEnd = this.end._compile(math, argNames);\\n\\n    if (this.step) {\\n      var evalStep = this.step._compile(math, argNames);\\n\\n      return function evalRangeNode(scope, args, context) {\\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\\n      };\\n    } else {\\n      return function evalRangeNode(scope, args, context) {\\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\\n      };\\n    }\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  RangeNode.prototype.forEach = function (callback) {\\n    callback(this.start, 'start', this);\\n    callback(this.end, 'end', this);\\n\\n    if (this.step) {\\n      callback(this.step, 'step', this);\\n    }\\n  };\\n  /**\\n   * Create a new RangeNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {RangeNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  RangeNode.prototype.map = function (callback) {\\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {RangeNode}\\n   */\\n\\n\\n  RangeNode.prototype.clone = function () {\\n    return new RangeNode(this.start, this.end, this.step && this.step);\\n  };\\n  /**\\n   * Calculate the necessary parentheses\\n   * @param {Node} node\\n   * @param {string} parenthesis\\n   * @return {Object} parentheses\\n   * @private\\n   */\\n\\n\\n  function calculateNecessaryParentheses(node, parenthesis) {\\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\\n    var parens = {};\\n    var startPrecedence = (0, _operators.getPrecedence)(node.start, parenthesis);\\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\\n\\n    if (node.step) {\\n      var stepPrecedence = (0, _operators.getPrecedence)(node.step, parenthesis);\\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\\n    }\\n\\n    var endPrecedence = (0, _operators.getPrecedence)(node.end, parenthesis);\\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\\n    return parens;\\n  }\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RangeNode.prototype._toString = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\\n\\n    var str;\\n    var start = this.start.toString(options);\\n\\n    if (parens.start) {\\n      start = '(' + start + ')';\\n    }\\n\\n    str = start;\\n\\n    if (this.step) {\\n      var step = this.step.toString(options);\\n\\n      if (parens.step) {\\n        step = '(' + step + ')';\\n      }\\n\\n      str += ':' + step;\\n    }\\n\\n    var end = this.end.toString(options);\\n\\n    if (parens.end) {\\n      end = '(' + end + ')';\\n    }\\n\\n    str += ':' + end;\\n    return str;\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  RangeNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'RangeNode',\\n      start: this.start,\\n      end: this.end,\\n      step: this.step\\n    };\\n  };\\n  /**\\n   * Instantiate an RangeNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"RangeNode\\\", \\\"start\\\": ..., \\\"end\\\": ..., \\\"step\\\": ...}`,\\n   *                       where mathjs is optional\\n   * @returns {RangeNode}\\n   */\\n\\n\\n  RangeNode.fromJSON = function (json) {\\n    return new RangeNode(json.start, json.end, json.step);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RangeNode.prototype.toHTML = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\\n\\n    var str;\\n    var start = this.start.toHTML(options);\\n\\n    if (parens.start) {\\n      start = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + start + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    str = start;\\n\\n    if (this.step) {\\n      var step = this.step.toHTML(options);\\n\\n      if (parens.step) {\\n        step = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + step + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n      }\\n\\n      str += '<span class=\\\"math-operator math-range-operator\\\">:</span>' + step;\\n    }\\n\\n    var end = this.end.toHTML(options);\\n\\n    if (parens.end) {\\n      end = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + end + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    str += '<span class=\\\"math-operator math-range-operator\\\">:</span>' + end;\\n    return str;\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @params {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RangeNode.prototype._toTex = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var parens = calculateNecessaryParentheses(this, parenthesis);\\n    var str = this.start.toTex(options);\\n\\n    if (parens.start) {\\n      str = \\\"\\\\\\\\left(\\\".concat(str, \\\"\\\\\\\\right)\\\");\\n    }\\n\\n    if (this.step) {\\n      var step = this.step.toTex(options);\\n\\n      if (parens.step) {\\n        step = \\\"\\\\\\\\left(\\\".concat(step, \\\"\\\\\\\\right)\\\");\\n      }\\n\\n      str += ':' + step;\\n    }\\n\\n    var end = this.end.toTex(options);\\n\\n    if (parens.end) {\\n      end = \\\"\\\\\\\\left(\\\".concat(end, \\\"\\\\\\\\right)\\\");\\n    }\\n\\n    str += ':' + end;\\n    return str;\\n  };\\n\\n  return RangeNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createRangeNode = createRangeNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createRangeNode\",\"_is\",\"_factory\",\"_operators\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"RangeNode\",\"start\",\"end\",\"step\",\"SyntaxError\",\"isNode\",\"TypeError\",\"arguments\",\"length\",\"Error\",\"calculateNecessaryParentheses\",\"node\",\"parenthesis\",\"precedence\",\"getPrecedence\",\"parens\",\"startPrecedence\",\"stepPrecedence\",\"endPrecedence\",\"prototype\",\"Node\",\"type\",\"isRangeNode\",\"needsEnd\",\"RangeNode.prototype.needsEnd\",\"filter\",\"endSymbols\",\"isSymbolNode\",\"_compile\",\"RangeNode.prototype._compile\",\"math\",\"argNames\",\"range\",\"evalStart\",\"evalEnd\",\"evalStep\",\"evalRangeNode\",\"scope\",\"args\",\"context\",\"forEach\",\"RangeNode.prototype.forEach\",\"callback\",\"map\",\"RangeNode.prototype.map\",\"_ifNode\",\"clone\",\"RangeNode.prototype.clone\",\"_toString\",\"RangeNode.prototype._toString\",\"options\",\"toString\",\"str\",\"toJSON\",\"RangeNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"RangeNode.fromJSON\",\"json\",\"toHTML\",\"RangeNode.prototype.toHTML\",\"_toTex\",\"RangeNode.prototype._toTex\",\"toTex\",\"concat\",\"isClass\"]\n}\n"]