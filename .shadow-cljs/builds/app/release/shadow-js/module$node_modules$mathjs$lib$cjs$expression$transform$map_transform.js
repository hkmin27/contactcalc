["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/transform/map.transform.js"],"~:js","shadow$provide[580]=function(c,b,y,a){function q(p,g,d){function l(n,r){return Array.isArray(n)?(0,k.map)(n,function(v,C){return l(v,r.concat(C+1))}):1===h?g(n):2===h?g(n,r):g(n,r,d)}var h=(0,u.maxArgumentCount)(g);return l(p,[])}Object.defineProperty(a,\"__esModule\",{value:!0});a.createMapTransform=void 0;var f=b(14),u=b(127),k=b(24);c=b(25);var t=b(576);b=(0,c.factory)(\"map\",[\"typed\"],function(p){function g(l,h,n){var r,v;l[0]&&(r=l[0].compile().evaluate(n));l[1]&&(v=(0,f.isSymbolNode)(l[1])||(0,\nf.isFunctionAssignmentNode)(l[1])?l[1].compile().evaluate(n):(0,t.compileInlineExpression)(l[1],h,n));return d(r,v)}p=p.typed;g.rawArgs=!0;var d=p(\"map\",{\"Array, function\":function(l,h){return q(l,h,l)},\"Matrix, function\":function(l,h){return l.create(q(l.valueOf(),h,l))}});return g},{isTransformFunction:!0});a.createMapTransform=b}","~:source","shadow$provide[580] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMapTransform = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _function = require(\"../../utils/function.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _compileInlineExpression = require(\"./utils/compileInlineExpression.js\");\n\nvar name = 'map';\nvar dependencies = ['typed'];\nvar createMapTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  function mapTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().evaluate(scope);\n    }\n\n    if (args[1]) {\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().evaluate(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\n      }\n    }\n\n    return map(x, callback);\n  }\n\n  mapTransform.rawArgs = true; // one-based version of map function\n\n  var map = typed('map', {\n    'Array, function': function ArrayFunction(x, callback) {\n      return _map(x, callback, x);\n    },\n    'Matrix, function': function MatrixFunction(x, callback) {\n      return x.create(_map(x.valueOf(), callback, x));\n    }\n  });\n  return mapTransform;\n}, {\n  isTransformFunction: true\n});\n/**\n * Map for a multi dimensional array. One-based indexes\n * @param {Array} array\n * @param {function} callback\n * @param {Array} orig\n * @return {Array}\n * @private\n */\n\nexports.createMapTransform = createMapTransform;\n\nfunction _map(array, callback, orig) {\n  // figure out what number of arguments the callback function expects\n  var argsCount = (0, _function.maxArgumentCount)(callback);\n\n  function recurse(value, index) {\n    if (Array.isArray(value)) {\n      return (0, _array.map)(value, function (child, i) {\n        // we create a copy of the index array and append the new index value\n        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1\n      });\n    } else {\n      // invoke the (typed) callback function with the right number of arguments\n      if (argsCount === 1) {\n        return callback(value);\n      } else if (argsCount === 2) {\n        return callback(value, index);\n      } else {\n        // 3 or -1\n        return callback(value, index, orig);\n      }\n    }\n  }\n\n  return recurse(array, []);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$expression$transform$utils$compileInlineExpression","~$module$node_modules$mathjs$lib$cjs$utils$function"]],"~:properties",["^5",["rawArgs","createMapTransform","__esModule","isTransformFunction","value"]],"~:compiled-at",1619135724042,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$transform$map_transform.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/transform/map.transform.js\"],\n\"sourcesContent\":[\"shadow$provide[580] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createMapTransform = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _function = require(\\\"../../utils/function.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _compileInlineExpression = require(\\\"./utils/compileInlineExpression.js\\\");\\n\\nvar name = 'map';\\nvar dependencies = ['typed'];\\nvar createMapTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed;\\n\\n  /**\\n   * Attach a transform function to math.map\\n   * Adds a property transform containing the transform function.\\n   *\\n   * This transform creates a one-based index instead of a zero-based index\\n   */\\n  function mapTransform(args, math, scope) {\\n    var x, callback;\\n\\n    if (args[0]) {\\n      x = args[0].compile().evaluate(scope);\\n    }\\n\\n    if (args[1]) {\\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\\n        callback = args[1].compile().evaluate(scope);\\n      } else {\\n        // an expression like filter([3, -2, 5], x > 0)\\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\\n      }\\n    }\\n\\n    return map(x, callback);\\n  }\\n\\n  mapTransform.rawArgs = true; // one-based version of map function\\n\\n  var map = typed('map', {\\n    'Array, function': function ArrayFunction(x, callback) {\\n      return _map(x, callback, x);\\n    },\\n    'Matrix, function': function MatrixFunction(x, callback) {\\n      return x.create(_map(x.valueOf(), callback, x));\\n    }\\n  });\\n  return mapTransform;\\n}, {\\n  isTransformFunction: true\\n});\\n/**\\n * Map for a multi dimensional array. One-based indexes\\n * @param {Array} array\\n * @param {function} callback\\n * @param {Array} orig\\n * @return {Array}\\n * @private\\n */\\n\\nexports.createMapTransform = createMapTransform;\\n\\nfunction _map(array, callback, orig) {\\n  // figure out what number of arguments the callback function expects\\n  var argsCount = (0, _function.maxArgumentCount)(callback);\\n\\n  function recurse(value, index) {\\n    if (Array.isArray(value)) {\\n      return (0, _array.map)(value, function (child, i) {\\n        // we create a copy of the index array and append the new index value\\n        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1\\n      });\\n    } else {\\n      // invoke the (typed) callback function with the right number of arguments\\n      if (argsCount === 1) {\\n        return callback(value);\\n      } else if (argsCount === 2) {\\n        return callback(value, index);\\n      } else {\\n        // 3 or -1\\n        return callback(value, index, orig);\\n      }\\n    }\\n  }\\n\\n  return recurse(array, []);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_map\",\"array\",\"callback\",\"orig\",\"recurse\",\"value\",\"index\",\"Array\",\"isArray\",\"_array\",\"map\",\"child\",\"i\",\"concat\",\"argsCount\",\"_function\",\"maxArgumentCount\",\"Object\",\"defineProperty\",\"createMapTransform\",\"_is\",\"_factory\",\"_compileInlineExpression\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"mapTransform\",\"args\",\"math\",\"scope\",\"x\",\"compile\",\"evaluate\",\"isSymbolNode\",\"isFunctionAssignmentNode\",\"compileInlineExpression\",\"typed\",\"rawArgs\",\"ArrayFunction\",\"MatrixFunction\",\"create\",\"valueOf\",\"isTransformFunction\"]\n}\n"]