["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/typed-function/typed-function.js"],"~:js","shadow$provide[18]=function(c,b,y,a){(function(q,f){\"function\"===typeof define&&define.amd?define([],f):\"object\"===typeof a?y.exports=f():q.typed=f()})(this,function(){function q(){return!0}function f(){return!1}function u(){}function k(){function t(ja){var na=ka(da.types,function(la){return la.name===ja});if(na)return na;if(\"any\"===ja)return Ka;na=ka(da.types,function(la){return la.name.toLowerCase()===ja.toLowerCase()});throw new TypeError('Unknown type \"'+ja+'\"'+(na?'. Did you mean \"'+na.name+\n'\"?':\"\"));}function p(ja){var na=ka(da.types,function(la){return la.test(ja)});if(na)return na.name;throw new TypeError(\"Value has unknown type. Value: \"+ja);}function g(ja){return ja.map(function(na){var la=na.types.map(w);return(na.restParam?\"...\":\"\")+la.join(\"|\")}).join(\",\")}function d(ja,na){var la=0===ja.indexOf(\"...\"),ta=(la?3<ja.length?ja.slice(3):\"any\":ja).split(\"|\").map(Q).filter(T).filter(ba);ja=I(na,ta);ta=ta.map(function(Fa){var Sa=t(Fa);return{name:Fa,typeIndex:Sa===Ka?999:da.types.indexOf(Sa),\ntest:Sa.test,conversion:null,conversionIndex:-1}});ja=ja.map(function(Fa){var Sa=t(Fa.from);return{name:Fa.from,typeIndex:Sa===Ka?999:da.types.indexOf(Sa),test:Sa.test,conversion:Fa,conversionIndex:na.indexOf(Fa)}});return{types:ta.concat(ja),restParam:la}}function l(ja,na,la){var ta=[];\"\"!==ja.trim()&&(ta=ja.split(\",\").map(Q).map(function(Fa,Sa,Qa){var Ua=d(Fa,la);if(Ua.restParam&&Sa!==Qa.length-1)throw new SyntaxError('Unexpected rest parameter \"'+Fa+'\": only allowed for the last parameter');return Ua}));\nreturn ta.some(ca)?null:{params:ta,fn:na}}function h(ja){return(ja=ja[ja.length-1])?ja.restParam:!1}function n(ja){return ja.types.some(function(na){return null!=na.conversion})}function r(ja){if(ja&&0!==ja.types.length){if(1===ja.types.length)return t(ja.types[0].name).test;if(2===ja.types.length){var na=t(ja.types[0].name).test,la=t(ja.types[1].name).test;return function(Fa){return na(Fa)||la(Fa)}}var ta=ja.types.map(function(Fa){return t(Fa.name).test});return function(Fa){for(var Sa=0;Sa<ta.length;Sa++)if(ta[Sa](Fa))return!0;\nreturn!1}}return q}function v(ja){if(h(ja)){var na=ja.slice(0,ja.length-1).map(r);var la=na.length,ta=r(ja[ja.length-1]);return function(Qa){for(var Ua=0;Ua<na.length;Ua++)if(!na[Ua](Qa[Ua]))return!1;a:{for(Ua=la;Ua<Qa.length;Ua++)if(!ta(Qa[Ua])){Ua=!1;break a}Ua=!0}return Ua&&Qa.length>=la+1}}if(0===ja.length)return function(Qa){return 0===Qa.length};if(1===ja.length){var Fa=r(ja[0]);return function(Qa){return Fa(Qa[0])&&1===Qa.length}}if(2===ja.length){Fa=r(ja[0]);var Sa=r(ja[1]);return function(Qa){return Fa(Qa[0])&&\nSa(Qa[1])&&2===Qa.length}}na=ja.map(r);return function(Qa){for(var Ua=0;Ua<na.length;Ua++)if(!na[Ua](Qa[Ua]))return!1;return Qa.length===na.length}}function C(ja,na){na<ja.params.length?ja=ja.params[na]:h(ja.params)?(ja=ja.params,ja=ja[ja.length-1]):ja=null;return ja}function z(ja,na,la){ja=C(ja,na);return(ja?la?ja.types.filter(B):ja.types:[]).map(w)}function w(ja){return ja.name}function B(ja){return null===ja.conversion||void 0===ja.conversion}function x(ja,na){ja=ha(wa(ja,function(la){return z(la,\nna,!1)}));return-1!==ja.indexOf(\"any\")?[\"any\"]:ja}function D(ja,na,la){ja=ja||\"unnamed\";var ta;for(ta=0;ta<na.length;ta++){var Fa=la.filter(function(Qa){var Ua=r(C(Qa,ta));return(ta<Qa.params.length||h(Qa.params))&&Ua(na[ta])});if(0===Fa.length){if(Fa=x(la,ta),0<Fa.length){var Sa=p(na[ta]);la=new TypeError(\"Unexpected type of argument in function \"+ja+\" (expected: \"+Fa.join(\" or \")+\", actual: \"+Sa+\", index: \"+ta+\")\");la.data={category:\"wrongType\",fn:ja,index:ta,actual:Sa,expected:Fa};return la}}else la=\nFa}Fa=la.map(function(Qa){return h(Qa.params)?Infinity:Qa.params.length});if(na.length<Math.min.apply(null,Fa))return Fa=x(la,ta),la=new TypeError(\"Too few arguments in function \"+ja+\" (expected: \"+Fa.join(\" or \")+\", index: \"+na.length+\")\"),la.data={category:\"tooFewArgs\",fn:ja,index:na.length,expected:Fa},la;Fa=Math.max.apply(null,Fa);if(na.length>Fa)return la=new TypeError(\"Too many arguments in function \"+ja+\" (expected: \"+Fa+\", actual: \"+na.length+\")\"),la.data={category:\"tooManyArgs\",fn:ja,index:na.length,\nexpectedLength:Fa},la;la=new TypeError('Arguments of type \"'+na.join(\", \")+'\" do not match any of the defined signatures of function '+ja+\".\");la.data={category:\"mismatch\",actual:na.map(p)};return la}function F(ja){for(var na=999,la=0;la<ja.types.length;la++)B(ja.types[la])&&(na=Math.min(na,ja.types[la].typeIndex));return na}function E(ja){for(var na=999,la=0;la<ja.types.length;la++)B(ja.types[la])||(na=Math.min(na,ja.types[la].conversionIndex));return na}function G(ja,na){var la=Math.min(ja.params.length,\nna.params.length),ta;var Fa=ja.params.some(n)-na.params.some(n);if(0!==Fa)return Fa;for(ta=0;ta<la;ta++)if(Fa=n(ja.params[ta])-n(na.params[ta]),0!==Fa)return Fa;for(ta=0;ta<la;ta++){var Sa=ja.params[ta],Qa=na.params[ta];Fa=Sa.restParam-Qa.restParam;0===Fa&&(Fa=n(Sa)-n(Qa),0===Fa&&(Fa=F(Sa)-F(Qa),Fa=0!==Fa?Fa:E(Sa)-E(Qa)));if(0!==Fa)return Fa}return ja.params.length-na.params.length}function I(ja,na){var la={};ja.forEach(function(ta){-1!==na.indexOf(ta.from)||-1===na.indexOf(ta.to)||la[ta.from]||(la[ta.from]=\nta)});return Object.keys(la).map(function(ta){return la[ta]})}function L(ja,na){var la=na;if(ja.some(n)){var ta=h(ja),Fa=ja.map(M);la=function(){for(var Ua=[],ea=ta?arguments.length-1:arguments.length,qa=0;qa<ea;qa++)Ua[qa]=Fa[qa](arguments[qa]);ta&&(Ua[ea]=arguments[ea].map(Fa[ea]));return na.apply(this,Ua)}}var Sa=la;if(h(ja)){var Qa=ja.length-1;Sa=function(){return la.apply(this,Array.prototype.slice.call(arguments,0,Qa).concat([Array.prototype.slice.call(arguments,Qa,void 0)]))}}return Sa}function M(ja){var na=\n[],la=[];ja.types.forEach(function(Ua){Ua.conversion&&(na.push(t(Ua.conversion.from).test),la.push(Ua.conversion.convert))});switch(la.length){case 0:return function(Ua){return Ua};case 1:var ta=na[0];var Fa=la[0];return function(Ua){return ta(Ua)?Fa(Ua):Ua};case 2:ta=na[0];var Sa=na[1];Fa=la[0];var Qa=la[1];return function(Ua){return ta(Ua)?Fa(Ua):Sa(Ua)?Qa(Ua):Ua};default:return function(Ua){for(var ea=0;ea<la.length;ea++)if(na[ea](Ua))return la[ea](Ua);return Ua}}}function S(ja){var na={};ja.forEach(function(la){la.params.some(n)||\nP(la.params,!0).forEach(function(ta){na[g(ta)]=la.fn})});return na}function P(ja,na){function la(ta,Fa,Sa){if(Fa<ta.length){var Qa=ta[Fa],Ua=na?Qa.types.filter(B):Qa.types;Qa.restParam?(Qa=Ua.filter(B),Ua=Qa.length<Ua.length?[Qa,Ua]:[Ua]):Ua=Ua.map(function(ea){return[ea]});return wa(Ua,function(ea){return la(ta,Fa+1,Sa.concat([ea]))})}return[Sa.map(function(ea,qa){return{types:ea,restParam:qa===ta.length-1&&h(ta)}})]}return la(ja,0,[])}function R(ja,na){if(0===Object.keys(na).length)throw new SyntaxError(\"No signatures provided\");\nvar la=[];Object.keys(na).map(function(V){return l(V,na[V],da.conversions)}).filter(Y).forEach(function(V){var X=ka(la,function(aa){a:{for(var sa=Math.max(aa.params.length,V.params.length),ua=0;ua<sa;ua++){var Aa=z(aa,ua,!0),Ba=z(V,ua,!0);b:{for(var Ga=0;Ga<Aa.length;Ga++)if(-1!==Ba.indexOf(Aa[Ga])){Aa=!0;break b}Aa=!1}if(!Aa){aa=!1;break a}}sa=aa.params.length;ua=V.params.length;aa=h(aa.params);Aa=h(V.params);aa=aa?Aa?sa===ua:ua>=sa:Aa?sa>=ua:sa===ua}return aa});if(X)throw new TypeError('Conflicting signatures \"'+\ng(X.params)+'\" and \"'+g(V.params)+'\".');la.push(V)});var ta=wa(la,function(V){return(V?P(V.params,!1):[]).map(function(X){return{params:X,fn:V.fn}})}).filter(Y);ta.sort(G);var Fa=ta[0]&&2>=ta[0].params.length&&!h(ta[0].params),Sa=ta[1]&&2>=ta[1].params.length&&!h(ta[1].params),Qa=ta[2]&&2>=ta[2].params.length&&!h(ta[2].params),Ua=ta[3]&&2>=ta[3].params.length&&!h(ta[3].params),ea=ta[4]&&2>=ta[4].params.length&&!h(ta[4].params),qa=ta[5]&&2>=ta[5].params.length&&!h(ta[5].params),ya=Fa&&Sa&&Qa&&Ua&&\nea&&qa,Da=ta.map(function(V){return v(V.params)}),Ea=Fa?r(ta[0].params[0]):f,ab=Sa?r(ta[1].params[0]):f,fb=Qa?r(ta[2].params[0]):f,hb=Ua?r(ta[3].params[0]):f,gb=ea?r(ta[4].params[0]):f,O=qa?r(ta[5].params[0]):f,ma=Fa?r(ta[0].params[1]):f,Ja=Sa?r(ta[1].params[1]):f,Ta=Qa?r(ta[2].params[1]):f,lb=Ua?r(ta[3].params[1]):f,Ub=ea?r(ta[4].params[1]):f,Ib=qa?r(ta[5].params[1]):f,Xa=ta.map(function(V){return L(V.params,V.fn)}),yb=Fa?Xa[0]:u,rb=Sa?Xa[1]:u,oc=Qa?Xa[2]:u,xc=Ua?Xa[3]:u,Rb=ea?Xa[4]:u,$c=qa?Xa[5]:\nu,ad=Fa?ta[0].params.length:-1,Xb=Sa?ta[1].params.length:-1,La=Qa?ta[2].params.length:-1,ob=Ua?ta[3].params.length:-1,zb=ea?ta[4].params.length:-1,yc=qa?ta[5].params.length:-1,J=ya?6:0,N=ta.length,W=function(){for(var V=J;V<N;V++)if(Da[V](arguments))return Xa[V].apply(this,arguments);throw D(ja,arguments,ta);};Fa=function sa(X,aa){return arguments.length===ad&&Ea(X)&&ma(aa)?yb.apply(sa,arguments):arguments.length===Xb&&ab(X)&&Ja(aa)?rb.apply(sa,arguments):arguments.length===La&&fb(X)&&Ta(aa)?oc.apply(sa,\narguments):arguments.length===ob&&hb(X)&&lb(aa)?xc.apply(sa,arguments):arguments.length===zb&&gb(X)&&Ub(aa)?Rb.apply(sa,arguments):arguments.length===yc&&O(X)&&Ib(aa)?$c.apply(sa,arguments):W.apply(sa,arguments)};try{Object.defineProperty(Fa,\"name\",{value:ja})}catch(X){}Fa.signatures=S(ta);return Fa}function ba(ja){return-1===da.ignore.indexOf(ja)}function Q(ja){return ja.trim()}function T(ja){return!!ja}function Y(ja){return null!==ja}function ca(ja){return 0===ja.types.length}function ka(ja,na){for(var la=\n0;la<ja.length;la++)if(na(ja[la]))return ja[la]}function ha(ja){for(var na={},la=0;la<ja.length;la++)na[ja[la]]=!0;return Object.keys(na)}function wa(ja,na){return Array.prototype.concat.apply([],ja.map(na))}function Ia(ja){for(var na=\"\",la=0;la<ja.length;la++){var ta=ja[la];if((\"object\"===typeof ta.signatures||\"string\"===typeof ta.signature)&&\"\"!==ta.name)if(\"\"===na)na=ta.name;else if(na!==ta.name)throw ja=Error(\"Function names do not match (expected: \"+na+\", actual: \"+ta.name+\")\"),ja.data={actual:ta.name,\nexpected:na},ja;}return na}function Ha(ja){function na(Ua,ea){if(ta.hasOwnProperty(Ua)&&ea!==ta[Ua])throw la=Error('Signature \"'+Ua+'\" is defined twice'),la.data={signature:Ua},la;}for(var la,ta={},Fa=0;Fa<ja.length;Fa++){var Sa=ja[Fa];if(\"object\"===typeof Sa.signatures)for(var Qa in Sa.signatures)Sa.signatures.hasOwnProperty(Qa)&&(na(Qa,Sa.signatures[Qa]),ta[Qa]=Sa.signatures[Qa]);else if(\"string\"===typeof Sa.signature)na(Sa.signature,Sa),ta[Sa.signature]=Sa;else throw la=new TypeError(\"Function is no typed-function (index: \"+\nFa+\")\"),la.data={index:Fa},la;}return ta}var oa=[{name:\"number\",test:function(ja){return\"number\"===typeof ja}},{name:\"string\",test:function(ja){return\"string\"===typeof ja}},{name:\"boolean\",test:function(ja){return\"boolean\"===typeof ja}},{name:\"Function\",test:function(ja){return\"function\"===typeof ja}},{name:\"Array\",test:Array.isArray},{name:\"Date\",test:function(ja){return ja instanceof Date}},{name:\"RegExp\",test:function(ja){return ja instanceof RegExp}},{name:\"Object\",test:function(ja){return\"object\"===\ntypeof ja&&null!==ja&&ja.constructor===Object}},{name:\"null\",test:function(ja){return null===ja}},{name:\"undefined\",test:function(ja){return void 0===ja}}],Ka={name:\"any\",test:q},fa=[],va=[],da={types:oa,conversions:va,ignore:fa};da=R(\"typed\",{\"string, Object\":R,Object:function(ja){var na=[],la;for(la in ja)ja.hasOwnProperty(la)&&na.push(ja[la]);na=Ia(na);return R(na,ja)},\"...Function\":function(ja){return R(Ia(ja),Ha(ja))},\"string, ...Function\":function(ja,na){return R(ja,Ha(na))}});da.create=k;da.types=\noa;da.conversions=va;da.ignore=fa;da.convert=function(ja,na){var la=p(ja);if(na===la)return ja;for(var ta=0;ta<da.conversions.length;ta++){var Fa=da.conversions[ta];if(Fa.from===la&&Fa.to===na)return Fa.convert(ja)}throw Error(\"Cannot convert from \"+la+\" to \"+na);};da.find=function(ja,na){if(!ja.signatures)throw new TypeError(\"Function is no typed-function\");if(\"string\"===typeof na){na=na.split(\",\");for(var la=0;la<na.length;la++)na[la]=na[la].trim()}else if(!Array.isArray(na))throw new TypeError(\"String array or a comma separated string expected\");\nla=na.join(\",\");if(la=ja.signatures[la])return la;throw new TypeError(\"Signature not found (signature: \"+(ja.name||\"unnamed\")+\"(\"+na.join(\", \")+\"))\");};da.addType=function(ja,na){if(!ja||\"string\"!==typeof ja.name||\"function\"!==typeof ja.test)throw new TypeError(\"Object with properties {name: string, test: function} expected\");if(!1!==na)for(na=0;na<da.types.length;na++)if(\"Object\"===da.types[na].name){da.types.splice(na,0,ja);return}da.types.push(ja)};da.addConversion=function(ja){if(!ja||\"string\"!==\ntypeof ja.from||\"string\"!==typeof ja.to||\"function\"!==typeof ja.convert)throw new TypeError(\"Object with properties {from: string, to: string, convert: function} expected\");da.conversions.push(ja)};return da}return k()})}","~:source","shadow$provide[18] = function(global,require,module,exports) {\n/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(this, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(this,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }\n\n        return generic.apply(fn, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["ignore","typed","conversion","index","find","params","signatures","expectedLength","convert","fn","conversions","types","typeIndex","expected","name","value","restParam","signature","addConversion","create","conversionIndex","category","actual","data","test","addType"]],"~:compiled-at",1619135723710,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$typed_function$typed_function.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/typed-function/typed-function.js\"],\n\"sourcesContent\":[\"shadow$provide[18] = function(global,require,module,exports) {\\n/**\\n * typed-function\\n *\\n * Type checking for JavaScript functions\\n *\\n * https://github.com/josdejong/typed-function\\n */\\n'use strict';\\n\\n(function (root, factory) {\\n  if (typeof define === 'function' && define.amd) {\\n    // AMD. Register as an anonymous module.\\n    define([], factory);\\n  } else if (typeof exports === 'object') {\\n    // OldNode. Does not work with strict CommonJS, but\\n    // only CommonJS-like environments that support module.exports,\\n    // like OldNode.\\n    module.exports = factory();\\n  } else {\\n    // Browser globals (root is window)\\n    root.typed = factory();\\n  }\\n}(this, function () {\\n\\n  function ok () {\\n    return true;\\n  }\\n\\n  function notOk () {\\n    return false;\\n  }\\n\\n  function undef () {\\n    return undefined;\\n  }\\n\\n  /**\\n   * @typedef {{\\n   *   params: Param[],\\n   *   fn: function\\n   * }} Signature\\n   *\\n   * @typedef {{\\n   *   types: Type[],\\n   *   restParam: boolean\\n   * }} Param\\n   *\\n   * @typedef {{\\n   *   name: string,\\n   *   typeIndex: number,\\n   *   test: function,\\n   *   conversion?: ConversionDef,\\n   *   conversionIndex: number,\\n   * }} Type\\n   *\\n   * @typedef {{\\n   *   from: string,\\n   *   to: string,\\n   *   convert: function (*) : *\\n   * }} ConversionDef\\n   *\\n   * @typedef {{\\n   *   name: string,\\n   *   test: function(*) : boolean\\n   * }} TypeDef\\n   */\\n\\n  // create a new instance of typed-function\\n  function create () {\\n    // data type tests\\n    var _types = [\\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\\n      { name: 'Array',     test: Array.isArray },\\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\\n      { name: 'Object',    test: function (x) {\\n        return typeof x === 'object' && x !== null && x.constructor === Object\\n      }},\\n      { name: 'null',      test: function (x) { return x === null } },\\n      { name: 'undefined', test: function (x) { return x === undefined } }\\n    ];\\n\\n    var anyType = {\\n      name: 'any',\\n      test: ok\\n    }\\n\\n    // types which need to be ignored\\n    var _ignore = [];\\n\\n    // type conversions\\n    var _conversions = [];\\n\\n    // This is a temporary object, will be replaced with a typed function at the end\\n    var typed = {\\n      types: _types,\\n      conversions: _conversions,\\n      ignore: _ignore\\n    };\\n\\n    /**\\n     * Find the test function for a type\\n     * @param {String} typeName\\n     * @return {TypeDef} Returns the type definition when found,\\n     *                    Throws a TypeError otherwise\\n     */\\n    function findTypeByName (typeName) {\\n      var entry = findInArray(typed.types, function (entry) {\\n        return entry.name === typeName;\\n      });\\n\\n      if (entry) {\\n        return entry;\\n      }\\n\\n      if (typeName === 'any') { // special baked-in case 'any'\\n        return anyType;\\n      }\\n\\n      var hint = findInArray(typed.types, function (entry) {\\n        return entry.name.toLowerCase() === typeName.toLowerCase();\\n      });\\n\\n      throw new TypeError('Unknown type \\\"' + typeName + '\\\"' +\\n          (hint ? ('. Did you mean \\\"' + hint.name + '\\\"?') : ''));\\n    }\\n\\n    /**\\n     * Find the index of a type definition. Handles special case 'any'\\n     * @param {TypeDef} type\\n     * @return {number}\\n     */\\n    function findTypeIndex(type) {\\n      if (type === anyType) {\\n        return 999;\\n      }\\n\\n      return typed.types.indexOf(type);\\n    }\\n\\n    /**\\n     * Find a type that matches a value.\\n     * @param {*} value\\n     * @return {string} Returns the name of the first type for which\\n     *                  the type test matches the value.\\n     */\\n    function findTypeName(value) {\\n      var entry = findInArray(typed.types, function (entry) {\\n        return entry.test(value);\\n      });\\n\\n      if (entry) {\\n        return entry.name;\\n      }\\n\\n      throw new TypeError('Value has unknown type. Value: ' + value);\\n    }\\n\\n    /**\\n     * Find a specific signature from a (composed) typed function, for example:\\n     *\\n     *   typed.find(fn, ['number', 'string'])\\n     *   typed.find(fn, 'number, string')\\n     *\\n     * Function find only only works for exact matches.\\n     *\\n     * @param {Function} fn                   A typed-function\\n     * @param {string | string[]} signature   Signature to be found, can be\\n     *                                        an array or a comma separated string.\\n     * @return {Function}                     Returns the matching signature, or\\n     *                                        throws an error when no signature\\n     *                                        is found.\\n     */\\n    function find (fn, signature) {\\n      if (!fn.signatures) {\\n        throw new TypeError('Function is no typed-function');\\n      }\\n\\n      // normalize input\\n      var arr;\\n      if (typeof signature === 'string') {\\n        arr = signature.split(',');\\n        for (var i = 0; i < arr.length; i++) {\\n          arr[i] = arr[i].trim();\\n        }\\n      }\\n      else if (Array.isArray(signature)) {\\n        arr = signature;\\n      }\\n      else {\\n        throw new TypeError('String array or a comma separated string expected');\\n      }\\n\\n      var str = arr.join(',');\\n\\n      // find an exact match\\n      var match = fn.signatures[str];\\n      if (match) {\\n        return match;\\n      }\\n\\n      // TODO: extend find to match non-exact signatures\\n\\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\\n    }\\n\\n    /**\\n     * Convert a given value to another data type.\\n     * @param {*} value\\n     * @param {string} type\\n     */\\n    function convert (value, type) {\\n      var from = findTypeName(value);\\n\\n      // check conversion is needed\\n      if (type === from) {\\n        return value;\\n      }\\n\\n      for (var i = 0; i < typed.conversions.length; i++) {\\n        var conversion = typed.conversions[i];\\n        if (conversion.from === from && conversion.to === type) {\\n          return conversion.convert(value);\\n        }\\n      }\\n\\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\\n    }\\n    \\n    /**\\n     * Stringify parameters in a normalized way\\n     * @param {Param[]} params\\n     * @return {string}\\n     */\\n    function stringifyParams (params) {\\n      return params\\n          .map(function (param) {\\n            var typeNames = param.types.map(getTypeName);\\n\\n            return (param.restParam ? '...' : '') + typeNames.join('|');\\n          })\\n          .join(',');\\n    }\\n\\n    /**\\n     * Parse a parameter, like \\\"...number | boolean\\\"\\n     * @param {string} param\\n     * @param {ConversionDef[]} conversions\\n     * @return {Param} param\\n     */\\n    function parseParam (param, conversions) {\\n      var restParam = param.indexOf('...') === 0;\\n      var types = (!restParam)\\n          ? param\\n          : (param.length > 3)\\n              ? param.slice(3)\\n              : 'any';\\n\\n      var typeNames = types.split('|').map(trim)\\n          .filter(notEmpty)\\n          .filter(notIgnore);\\n\\n      var matchingConversions = filterConversions(conversions, typeNames);\\n\\n      var exactTypes = typeNames.map(function (typeName) {\\n        var type = findTypeByName(typeName);\\n\\n        return {\\n          name: typeName,\\n          typeIndex: findTypeIndex(type),\\n          test: type.test,\\n          conversion: null,\\n          conversionIndex: -1\\n        };\\n      });\\n\\n      var convertibleTypes = matchingConversions.map(function (conversion) {\\n        var type = findTypeByName(conversion.from);\\n\\n        return {\\n          name: conversion.from,\\n          typeIndex: findTypeIndex(type),\\n          test: type.test,\\n          conversion: conversion,\\n          conversionIndex: conversions.indexOf(conversion)\\n        };\\n      });\\n\\n      return {\\n        types: exactTypes.concat(convertibleTypes),\\n        restParam: restParam\\n      };\\n    }\\n\\n    /**\\n     * Parse a signature with comma separated parameters,\\n     * like \\\"number | boolean, ...string\\\"\\n     * @param {string} signature\\n     * @param {function} fn\\n     * @param {ConversionDef[]} conversions\\n     * @return {Signature | null} signature\\n     */\\n    function parseSignature (signature, fn, conversions) {\\n      var params = [];\\n\\n      if (signature.trim() !== '') {\\n        params = signature\\n            .split(',')\\n            .map(trim)\\n            .map(function (param, index, array) {\\n              var parsedParam = parseParam(param, conversions);\\n\\n              if (parsedParam.restParam && (index !== array.length - 1)) {\\n                throw new SyntaxError('Unexpected rest parameter \\\"' + param + '\\\": ' +\\n                    'only allowed for the last parameter');\\n              }\\n\\n              return parsedParam;\\n          });\\n      }\\n\\n      if (params.some(isInvalidParam)) {\\n        // invalid signature: at least one parameter has no types\\n        // (they may have been filtered)\\n        return null;\\n      }\\n\\n      return {\\n        params: params,\\n        fn: fn\\n      };\\n    }\\n\\n    /**\\n     * Test whether a set of params contains a restParam\\n     * @param {Param[]} params\\n     * @return {boolean} Returns true when the last parameter is a restParam\\n     */\\n    function hasRestParam(params) {\\n      var param = last(params)\\n      return param ? param.restParam : false;\\n    }\\n\\n    /**\\n     * Test whether a parameter contains conversions\\n     * @param {Param} param\\n     * @return {boolean} Returns true when at least one of the parameters\\n     *                   contains a conversion.\\n     */\\n    function hasConversions(param) {\\n      return param.types.some(function (type) {\\n        return type.conversion != null;\\n      });\\n    }\\n\\n    /**\\n     * Create a type test for a single parameter, which can have one or multiple\\n     * types.\\n     * @param {Param} param\\n     * @return {function(x: *) : boolean} Returns a test function\\n     */\\n    function compileTest(param) {\\n      if (!param || param.types.length === 0) {\\n        // nothing to do\\n        return ok;\\n      }\\n      else if (param.types.length === 1) {\\n        return findTypeByName(param.types[0].name).test;\\n      }\\n      else if (param.types.length === 2) {\\n        var test0 = findTypeByName(param.types[0].name).test;\\n        var test1 = findTypeByName(param.types[1].name).test;\\n        return function or(x) {\\n          return test0(x) || test1(x);\\n        }\\n      }\\n      else { // param.types.length > 2\\n        var tests = param.types.map(function (type) {\\n          return findTypeByName(type.name).test;\\n        })\\n        return function or(x) {\\n          for (var i = 0; i < tests.length; i++) {\\n            if (tests[i](x)) {\\n              return true;\\n            }\\n          }\\n          return false;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Create a test for all parameters of a signature\\n     * @param {Param[]} params\\n     * @return {function(args: Array<*>) : boolean}\\n     */\\n    function compileTests(params) {\\n      var tests, test0, test1;\\n\\n      if (hasRestParam(params)) {\\n        // variable arguments like '...number'\\n        tests = initial(params).map(compileTest);\\n        var varIndex = tests.length;\\n        var lastTest = compileTest(last(params));\\n        var testRestParam = function (args) {\\n          for (var i = varIndex; i < args.length; i++) {\\n            if (!lastTest(args[i])) {\\n              return false;\\n            }\\n          }\\n          return true;\\n        }\\n\\n        return function testArgs(args) {\\n          for (var i = 0; i < tests.length; i++) {\\n            if (!tests[i](args[i])) {\\n              return false;\\n            }\\n          }\\n          return testRestParam(args) && (args.length >= varIndex + 1);\\n        };\\n      }\\n      else {\\n        // no variable arguments\\n        if (params.length === 0) {\\n          return function testArgs(args) {\\n            return args.length === 0;\\n          };\\n        }\\n        else if (params.length === 1) {\\n          test0 = compileTest(params[0]);\\n          return function testArgs(args) {\\n            return test0(args[0]) && args.length === 1;\\n          };\\n        }\\n        else if (params.length === 2) {\\n          test0 = compileTest(params[0]);\\n          test1 = compileTest(params[1]);\\n          return function testArgs(args) {\\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\\n          };\\n        }\\n        else { // arguments.length > 2\\n          tests = params.map(compileTest);\\n          return function testArgs(args) {\\n            for (var i = 0; i < tests.length; i++) {\\n              if (!tests[i](args[i])) {\\n                return false;\\n              }\\n            }\\n            return args.length === tests.length;\\n          };\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Find the parameter at a specific index of a signature.\\n     * Handles rest parameters.\\n     * @param {Signature} signature\\n     * @param {number} index\\n     * @return {Param | null} Returns the matching parameter when found,\\n     *                        null otherwise.\\n     */\\n    function getParamAtIndex(signature, index) {\\n      return index < signature.params.length\\n          ? signature.params[index]\\n          : hasRestParam(signature.params)\\n              ? last(signature.params)\\n              : null\\n    }\\n\\n    /**\\n     * Get all type names of a parameter\\n     * @param {Signature} signature\\n     * @param {number} index\\n     * @param {boolean} excludeConversions\\n     * @return {string[]} Returns an array with type names\\n     */\\n    function getExpectedTypeNames (signature, index, excludeConversions) {\\n      var param = getParamAtIndex(signature, index);\\n      var types = param\\n          ? excludeConversions\\n                  ? param.types.filter(isExactType)\\n                  : param.types\\n          : [];\\n\\n      return types.map(getTypeName);\\n    }\\n\\n    /**\\n     * Returns the name of a type\\n     * @param {Type} type\\n     * @return {string} Returns the type name\\n     */\\n    function getTypeName(type) {\\n      return type.name;\\n    }\\n\\n    /**\\n     * Test whether a type is an exact type or conversion\\n     * @param {Type} type\\n     * @return {boolean} Returns true when\\n     */\\n    function isExactType(type) {\\n      return type.conversion === null || type.conversion === undefined;\\n    }\\n\\n    /**\\n     * Helper function for creating error messages: create an array with\\n     * all available types on a specific argument index.\\n     * @param {Signature[]} signatures\\n     * @param {number} index\\n     * @return {string[]} Returns an array with available types\\n     */\\n    function mergeExpectedParams(signatures, index) {\\n      var typeNames = uniq(flatMap(signatures, function (signature) {\\n        return getExpectedTypeNames(signature, index, false);\\n      }));\\n\\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\\n    }\\n\\n    /**\\n     * Create\\n     * @param {string} name             The name of the function\\n     * @param {array.<*>} args          The actual arguments passed to the function\\n     * @param {Signature[]} signatures  A list with available signatures\\n     * @return {TypeError} Returns a type error with additional data\\n     *                     attached to it in the property `data`\\n     */\\n    function createError(name, args, signatures) {\\n      var err, expected;\\n      var _name = name || 'unnamed';\\n\\n      // test for wrong type at some index\\n      var matchingSignatures = signatures;\\n      var index;\\n      for (index = 0; index < args.length; index++) {\\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\\n          var test = compileTest(getParamAtIndex(signature, index));\\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\\n              test(args[index]);\\n        });\\n\\n        if (nextMatchingDefs.length === 0) {\\n          // no matching signatures anymore, throw error \\\"wrong type\\\"\\n          expected = mergeExpectedParams(matchingSignatures, index);\\n          if (expected.length > 0) {\\n            var actualType = findTypeName(args[index]);\\n\\n            err = new TypeError('Unexpected type of argument in function ' + _name +\\n                ' (expected: ' + expected.join(' or ') +\\n                ', actual: ' + actualType + ', index: ' + index + ')');\\n            err.data = {\\n              category: 'wrongType',\\n              fn: _name,\\n              index: index,\\n              actual: actualType,\\n              expected: expected\\n            }\\n            return err;\\n          }\\n        }\\n        else {\\n          matchingSignatures = nextMatchingDefs;\\n        }\\n      }\\n\\n      // test for too few arguments\\n      var lengths = matchingSignatures.map(function (signature) {\\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\\n      });\\n      if (args.length < Math.min.apply(null, lengths)) {\\n        expected = mergeExpectedParams(matchingSignatures, index);\\n        err = new TypeError('Too few arguments in function ' + _name +\\n            ' (expected: ' + expected.join(' or ') +\\n            ', index: ' + args.length + ')');\\n        err.data = {\\n          category: 'tooFewArgs',\\n          fn: _name,\\n          index: args.length,\\n          expected: expected\\n        }\\n        return err;\\n      }\\n\\n      // test for too many arguments\\n      var maxLength = Math.max.apply(null, lengths);\\n      if (args.length > maxLength) {\\n        err = new TypeError('Too many arguments in function ' + _name +\\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\\n        err.data = {\\n          category: 'tooManyArgs',\\n          fn: _name,\\n          index: args.length,\\n          expectedLength: maxLength\\n        }\\n        return err;\\n      }\\n\\n      err = new TypeError('Arguments of type \\\"' + args.join(', ') +\\n          '\\\" do not match any of the defined signatures of function ' + _name + '.');\\n      err.data = {\\n        category: 'mismatch',\\n        actual: args.map(findTypeName)\\n      }\\n      return err;\\n    }\\n\\n    /**\\n     * Find the lowest index of all exact types of a parameter (no conversions)\\n     * @param {Param} param\\n     * @return {number} Returns the index of the lowest type in typed.types\\n     */\\n    function getLowestTypeIndex (param) {\\n      var min = 999;\\n\\n      for (var i = 0; i < param.types.length; i++) {\\n        if (isExactType(param.types[i])) {\\n          min = Math.min(min, param.types[i].typeIndex);\\n        }\\n      }\\n\\n      return min;\\n    }\\n\\n    /**\\n     * Find the lowest index of the conversion of all types of the parameter\\n     * having a conversion\\n     * @param {Param} param\\n     * @return {number} Returns the lowest index of the conversions of this type\\n     */\\n    function getLowestConversionIndex (param) {\\n      var min = 999;\\n\\n      for (var i = 0; i < param.types.length; i++) {\\n        if (!isExactType(param.types[i])) {\\n          min = Math.min(min, param.types[i].conversionIndex);\\n        }\\n      }\\n\\n      return min;\\n    }\\n\\n    /**\\n     * Compare two params\\n     * @param {Param} param1\\n     * @param {Param} param2\\n     * @return {number} returns a negative number when param1 must get a lower\\n     *                  index than param2, a positive number when the opposite,\\n     *                  or zero when both are equal\\n     */\\n    function compareParams (param1, param2) {\\n      var c;\\n\\n      // compare having a rest parameter or not\\n      c = param1.restParam - param2.restParam;\\n      if (c !== 0) {\\n        return c;\\n      }\\n\\n      // compare having conversions or not\\n      c = hasConversions(param1) - hasConversions(param2);\\n      if (c !== 0) {\\n        return c;\\n      }\\n\\n      // compare the index of the types\\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\\n      if (c !== 0) {\\n        return c;\\n      }\\n\\n      // compare the index of any conversion\\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\\n    }\\n\\n    /**\\n     * Compare two signatures\\n     * @param {Signature} signature1\\n     * @param {Signature} signature2\\n     * @return {number} returns a negative number when param1 must get a lower\\n     *                  index than param2, a positive number when the opposite,\\n     *                  or zero when both are equal\\n     */\\n    function compareSignatures (signature1, signature2) {\\n      var len = Math.min(signature1.params.length, signature2.params.length);\\n      var i;\\n      var c;\\n\\n      // compare whether the params have conversions at all or not\\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\\n      if (c !== 0) {\\n        return c;\\n      }\\n\\n      // next compare whether the params have conversions one by one\\n      for (i = 0; i < len; i++) {\\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\\n        if (c !== 0) {\\n          return c;\\n        }\\n      }\\n\\n      // compare the types of the params one by one\\n      for (i = 0; i < len; i++) {\\n        c = compareParams(signature1.params[i], signature2.params[i]);\\n        if (c !== 0) {\\n          return c;\\n        }\\n      }\\n\\n      // compare the number of params\\n      return signature1.params.length - signature2.params.length;\\n    }\\n\\n    /**\\n     * Get params containing all types that can be converted to the defined types.\\n     *\\n     * @param {ConversionDef[]} conversions\\n     * @param {string[]} typeNames\\n     * @return {ConversionDef[]} Returns the conversions that are available\\n     *                        for every type (if any)\\n     */\\n    function filterConversions(conversions, typeNames) {\\n      var matches = {};\\n\\n      conversions.forEach(function (conversion) {\\n        if (typeNames.indexOf(conversion.from) === -1 &&\\n            typeNames.indexOf(conversion.to) !== -1 &&\\n            !matches[conversion.from]) {\\n          matches[conversion.from] = conversion;\\n        }\\n      });\\n\\n      return Object.keys(matches).map(function (from) {\\n        return matches[from];\\n      });\\n    }\\n\\n    /**\\n     * Preprocess arguments before calling the original function:\\n     * - if needed convert the parameters\\n     * - in case of rest parameters, move the rest parameters into an Array\\n     * @param {Param[]} params\\n     * @param {function} fn\\n     * @return {function} Returns a wrapped function\\n     */\\n    function compileArgsPreprocessing(params, fn) {\\n      var fnConvert = fn;\\n\\n      // TODO: can we make this wrapper function smarter/simpler?\\n\\n      if (params.some(hasConversions)) {\\n        var restParam = hasRestParam(params);\\n        var compiledConversions = params.map(compileArgConversion)\\n\\n        fnConvert = function convertArgs() {\\n          var args = [];\\n          var last = restParam ? arguments.length - 1 : arguments.length;\\n          for (var i = 0; i < last; i++) {\\n            args[i] = compiledConversions[i](arguments[i]);\\n          }\\n          if (restParam) {\\n            args[last] = arguments[last].map(compiledConversions[last]);\\n          }\\n\\n          return fn.apply(this, args);\\n        }\\n      }\\n\\n      var fnPreprocess = fnConvert;\\n      if (hasRestParam(params)) {\\n        var offset = params.length - 1;\\n\\n        fnPreprocess = function preprocessRestParams () {\\n          return fnConvert.apply(this,\\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\\n        }\\n      }\\n\\n      return fnPreprocess;\\n    }\\n\\n    /**\\n     * Compile conversion for a parameter to the right type\\n     * @param {Param} param\\n     * @return {function} Returns the wrapped function that will convert arguments\\n     *\\n     */\\n    function compileArgConversion(param) {\\n      var test0, test1, conversion0, conversion1;\\n      var tests = [];\\n      var conversions = [];\\n\\n      param.types.forEach(function (type) {\\n        if (type.conversion) {\\n          tests.push(findTypeByName(type.conversion.from).test);\\n          conversions.push(type.conversion.convert);\\n        }\\n      });\\n\\n      // create optimized conversion functions depending on the number of conversions\\n      switch (conversions.length) {\\n        case 0:\\n          return function convertArg(arg) {\\n            return arg;\\n          }\\n\\n        case 1:\\n          test0 = tests[0]\\n          conversion0 = conversions[0];\\n          return function convertArg(arg) {\\n            if (test0(arg)) {\\n              return conversion0(arg)\\n            }\\n            return arg;\\n          }\\n\\n        case 2:\\n          test0 = tests[0]\\n          test1 = tests[1]\\n          conversion0 = conversions[0];\\n          conversion1 = conversions[1];\\n          return function convertArg(arg) {\\n            if (test0(arg)) {\\n              return conversion0(arg)\\n            }\\n            if (test1(arg)) {\\n              return conversion1(arg)\\n            }\\n            return arg;\\n          }\\n\\n        default:\\n          return function convertArg(arg) {\\n            for (var i = 0; i < conversions.length; i++) {\\n              if (tests[i](arg)) {\\n                return conversions[i](arg);\\n              }\\n            }\\n            return arg;\\n          }\\n      }\\n    }\\n\\n    /**\\n     * Convert an array with signatures into a map with signatures,\\n     * where signatures with union types are split into separate signatures\\n     *\\n     * Throws an error when there are conflicting types\\n     *\\n     * @param {Signature[]} signatures\\n     * @return {Object.<string, function>}  Returns a map with signatures\\n     *                                      as key and the original function\\n     *                                      of this signature as value.\\n     */\\n    function createSignaturesMap(signatures) {\\n      var signaturesMap = {};\\n      signatures.forEach(function (signature) {\\n        if (!signature.params.some(hasConversions)) {\\n          splitParams(signature.params, true).forEach(function (params) {\\n            signaturesMap[stringifyParams(params)] = signature.fn;\\n          });\\n        }\\n      });\\n\\n      return signaturesMap;\\n    }\\n\\n    /**\\n     * Split params with union types in to separate params.\\n     *\\n     * For example:\\n     *\\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\\n     *     // returns:\\n     *     // [\\n     *     //   ['Array', 'string'],\\n     *     //   ['Array', 'RegExp'],\\n     *     //   ['Object', 'string'],\\n     *     //   ['Object', 'RegExp']\\n     *     // ]\\n     *\\n     * @param {Param[]} params\\n     * @param {boolean} ignoreConversionTypes\\n     * @return {Param[]}\\n     */\\n    function splitParams(params, ignoreConversionTypes) {\\n      function _splitParams(params, index, types) {\\n        if (index < params.length) {\\n          var param = params[index]\\n          var filteredTypes = ignoreConversionTypes\\n              ? param.types.filter(isExactType)\\n              : param.types;\\n          var typeGroups\\n\\n          if (param.restParam) {\\n            // split the types of a rest parameter in two:\\n            // one with only exact types, and one with exact types and conversions\\n            var exactTypes = filteredTypes.filter(isExactType)\\n            typeGroups = exactTypes.length < filteredTypes.length\\n                ? [exactTypes, filteredTypes]\\n                : [filteredTypes]\\n\\n          }\\n          else {\\n            // split all the types of a regular parameter into one type per group\\n            typeGroups = filteredTypes.map(function (type) {\\n              return [type]\\n            })\\n          }\\n\\n          // recurse over the groups with types\\n          return flatMap(typeGroups, function (typeGroup) {\\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\\n          });\\n\\n        }\\n        else {\\n          // we've reached the end of the parameters. Now build a new Param\\n          var splittedParams = types.map(function (type, typeIndex) {\\n            return {\\n              types: type,\\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\\n            }\\n          });\\n\\n          return [splittedParams];\\n        }\\n      }\\n\\n      return _splitParams(params, 0, []);\\n    }\\n\\n    /**\\n     * Test whether two signatures have a conflicting signature\\n     * @param {Signature} signature1\\n     * @param {Signature} signature2\\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\\n     */\\n    function hasConflictingParams(signature1, signature2) {\\n      var ii = Math.max(signature1.params.length, signature2.params.length);\\n\\n      for (var i = 0; i < ii; i++) {\\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\\n\\n        if (!hasOverlap(typesNames1, typesNames2)) {\\n          return false;\\n        }\\n      }\\n\\n      var len1 = signature1.params.length;\\n      var len2 = signature2.params.length;\\n      var restParam1 = hasRestParam(signature1.params);\\n      var restParam2 = hasRestParam(signature2.params);\\n\\n      return restParam1\\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\\n    }\\n\\n    /**\\n     * Create a typed function\\n     * @param {String} name               The name for the typed function\\n     * @param {Object.<string, function>} signaturesMap\\n     *                                    An object with one or\\n     *                                    multiple signatures as key, and the\\n     *                                    function corresponding to the\\n     *                                    signature as value.\\n     * @return {function}  Returns the created typed function.\\n     */\\n    function createTypedFunction(name, signaturesMap) {\\n      if (Object.keys(signaturesMap).length === 0) {\\n        throw new SyntaxError('No signatures provided');\\n      }\\n\\n      // parse the signatures, and check for conflicts\\n      var parsedSignatures = [];\\n      Object.keys(signaturesMap)\\n          .map(function (signature) {\\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\\n          })\\n          .filter(notNull)\\n          .forEach(function (parsedSignature) {\\n            // check whether this parameter conflicts with already parsed signatures\\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\\n              return hasConflictingParams(s, parsedSignature)\\n            });\\n            if (conflictingSignature) {\\n              throw new TypeError('Conflicting signatures \\\"' +\\n                  stringifyParams(conflictingSignature.params) + '\\\" and \\\"' +\\n                  stringifyParams(parsedSignature.params) + '\\\".');\\n            }\\n\\n            parsedSignatures.push(parsedSignature);\\n          });\\n\\n      // split and filter the types of the signatures, and then order them\\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\\n\\n        return params.map(function (params) {\\n          return {\\n            params: params,\\n            fn: parsedSignature.fn\\n          };\\n        });\\n      }).filter(notNull);\\n\\n      signatures.sort(compareSignatures);\\n\\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\\n\\n      // compile the tests\\n      var tests = signatures.map(function (signature) {\\n        return compileTests(signature.params);\\n      });\\n\\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\\n\\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\\n\\n      // compile the functions\\n      var fns = signatures.map(function(signature) {\\n        return compileArgsPreprocessing(signature.params, signature.fn);\\n      });\\n\\n      var fn0 = ok0 ? fns[0] : undef;\\n      var fn1 = ok1 ? fns[1] : undef;\\n      var fn2 = ok2 ? fns[2] : undef;\\n      var fn3 = ok3 ? fns[3] : undef;\\n      var fn4 = ok4 ? fns[4] : undef;\\n      var fn5 = ok5 ? fns[5] : undef;\\n\\n      var len0 = ok0 ? signatures[0].params.length : -1;\\n      var len1 = ok1 ? signatures[1].params.length : -1;\\n      var len2 = ok2 ? signatures[2].params.length : -1;\\n      var len3 = ok3 ? signatures[3].params.length : -1;\\n      var len4 = ok4 ? signatures[4].params.length : -1;\\n      var len5 = ok5 ? signatures[5].params.length : -1;\\n\\n      // simple and generic, but also slow\\n      var iStart = allOk ? 6 : 0;\\n      var iEnd = signatures.length;\\n      var generic = function generic() {\\n        'use strict';\\n\\n        for (var i = iStart; i < iEnd; i++) {\\n          if (tests[i](arguments)) {\\n            return fns[i].apply(this, arguments);\\n          }\\n        }\\n\\n        throw createError(name, arguments, signatures);\\n      }\\n\\n      // create the typed function\\n      // fast, specialized version. Falls back to the slower, generic one if needed\\n      var fn = function fn(arg0, arg1) {\\n        'use strict';\\n\\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }\\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }\\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }\\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }\\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }\\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }\\n\\n        return generic.apply(fn, arguments);\\n      }\\n\\n      // attach name the typed function\\n      try {\\n        Object.defineProperty(fn, 'name', {value: name});\\n      }\\n      catch (err) {\\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\\n        // so it's fine to have unnamed functions.\\n      }\\n\\n      // attach signatures to the function\\n      fn.signatures = createSignaturesMap(signatures);\\n\\n      return fn;\\n    }\\n\\n    /**\\n     * Test whether a type should be NOT be ignored\\n     * @param {string} typeName\\n     * @return {boolean}\\n     */\\n    function notIgnore(typeName) {\\n      return typed.ignore.indexOf(typeName) === -1;\\n    }\\n\\n    /**\\n     * trim a string\\n     * @param {string} str\\n     * @return {string}\\n     */\\n    function trim(str) {\\n      return str.trim();\\n    }\\n\\n    /**\\n     * Test whether a string is not empty\\n     * @param {string} str\\n     * @return {boolean}\\n     */\\n    function notEmpty(str) {\\n      return !!str;\\n    }\\n\\n    /**\\n     * test whether a value is not strict equal to null\\n     * @param {*} value\\n     * @return {boolean}\\n     */\\n    function notNull(value) {\\n      return value !== null;\\n    }\\n\\n    /**\\n     * Test whether a parameter has no types defined\\n     * @param {Param} param\\n     * @return {boolean}\\n     */\\n    function isInvalidParam (param) {\\n      return param.types.length === 0;\\n    }\\n\\n    /**\\n     * Return all but the last items of an array\\n     * @param {Array} arr\\n     * @return {Array}\\n     */\\n    function initial(arr) {\\n      return arr.slice(0, arr.length - 1);\\n    }\\n\\n    /**\\n     * return the last item of an array\\n     * @param {Array} arr\\n     * @return {*}\\n     */\\n    function last(arr) {\\n      return arr[arr.length - 1];\\n    }\\n\\n    /**\\n     * Slice an array or function Arguments\\n     * @param {Array | Arguments | IArguments} arr\\n     * @param {number} start\\n     * @param {number} [end]\\n     * @return {Array}\\n     */\\n    function slice(arr, start, end) {\\n      return Array.prototype.slice.call(arr, start, end);\\n    }\\n\\n    /**\\n     * Test whether an array contains some item\\n     * @param {Array} array\\n     * @param {*} item\\n     * @return {boolean} Returns true if array contains item, false if not.\\n     */\\n    function contains(array, item) {\\n      return array.indexOf(item) !== -1;\\n    }\\n\\n    /**\\n     * Test whether two arrays have overlapping items\\n     * @param {Array} array1\\n     * @param {Array} array2\\n     * @return {boolean} Returns true when at least one item exists in both arrays\\n     */\\n    function hasOverlap(array1, array2) {\\n      for (var i = 0; i < array1.length; i++) {\\n        if (contains(array2, array1[i])) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n    /**\\n     * Return the first item from an array for which test(arr[i]) returns true\\n     * @param {Array} arr\\n     * @param {function} test\\n     * @return {* | undefined} Returns the first matching item\\n     *                         or undefined when there is no match\\n     */\\n    function findInArray(arr, test) {\\n      for (var i = 0; i < arr.length; i++) {\\n        if (test(arr[i])) {\\n          return arr[i];\\n        }\\n      }\\n      return undefined;\\n    }\\n\\n    /**\\n     * Filter unique items of an array with strings\\n     * @param {string[]} arr\\n     * @return {string[]}\\n     */\\n    function uniq(arr) {\\n      var entries = {}\\n      for (var i = 0; i < arr.length; i++) {\\n        entries[arr[i]] = true;\\n      }\\n      return Object.keys(entries);\\n    }\\n\\n    /**\\n     * Flat map the result invoking a callback for every item in an array.\\n     * https://gist.github.com/samgiles/762ee337dff48623e729\\n     * @param {Array} arr\\n     * @param {function} callback\\n     * @return {Array}\\n     */\\n    function flatMap(arr, callback) {\\n      return Array.prototype.concat.apply([], arr.map(callback));\\n    }\\n\\n    /**\\n     * Retrieve the function name from a set of typed functions,\\n     * and check whether the name of all functions match (if given)\\n     * @param {function[]} fns\\n     */\\n    function getName (fns) {\\n      var name = '';\\n\\n      for (var i = 0; i < fns.length; i++) {\\n        var fn = fns[i];\\n\\n        // check whether the names are the same when defined\\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\\n          if (name === '') {\\n            name = fn.name;\\n          }\\n          else if (name !== fn.name) {\\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\\n            err.data = {\\n              actual: fn.name,\\n              expected: name\\n            };\\n            throw err;\\n          }\\n        }\\n      }\\n\\n      return name;\\n    }\\n\\n    // extract and merge all signatures of a list with typed functions\\n    function extractSignatures(fns) {\\n      var err;\\n      var signaturesMap = {};\\n\\n      function validateUnique(_signature, _fn) {\\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\\n          err = new Error('Signature \\\"' + _signature + '\\\" is defined twice');\\n          err.data = {signature: _signature};\\n          throw err;\\n          // else: both signatures point to the same function, that's fine\\n        }\\n      }\\n\\n      for (var i = 0; i < fns.length; i++) {\\n        var fn = fns[i];\\n\\n        // test whether this is a typed-function\\n        if (typeof fn.signatures === 'object') {\\n          // merge the signatures\\n          for (var signature in fn.signatures) {\\n            if (fn.signatures.hasOwnProperty(signature)) {\\n              validateUnique(signature, fn.signatures[signature]);\\n              signaturesMap[signature] = fn.signatures[signature];\\n            }\\n          }\\n        }\\n        else if (typeof fn.signature === 'string') {\\n          validateUnique(fn.signature, fn);\\n          signaturesMap[fn.signature] = fn;\\n        }\\n        else {\\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\\n          err.data = {index: i};\\n          throw err;\\n        }\\n      }\\n\\n      return signaturesMap;\\n    }\\n\\n    typed = createTypedFunction('typed', {\\n      'string, Object': createTypedFunction,\\n      'Object': function (signaturesMap) {\\n        // find existing name\\n        var fns = [];\\n        for (var signature in signaturesMap) {\\n          if (signaturesMap.hasOwnProperty(signature)) {\\n            fns.push(signaturesMap[signature]);\\n          }\\n        }\\n        var name = getName(fns);\\n        return createTypedFunction(name, signaturesMap);\\n      },\\n      '...Function': function (fns) {\\n        return createTypedFunction(getName(fns), extractSignatures(fns));\\n      },\\n      'string, ...Function': function (name, fns) {\\n        return createTypedFunction(name, extractSignatures(fns));\\n      }\\n    });\\n\\n    typed.create = create;\\n    typed.types = _types;\\n    typed.conversions = _conversions;\\n    typed.ignore = _ignore;\\n    typed.convert = convert;\\n    typed.find = find;\\n\\n    /**\\n     * add a type\\n     * @param {{name: string, test: function}} type\\n     * @param {boolean} [beforeObjectTest=true]\\n     *                          If true, the new test will be inserted before\\n     *                          the test with name 'Object' (if any), since\\n     *                          tests for Object match Array and classes too.\\n     */\\n    typed.addType = function (type, beforeObjectTest) {\\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\\n        throw new TypeError('Object with properties {name: string, test: function} expected');\\n      }\\n\\n      if (beforeObjectTest !== false) {\\n        for (var i = 0; i < typed.types.length; i++) {\\n          if (typed.types[i].name === 'Object') {\\n            typed.types.splice(i, 0, type);\\n            return\\n          }\\n        }\\n      }\\n\\n      typed.types.push(type);\\n    };\\n\\n    // add a conversion\\n    typed.addConversion = function (conversion) {\\n      if (!conversion\\n          || typeof conversion.from !== 'string'\\n          || typeof conversion.to !== 'string'\\n          || typeof conversion.convert !== 'function') {\\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\\n      }\\n\\n      typed.conversions.push(conversion);\\n    };\\n\\n    return typed;\\n  }\\n\\n  return create();\\n}));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"root\",\"factory\",\"define\",\"amd\",\"typed\",\"ok\",\"notOk\",\"undef\",\"create\",\"findTypeByName\",\"typeName\",\"entry\",\"findInArray\",\"types\",\"name\",\"anyType\",\"hint\",\"toLowerCase\",\"TypeError\",\"findTypeName\",\"value\",\"test\",\"stringifyParams\",\"params\",\"map\",\"param\",\"typeNames\",\"getTypeName\",\"restParam\",\"join\",\"parseParam\",\"conversions\",\"indexOf\",\"split\",\"length\",\"slice\",\"trim\",\"filter\",\"notEmpty\",\"notIgnore\",\"matchingConversions\",\"filterConversions\",\"exactTypes\",\"type\",\"typeIndex\",\"conversion\",\"conversionIndex\",\"convertibleTypes\",\"from\",\"concat\",\"parseSignature\",\"signature\",\"fn\",\"index\",\"array\",\"parsedParam\",\"SyntaxError\",\"some\",\"isInvalidParam\",\"hasRestParam\",\"hasConversions\",\"compileTest\",\"test0\",\"test1\",\"or\",\"x\",\"tests\",\"i\",\"compileTests\",\"varIndex\",\"lastTest\",\"testArgs\",\"args\",\"getParamAtIndex\",\"arr\",\"getExpectedTypeNames\",\"excludeConversions\",\"isExactType\",\"undefined\",\"mergeExpectedParams\",\"signatures\",\"uniq\",\"flatMap\",\"createError\",\"_name\",\"nextMatchingDefs\",\"matchingSignatures\",\"expected\",\"actualType\",\"err\",\"data\",\"category\",\"actual\",\"lengths\",\"Infinity\",\"Math\",\"min\",\"apply\",\"maxLength\",\"max\",\"expectedLength\",\"getLowestTypeIndex\",\"getLowestConversionIndex\",\"compareSignatures\",\"signature1\",\"signature2\",\"len\",\"c\",\"param1\",\"param2\",\"matches\",\"forEach\",\"to\",\"Object\",\"keys\",\"compileArgsPreprocessing\",\"fnConvert\",\"compiledConversions\",\"compileArgConversion\",\"last\",\"arguments\",\"fnPreprocess\",\"offset\",\"Array\",\"prototype\",\"call\",\"start\",\"end\",\"push\",\"convert\",\"convertArg\",\"arg\",\"conversion0\",\"conversion1\",\"createSignaturesMap\",\"signaturesMap\",\"splitParams\",\"ignoreConversionTypes\",\"_splitParams\",\"filteredTypes\",\"typeGroups\",\"typeGroup\",\"splittedParams\",\"createTypedFunction\",\"parsedSignatures\",\"notNull\",\"parsedSignature\",\"conflictingSignature\",\"s\",\"ii\",\"typesNames1\",\"typesNames2\",\"array1\",\"array2\",\"item\",\"len1\",\"len2\",\"restParam1\",\"restParam2\",\"sort\",\"ok0\",\"ok1\",\"ok2\",\"ok3\",\"ok4\",\"ok5\",\"allOk\",\"test00\",\"test10\",\"test20\",\"test30\",\"test40\",\"test50\",\"test01\",\"test11\",\"test21\",\"test31\",\"test41\",\"test51\",\"fns\",\"fn0\",\"fn1\",\"fn2\",\"fn3\",\"fn4\",\"fn5\",\"len0\",\"len3\",\"len4\",\"len5\",\"iStart\",\"iEnd\",\"generic\",\"arg0\",\"arg1\",\"defineProperty\",\"ignore\",\"str\",\"entries\",\"callback\",\"getName\",\"Error\",\"extractSignatures\",\"validateUnique\",\"_signature\",\"_fn\",\"hasOwnProperty\",\"_types\",\"isArray\",\"Date\",\"RegExp\",\"constructor\",\"_ignore\",\"_conversions\",\"...Function\",\"string, ...Function\",\"find\",\"match\",\"addType\",\"typed.addType\",\"beforeObjectTest\",\"splice\",\"addConversion\",\"typed.addConversion\"]\n}\n"]