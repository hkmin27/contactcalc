["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/matrix/MatrixIndex.js"],"~:js","shadow$provide[199]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createIndexClass=void 0;var q=b(14),f=b(15),u=b(19);c=b(25);c=(0,c.factory)(\"Index\",[\"ImmutableDenseMatrix\"],function(k){function t(d){if(!(this instanceof t))throw new SyntaxError(\"Constructor must be called with the new operator\");this._dimensions=[];this._isScalar=!0;for(var l=0,h=arguments.length;l<h;l++){var n=arguments[l];if((0,q.isRange)(n))this._dimensions.push(n),this._isScalar=!1;else if(Array.isArray(n)||\n(0,q.isMatrix)(n)){if(n=p(n.valueOf()),this._dimensions.push(n),n=n.size(),1!==n.length||1!==n[0])this._isScalar=!1}else if(\"number\"===typeof n)this._dimensions.push(p([n]));else if(\"string\"===typeof n)this._dimensions.push(n);else throw new TypeError(\"Dimension must be an Array, Matrix, number, string, or Range\");}}function p(d){for(var l=0,h=d.length;l<h;l++)if(\"number\"!==typeof d[l]||!(0,u.isInteger)(d[l]))throw new TypeError(\"Index parameters must be positive integer numbers\");return new g(d)}\nvar g=k.ImmutableDenseMatrix;t.prototype.type=\"Index\";t.prototype.isIndex=!0;t.prototype.clone=function(){var d=new t;d._dimensions=(0,f.clone)(this._dimensions);d._isScalar=this._isScalar;return d};t.create=function(d){var l=new t;t.apply(l,d);return l};t.prototype.size=function(){for(var d=[],l=0,h=this._dimensions.length;l<h;l++){var n=this._dimensions[l];d[l]=\"string\"===typeof n?1:n.size()[0]}return d};t.prototype.max=function(){for(var d=[],l=0,h=this._dimensions.length;l<h;l++){var n=this._dimensions[l];\nd[l]=\"string\"===typeof n?n:n.max()}return d};t.prototype.min=function(){for(var d=[],l=0,h=this._dimensions.length;l<h;l++){var n=this._dimensions[l];d[l]=\"string\"===typeof n?n:n.min()}return d};t.prototype.forEach=function(d){for(var l=0,h=this._dimensions.length;l<h;l++)d(this._dimensions[l],l,this)};t.prototype.dimension=function(d){return this._dimensions[d]||null};t.prototype.isObjectProperty=function(){return 1===this._dimensions.length&&\"string\"===typeof this._dimensions[0]};t.prototype.getObjectProperty=\nfunction(){return this.isObjectProperty()?this._dimensions[0]:null};t.prototype.isScalar=function(){return this._isScalar};t.prototype.toArray=function(){for(var d=[],l=0,h=this._dimensions.length;l<h;l++){var n=this._dimensions[l];d.push(\"string\"===typeof n?n:n.toArray())}return d};t.prototype.valueOf=t.prototype.toArray;t.prototype.toString=function(){for(var d=[],l=0,h=this._dimensions.length;l<h;l++){var n=this._dimensions[l];\"string\"===typeof n?d.push(JSON.stringify(n)):d.push(n.toString())}return\"[\"+\nd.join(\", \")+\"]\"};t.prototype.toJSON=function(){return{mathjs:\"Index\",dimensions:this._dimensions}};t.fromJSON=function(d){return t.create(d.dimensions)};return t},{isClass:!0});a.createIndexClass=c}","~:source","shadow$provide[199] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Index';\nvar dependencies = ['ImmutableDenseMatrix'];\nvar createIndexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix;\n\n  /**\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\n   *\n   * Usage:\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\n   *\n   * Where each parameter can be any of:\n   *     A number\n   *     A string (containing a name of an object property)\n   *     An instance of Range\n   *     An Array with the Set values\n   *     A Matrix with the Set values\n   *\n   * The parameters start, end, and step must be integer numbers.\n   *\n   * @class Index\n   * @Constructor Index\n   * @param {...*} ranges\n   */\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this._dimensions = [];\n    this._isScalar = true;\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n\n      if ((0, _is.isRange)(arg)) {\n        this._dimensions.push(arg);\n\n        this._isScalar = false;\n      } else if (Array.isArray(arg) || (0, _is.isMatrix)(arg)) {\n        // create matrix\n        var m = _createImmutableMatrix(arg.valueOf());\n\n        this._dimensions.push(m); // size\n\n\n        var size = m.size(); // scalar\n\n        if (size.length !== 1 || size[0] !== 1) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      } // TODO: implement support for wildcard '*'\n\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !(0, _number.isInteger)(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    } // create matrix\n\n\n    return new ImmutableDenseMatrix(arg);\n  }\n  /**\n   * Create a clone of the index\n   * @memberof Index\n   * @return {Index} clone\n   */\n\n\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = (0, _object.clone)(this._dimensions);\n    index._isScalar = this._isScalar;\n    return index;\n  };\n  /**\n   * Create an index from an array with ranges/numbers\n   * @memberof Index\n   * @param {Array.<Array | number>} ranges\n   * @return {Index} index\n   * @private\n   */\n\n\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n  /**\n   * Retrieve the size of the index, the number of elements for each dimension.\n   * @memberof Index\n   * @returns {number[]} size\n   */\n\n\n  Index.prototype.size = function () {\n    var size = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n\n    return size;\n  };\n  /**\n   * Get the maximum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} max\n   */\n\n\n  Index.prototype.max = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n\n    return values;\n  };\n  /**\n   * Get the minimum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} min\n   */\n\n\n  Index.prototype.min = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n\n    return values;\n  };\n  /**\n   * Loop over each of the ranges of the index\n   * @memberof Index\n   * @param {Function} callback   Called for each range with a Range as first\n   *                              argument, the dimension as second, and the\n   *                              index object as third.\n   */\n\n\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n  /**\n   * Retrieve the dimension for the given index\n   * @memberof Index\n   * @param {Number} dim                  Number of the dimension\n   * @returns {Range | null} range\n   */\n\n\n  Index.prototype.dimension = function (dim) {\n    return this._dimensions[dim] || null;\n  };\n  /**\n   * Test whether this index contains an object property\n   * @returns {boolean} Returns true if the index is an object property\n   */\n\n\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n  /**\n   * Returns the object property name when the Index holds a single object property,\n   * else returns null\n   * @returns {string | null}\n   */\n\n\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n  /**\n   * Test whether this index contains only a single value.\n   *\n   * This is the case when the index is created with only scalar values as ranges,\n   * not for ranges resolving into a single value.\n   * @memberof Index\n   * @return {boolean} isScalar\n   */\n\n\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n  /**\n   * Expand the Index into an array.\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n\n    return array;\n  };\n  /**\n   * Get the primitive value of the Index, a two dimensional array.\n   * Equivalent to Index.toArray().\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.valueOf = Index.prototype.toArray;\n  /**\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\n   * @memberof Index\n   * @returns {String} str\n   */\n\n  Index.prototype.toString = function () {\n    var strings = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n\n    return '[' + strings.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the Index\n   * @memberof Index\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   */\n\n\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n  /**\n   * Instantiate an Index from a JSON object\n   * @memberof Index\n   * @param {Object} json A JSON object structured as:\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   * @return {Index}\n   */\n\n\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n\n  return Index;\n}, {\n  isClass: true\n});\nexports.createIndexClass = createIndexClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["isIndex","min","forEach","valueOf","fromJSON","isClass","_dimensions","isObjectProperty","_isScalar","__esModule","max","toString","getObjectProperty","value","dimensions","isScalar","mathjs","type","clone","create","size","toArray","dimension","createIndexClass","toJSON"]],"~:compiled-at",1619135723925,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$matrix$MatrixIndex.js\",\n\"lineCount\":6,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,gBAAR,CAA2B,IAAK,EAEhC,KAAIC,EAAMP,CAAA,CAAQ,EAAR,CAAV,CAEIQ,EAAUR,CAAA,CAAQ,EAAR,CAFd,CAIIS,EAAUT,CAAA,CAAQ,EAAR,CAEVU,EAAAA,CAAWV,CAAA,CAAQ,EAAR,CAIXM,EAAAA,CAAkC,CAAC,CAAA,CAAGI,CAASC,CAAAA,OAAb,EAF3BC,OAE2B,CADnBC,CAAC,sBAADA,CACmB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAuB9FC,QAASA,EAAK,CAACC,CAAD,CAAS,CACrB,GAAI,EAAE,IAAF,WAAkBD,EAAlB,CAAJ,CACE,KAAM,KAAIE,WAAJ,CAAgB,kDAAhB,CAAN,CAGF,IAAKC,CAAAA,WAAL,CAAmB,EACnB,KAAKC,CAAAA,SAAL,CAAiB,CAAA,CAEjB,KARqB,IAQZC,EAAI,CARQ,CAQLC,EAAKC,SAAUC,CAAAA,MAA/B,CAAuCH,CAAvC,CAA2CC,CAA3C,CAA+CD,CAAA,EAA/C,CAAoD,CAClD,IAAII,EAAMF,SAAA,CAAUF,CAAV,CAEV,IAAI,CAAC,CAAA,CAAGb,CAAIkB,CAAAA,OAAR,EAAiBD,CAAjB,CAAJ,CACE,IAAKN,CAAAA,WAAYQ,CAAAA,IAAjB,CAAsBF,CAAtB,CAEA,CAAA,IAAKL,CAAAA,SAAL,CAAiB,CAAA,CAHnB,KAIO,IAAIQ,KAAMC,CAAAA,OAAN,CAAcJ,CAAd,CAAJ;AAA0B,CAAC,CAAA,CAAGjB,CAAIsB,CAAAA,QAAR,EAAkBL,CAAlB,CAA1B,CASL,IAPIM,CAOA,CAPIC,CAAA,CAAuBP,CAAIQ,CAAAA,OAAJ,EAAvB,CAOJ,CALJ,IAAKd,CAAAA,WAAYQ,CAAAA,IAAjB,CAAsBI,CAAtB,CAKI,CAFAG,CAEA,CAFOH,CAAEG,CAAAA,IAAF,EAEP,CAAgB,CAAhB,GAAAA,CAAKV,CAAAA,MAAL,EAAiC,CAAjC,GAAqBU,CAAA,CAAK,CAAL,CAAzB,CACE,IAAKd,CAAAA,SAAL,CAAiB,CAAA,CADnB,CATK,IAYA,IAAmB,QAAnB,GAAI,MAAOK,EAAX,CACL,IAAKN,CAAAA,WAAYQ,CAAAA,IAAjB,CAAsBK,CAAA,CAAuB,CAACP,CAAD,CAAvB,CAAtB,CADK,KAEA,IAAmB,QAAnB,GAAI,MAAOA,EAAX,CAEL,IAAKN,CAAAA,WAAYQ,CAAAA,IAAjB,CAAsBF,CAAtB,CAFK,KAIL,MAAM,KAAIU,SAAJ,CAAc,8DAAd,CAAN,CAzBgD,CAR/B,CA8CvBH,QAASA,EAAsB,CAACP,CAAD,CAAM,CAEnC,IAFmC,IAE1BJ,EAAI,CAFsB,CAEnBe,EAAIX,CAAID,CAAAA,MAAxB,CAAgCH,CAAhC,CAAoCe,CAApC,CAAuCf,CAAA,EAAvC,CACE,GAAsB,QAAtB,GAAI,MAAOI,EAAA,CAAIJ,CAAJ,CAAX,EAAkC,CAAC,CAAC,CAAA,CAAGX,CAAQ2B,CAAAA,SAAZ,EAAuBZ,CAAA,CAAIJ,CAAJ,CAAvB,CAAnC,CACE,KAAM,KAAIc,SAAJ,CAAc,mDAAd,CAAN,CAKJ,MAAO,KAAIG,CAAJ,CAAyBb,CAAzB,CAT4B;AApErC,IAAIa,EAAuBvB,CAAKuB,CAAAA,oBAiEhCtB,EAAMuB,CAAAA,SAAUC,CAAAA,IAAhB,CAAuB,OACvBxB,EAAMuB,CAAAA,SAAUE,CAAAA,OAAhB,CAA0B,CAAA,CAoB1BzB,EAAMuB,CAAAA,SAAUG,CAAAA,KAAhB,CAAwBC,QAAS,EAAG,CAClC,IAAIC,EAAQ,IAAI5B,CAChB4B,EAAMzB,CAAAA,WAAN,CAAoB,CAAC,CAAA,CAAGV,CAAQiC,CAAAA,KAAZ,EAAmB,IAAKvB,CAAAA,WAAxB,CACpByB,EAAMxB,CAAAA,SAAN,CAAkB,IAAKA,CAAAA,SACvB,OAAOwB,EAJ2B,CAepC5B,EAAM6B,CAAAA,MAAN,CAAeC,QAAS,CAAC7B,CAAD,CAAS,CAC/B,IAAI2B,EAAQ,IAAI5B,CAChBA,EAAM+B,CAAAA,KAAN,CAAYH,CAAZ,CAAmB3B,CAAnB,CACA,OAAO2B,EAHwB,CAYjC5B,EAAMuB,CAAAA,SAAUL,CAAAA,IAAhB,CAAuBc,QAAS,EAAG,CAGjC,IAFA,IAAId,EAAO,EAAX,CAESb,EAAI,CAFb,CAEgBC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CAA2D,CACzD,IAAI4B,EAAI,IAAK9B,CAAAA,WAAL,CAAiBE,CAAjB,CACRa,EAAA,CAAKb,CAAL,CAAA,CAAuB,QAAb,GAAA,MAAO4B,EAAP,CAAwB,CAAxB,CAA4BA,CAAEf,CAAAA,IAAF,EAAA,CAAS,CAAT,CAFmB,CAK3D,MAAOA,EAR0B,CAiBnClB,EAAMuB,CAAAA,SAAUW,CAAAA,GAAhB,CAAsBC,QAAS,EAAG,CAGhC,IAFA,IAAIC,EAAS,EAAb,CAES/B,EAAI,CAFb,CAEgBC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CAA2D,CACzD,IAAIgC,EAAQ,IAAKlC,CAAAA,WAAL,CAAiBE,CAAjB,CACZ+B;CAAA,CAAO/B,CAAP,CAAA,CAA6B,QAAjB,GAAA,MAAOgC,EAAP,CAA4BA,CAA5B,CAAoCA,CAAMH,CAAAA,GAAN,EAFS,CAK3D,MAAOE,EARyB,CAiBlCpC,EAAMuB,CAAAA,SAAUe,CAAAA,GAAhB,CAAsBC,QAAS,EAAG,CAGhC,IAFA,IAAIH,EAAS,EAAb,CAES/B,EAAI,CAFb,CAEgBC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CAA2D,CACzD,IAAIgC,EAAQ,IAAKlC,CAAAA,WAAL,CAAiBE,CAAjB,CACZ+B,EAAA,CAAO/B,CAAP,CAAA,CAA6B,QAAjB,GAAA,MAAOgC,EAAP,CAA4BA,CAA5B,CAAoCA,CAAMC,CAAAA,GAAN,EAFS,CAK3D,MAAOF,EARyB,CAmBlCpC,EAAMuB,CAAAA,SAAUiB,CAAAA,OAAhB,CAA0BC,QAAS,CAACC,CAAD,CAAW,CAC5C,IAD4C,IACnCrC,EAAI,CAD+B,CAC5BC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CACEqC,CAAA,CAAS,IAAKvC,CAAAA,WAAL,CAAiBE,CAAjB,CAAT,CAA8BA,CAA9B,CAAiC,IAAjC,CAF0C,CAa9CL,EAAMuB,CAAAA,SAAUoB,CAAAA,SAAhB,CAA4BC,QAAS,CAACC,CAAD,CAAM,CACzC,MAAO,KAAK1C,CAAAA,WAAL,CAAiB0C,CAAjB,CAAP,EAAgC,IADS,CAS3C7C,EAAMuB,CAAAA,SAAUuB,CAAAA,gBAAhB,CAAmCC,QAAS,EAAG,CAC7C,MAAmC,EAAnC,GAAO,IAAK5C,CAAAA,WAAYK,CAAAA,MAAxB,EAAuE,QAAvE,GAAwC,MAAO,KAAKL,CAAAA,WAAL,CAAiB,CAAjB,CADF,CAU/CH,EAAMuB,CAAAA,SAAUyB,CAAAA,iBAAhB;AAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAKH,CAAAA,gBAAL,EAAA,CAA0B,IAAK3C,CAAAA,WAAL,CAAiB,CAAjB,CAA1B,CAAgD,IADT,CAahDH,EAAMuB,CAAAA,SAAU2B,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAK/C,CAAAA,SADyB,CAWvCJ,EAAMuB,CAAAA,SAAU6B,CAAAA,OAAhB,CAA0BC,QAAS,EAAG,CAGpC,IAFA,IAAIC,EAAQ,EAAZ,CAESjD,EAAI,CAFb,CAEgBC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CAA2D,CACzD,IAAIsC,EAAY,IAAKxC,CAAAA,WAAL,CAAiBE,CAAjB,CAChBiD,EAAM3C,CAAAA,IAAN,CAAgC,QAArB,GAAA,MAAOgC,EAAP,CAAgCA,CAAhC,CAA4CA,CAAUS,CAAAA,OAAV,EAAvD,CAFyD,CAK3D,MAAOE,EAR6B,CAkBtCtD,EAAMuB,CAAAA,SAAUN,CAAAA,OAAhB,CAA0BjB,CAAMuB,CAAAA,SAAU6B,CAAAA,OAO1CpD,EAAMuB,CAAAA,SAAUgC,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CAGrC,IAFA,IAAIC,EAAU,EAAd,CAESpD,EAAI,CAFb,CAEgBC,EAAK,IAAKH,CAAAA,WAAYK,CAAAA,MAAtC,CAA8CH,CAA9C,CAAkDC,CAAlD,CAAsDD,CAAA,EAAtD,CAA2D,CACzD,IAAIsC,EAAY,IAAKxC,CAAAA,WAAL,CAAiBE,CAAjB,CAES,SAAzB,GAAI,MAAOsC,EAAX,CACEc,CAAQ9C,CAAAA,IAAR,CAAa+C,IAAKC,CAAAA,SAAL,CAAehB,CAAf,CAAb,CADF,CAGEc,CAAQ9C,CAAAA,IAAR,CAAagC,CAAUY,CAAAA,QAAV,EAAb,CANuD,CAU3D,MAAO,GAAP;AAAaE,CAAQG,CAAAA,IAAR,CAAa,IAAb,CAAb,CAAkC,GAbG,CAuBvC5D,EAAMuB,CAAAA,SAAUsC,CAAAA,MAAhB,CAAyBC,QAAS,EAAG,CACnC,MAAO,CACLC,OAAQ,OADH,CAELC,WAAY,IAAK7D,CAAAA,WAFZ,CAD4B,CAerCH,EAAMiE,CAAAA,QAAN,CAAiBC,QAAS,CAACC,CAAD,CAAO,CAC/B,MAAOnE,EAAM6B,CAAAA,MAAN,CAAasC,CAAKH,CAAAA,UAAlB,CADwB,CAIjC,OAAOhE,EAlSuF,CAA1D,CAmSnC,CACDoE,QAAS,CAAA,CADR,CAnSmC,CAsStCjF,EAAQI,CAAAA,gBAAR,CAA2BA,CAxTmC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/matrix/MatrixIndex.js\"],\n\"sourcesContent\":[\"shadow$provide[199] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createIndexClass = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'Index';\\nvar dependencies = ['ImmutableDenseMatrix'];\\nvar createIndexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix;\\n\\n  /**\\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\\n   *\\n   * Usage:\\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\\n   *\\n   * Where each parameter can be any of:\\n   *     A number\\n   *     A string (containing a name of an object property)\\n   *     An instance of Range\\n   *     An Array with the Set values\\n   *     A Matrix with the Set values\\n   *\\n   * The parameters start, end, and step must be integer numbers.\\n   *\\n   * @class Index\\n   * @Constructor Index\\n   * @param {...*} ranges\\n   */\\n  function Index(ranges) {\\n    if (!(this instanceof Index)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    this._dimensions = [];\\n    this._isScalar = true;\\n\\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\\n      var arg = arguments[i];\\n\\n      if ((0, _is.isRange)(arg)) {\\n        this._dimensions.push(arg);\\n\\n        this._isScalar = false;\\n      } else if (Array.isArray(arg) || (0, _is.isMatrix)(arg)) {\\n        // create matrix\\n        var m = _createImmutableMatrix(arg.valueOf());\\n\\n        this._dimensions.push(m); // size\\n\\n\\n        var size = m.size(); // scalar\\n\\n        if (size.length !== 1 || size[0] !== 1) {\\n          this._isScalar = false;\\n        }\\n      } else if (typeof arg === 'number') {\\n        this._dimensions.push(_createImmutableMatrix([arg]));\\n      } else if (typeof arg === 'string') {\\n        // object property (arguments.count should be 1)\\n        this._dimensions.push(arg);\\n      } else {\\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\\n      } // TODO: implement support for wildcard '*'\\n\\n    }\\n  }\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  Index.prototype.type = 'Index';\\n  Index.prototype.isIndex = true;\\n\\n  function _createImmutableMatrix(arg) {\\n    // loop array elements\\n    for (var i = 0, l = arg.length; i < l; i++) {\\n      if (typeof arg[i] !== 'number' || !(0, _number.isInteger)(arg[i])) {\\n        throw new TypeError('Index parameters must be positive integer numbers');\\n      }\\n    } // create matrix\\n\\n\\n    return new ImmutableDenseMatrix(arg);\\n  }\\n  /**\\n   * Create a clone of the index\\n   * @memberof Index\\n   * @return {Index} clone\\n   */\\n\\n\\n  Index.prototype.clone = function () {\\n    var index = new Index();\\n    index._dimensions = (0, _object.clone)(this._dimensions);\\n    index._isScalar = this._isScalar;\\n    return index;\\n  };\\n  /**\\n   * Create an index from an array with ranges/numbers\\n   * @memberof Index\\n   * @param {Array.<Array | number>} ranges\\n   * @return {Index} index\\n   * @private\\n   */\\n\\n\\n  Index.create = function (ranges) {\\n    var index = new Index();\\n    Index.apply(index, ranges);\\n    return index;\\n  };\\n  /**\\n   * Retrieve the size of the index, the number of elements for each dimension.\\n   * @memberof Index\\n   * @returns {number[]} size\\n   */\\n\\n\\n  Index.prototype.size = function () {\\n    var size = [];\\n\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      var d = this._dimensions[i];\\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\\n    }\\n\\n    return size;\\n  };\\n  /**\\n   * Get the maximum value for each of the indexes ranges.\\n   * @memberof Index\\n   * @returns {number[]} max\\n   */\\n\\n\\n  Index.prototype.max = function () {\\n    var values = [];\\n\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      var range = this._dimensions[i];\\n      values[i] = typeof range === 'string' ? range : range.max();\\n    }\\n\\n    return values;\\n  };\\n  /**\\n   * Get the minimum value for each of the indexes ranges.\\n   * @memberof Index\\n   * @returns {number[]} min\\n   */\\n\\n\\n  Index.prototype.min = function () {\\n    var values = [];\\n\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      var range = this._dimensions[i];\\n      values[i] = typeof range === 'string' ? range : range.min();\\n    }\\n\\n    return values;\\n  };\\n  /**\\n   * Loop over each of the ranges of the index\\n   * @memberof Index\\n   * @param {Function} callback   Called for each range with a Range as first\\n   *                              argument, the dimension as second, and the\\n   *                              index object as third.\\n   */\\n\\n\\n  Index.prototype.forEach = function (callback) {\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      callback(this._dimensions[i], i, this);\\n    }\\n  };\\n  /**\\n   * Retrieve the dimension for the given index\\n   * @memberof Index\\n   * @param {Number} dim                  Number of the dimension\\n   * @returns {Range | null} range\\n   */\\n\\n\\n  Index.prototype.dimension = function (dim) {\\n    return this._dimensions[dim] || null;\\n  };\\n  /**\\n   * Test whether this index contains an object property\\n   * @returns {boolean} Returns true if the index is an object property\\n   */\\n\\n\\n  Index.prototype.isObjectProperty = function () {\\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\\n  };\\n  /**\\n   * Returns the object property name when the Index holds a single object property,\\n   * else returns null\\n   * @returns {string | null}\\n   */\\n\\n\\n  Index.prototype.getObjectProperty = function () {\\n    return this.isObjectProperty() ? this._dimensions[0] : null;\\n  };\\n  /**\\n   * Test whether this index contains only a single value.\\n   *\\n   * This is the case when the index is created with only scalar values as ranges,\\n   * not for ranges resolving into a single value.\\n   * @memberof Index\\n   * @return {boolean} isScalar\\n   */\\n\\n\\n  Index.prototype.isScalar = function () {\\n    return this._isScalar;\\n  };\\n  /**\\n   * Expand the Index into an array.\\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\\n   * @memberof Index\\n   * @returns {Array} array\\n   */\\n\\n\\n  Index.prototype.toArray = function () {\\n    var array = [];\\n\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      var dimension = this._dimensions[i];\\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\\n    }\\n\\n    return array;\\n  };\\n  /**\\n   * Get the primitive value of the Index, a two dimensional array.\\n   * Equivalent to Index.toArray().\\n   * @memberof Index\\n   * @returns {Array} array\\n   */\\n\\n\\n  Index.prototype.valueOf = Index.prototype.toArray;\\n  /**\\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\\n   * @memberof Index\\n   * @returns {String} str\\n   */\\n\\n  Index.prototype.toString = function () {\\n    var strings = [];\\n\\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\\n      var dimension = this._dimensions[i];\\n\\n      if (typeof dimension === 'string') {\\n        strings.push(JSON.stringify(dimension));\\n      } else {\\n        strings.push(dimension.toString());\\n      }\\n    }\\n\\n    return '[' + strings.join(', ') + ']';\\n  };\\n  /**\\n   * Get a JSON representation of the Index\\n   * @memberof Index\\n   * @returns {Object} Returns a JSON object structured as:\\n   *                   `{\\\"mathjs\\\": \\\"Index\\\", \\\"ranges\\\": [{\\\"mathjs\\\": \\\"Range\\\", start: 0, end: 10, step:1}, ...]}`\\n   */\\n\\n\\n  Index.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'Index',\\n      dimensions: this._dimensions\\n    };\\n  };\\n  /**\\n   * Instantiate an Index from a JSON object\\n   * @memberof Index\\n   * @param {Object} json A JSON object structured as:\\n   *                     `{\\\"mathjs\\\": \\\"Index\\\", \\\"dimensions\\\": [{\\\"mathjs\\\": \\\"Range\\\", start: 0, end: 10, step:1}, ...]}`\\n   * @return {Index}\\n   */\\n\\n\\n  Index.fromJSON = function (json) {\\n    return Index.create(json.dimensions);\\n  };\\n\\n  return Index;\\n}, {\\n  isClass: true\\n});\\nexports.createIndexClass = createIndexClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createIndexClass\",\"_is\",\"_object\",\"_number\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"Index\",\"ranges\",\"SyntaxError\",\"_dimensions\",\"_isScalar\",\"i\",\"ii\",\"arguments\",\"length\",\"arg\",\"isRange\",\"push\",\"Array\",\"isArray\",\"isMatrix\",\"m\",\"_createImmutableMatrix\",\"valueOf\",\"size\",\"TypeError\",\"l\",\"isInteger\",\"ImmutableDenseMatrix\",\"prototype\",\"type\",\"isIndex\",\"clone\",\"Index.prototype.clone\",\"index\",\"create\",\"Index.create\",\"apply\",\"Index.prototype.size\",\"d\",\"max\",\"Index.prototype.max\",\"values\",\"range\",\"min\",\"Index.prototype.min\",\"forEach\",\"Index.prototype.forEach\",\"callback\",\"dimension\",\"Index.prototype.dimension\",\"dim\",\"isObjectProperty\",\"Index.prototype.isObjectProperty\",\"getObjectProperty\",\"Index.prototype.getObjectProperty\",\"isScalar\",\"Index.prototype.isScalar\",\"toArray\",\"Index.prototype.toArray\",\"array\",\"toString\",\"Index.prototype.toString\",\"strings\",\"JSON\",\"stringify\",\"join\",\"toJSON\",\"Index.prototype.toJSON\",\"mathjs\",\"dimensions\",\"fromJSON\",\"Index.fromJSON\",\"json\",\"isClass\"]\n}\n"]