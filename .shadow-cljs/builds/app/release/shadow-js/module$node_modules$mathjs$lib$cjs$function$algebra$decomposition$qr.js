["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/decomposition/qr.js"],"~:js","shadow$provide[277]=function(c,b,y,a){function q(){q=Object.assign||function(f){for(var u=1;u<arguments.length;u++){var k=arguments[u],t;for(t in k)Object.prototype.hasOwnProperty.call(k,t)&&(f[t]=k[t])}return f};return q.apply(this,arguments)}Object.defineProperty(a,\"__esModule\",{value:!0});a.createQr=void 0;c=b(25);c=(0,c.factory)(\"qr\",\"typed matrix zeros identity isZero equal sign sqrt conj unaryMinus addScalar divideScalar multiplyScalar subtract complex\".split(\" \"),function(f){function u(F){var E=\nF._size[0],G=F._size[1],I=d([E],\"dense\"),L=I._data;F=F.clone();var M=F._data,S,P,R=g([E],\"\");for(P=0;P<Math.min(G,E);++P){var ba=M[P][P];var Q=C(h(ba,0)?1:n(ba)),T=v(Q),Y=0;for(S=P;S<E;S++)Y=z(Y,B(M[S][P],v(M[S][P])));Q=B(Q,r(Y));if(!l(Q)){ba=x(ba,Q);R[P]=1;for(S=P+1;S<E;S++)R[S]=w(M[S][P],ba);Q=C(v(w(ba,Q)));Y=void 0;for(ba=P;ba<G;ba++){Y=0;for(S=P;S<E;S++)Y=z(Y,B(v(R[S]),M[S][ba]));Y=B(Y,Q);for(S=P;S<E;S++)M[S][ba]=B(x(M[S][ba],B(R[S],Y)),T)}for(S=0;S<E;S++){Y=0;for(ba=P;ba<E;ba++)Y=z(Y,B(L[S][ba],\nR[ba]));Y=B(Y,Q);for(ba=P;ba<E;++ba)L[S][ba]=w(x(L[S][ba],B(Y,v(R[ba]))),T)}}}return{Q:I,R:F,toString:function(){return\"Q: \"+this.Q.toString()+\"\\nR: \"+this.R.toString()}}}function k(F){var E=u(F),G=E.R._data;if(0<F._data.length){F=\"Complex\"===G[0][0].type?D(0):0;for(var I=0;I<G.length;++I)for(var L=0;L<I&&L<(G[0]||[]).length;++L)G[I][L]=F}return E}var t=f.typed,p=f.matrix,g=f.zeros,d=f.identity,l=f.isZero,h=f.equal,n=f.sign,r=f.sqrt,v=f.conj,C=f.unaryMinus,z=f.addScalar,w=f.divideScalar,B=f.multiplyScalar,\nx=f.subtract,D=f.complex;return q(t(\"qr\",{DenseMatrix:function(F){return k(F)},SparseMatrix:function(F){throw Error(\"qr not implemented for sparse matrices yet\");},Array:function(F){F=p(F);F=k(F);return{Q:F.Q.valueOf(),R:F.R.valueOf()}}}),{_denseQRimpl:u})});a.createQr=c}","~:source","shadow$provide[277] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQr = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\nvar createQr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      zeros = _ref.zeros,\n      identity = _ref.identity,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      sign = _ref.sign,\n      sqrt = _ref.sqrt,\n      conj = _ref.conj,\n      unaryMinus = _ref.unaryMinus,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      complex = _ref.complex;\n\n  /**\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\n   * two matrices (`Q`, `R`) where `Q` is an\n   * orthogonal matrix and `R` is an upper triangular matrix.\n   *\n   * Syntax:\n   *\n   *    math.qr(A)\n   *\n   * Example:\n   *\n   *    const m = [\n   *      [1, -1,  4],\n   *      [1,  4, -2],\n   *      [1,  4,  2],\n   *      [1,  -1, 0]\n   *    ]\n   *    const result = math.qr(m)\n   *    // r = {\n   *    //   Q: [\n   *    //     [0.5, -0.5,   0.5],\n   *    //     [0.5,  0.5,  -0.5],\n   *    //     [0.5,  0.5,   0.5],\n   *    //     [0.5, -0.5,  -0.5],\n   *    //   ],\n   *    //   R: [\n   *    //     [2, 3,  2],\n   *    //     [0, 5, -2],\n   *    //     [0, 0,  4],\n   *    //     [0, 0,  0]\n   *    //   ]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lusolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array\n   * for which to get the QR decomposition.\n   *\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\n   * matrix and R: the upper triangular matrix\n   */\n  return _extends(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseQR(m); // result\n\n\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl: _denseQRimpl\n  });\n\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data; // vars\n\n    var i, j, k;\n    var w = zeros([rows], '');\n\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\n       * **k-th Household matrix**\n       *\n       * The matrix I - 2*v*transpose(v)\n       * x     = first column of A\n       * x1    = first element of x\n       * alpha = x1 / |x1| * |x|\n       * e1    = tranpose([1, 0, 0, ...])\n       * u     = x - alpha * e1\n       * v     = u / |u|\n       *\n       * Household matrix = I - 2 * v * tranpose(v)\n       *\n       *  * Initially Q = I and R = A.\n       *  * Household matrix is a reflection in a plane normal to v which\n       *    will zero out all but the top right element in R.\n       *  * Appplying reflection to both Q and R will not change product.\n       *  * Repeat this process on the (1,1) minor to get R as an upper\n       *    triangular matrix.\n       *  * Reflections leave the magnitude of the columns of Q unchanged\n       *    so Q remains othoganal.\n       *\n       */\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n\n        w[k] = 1;\n\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        } // tau = - conj(u1 / alpha)\n\n\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n        /*\n         * tau and w have been choosen so that\n         *\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\n         */\n\n        /*\n         * -- calculate R = R - tau * w * tranpose(w) * R --\n         * Only do calculation with rows k to (rows-1)\n         * Additionally columns 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n        for (j = k; j < cols; j++) {\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\n\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          } // calculate the jth element of [tau * transpose(w) * R]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\n         * Q is a square matrix (rows x rows)\n         * Only do calculation with columns k to (rows-1)\n         * Additionally rows 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n\n        for (i = 0; i < rows; i++) {\n          s = 0.0; // calculate ith element of [Q * w]\n\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          } // calculate the ith element of [tau * Q * w]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    } // return matrices\n\n\n    return {\n      Q: Q,\n      R: R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n\n    var Rdata = ret.R._data;\n\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});\nexports.createQr = createQr;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["SparseMatrix","DenseMatrix","Q","createQr","__esModule","toString","value","R","_denseQRimpl","Array"]],"~:compiled-at",1619135723975,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$qr.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/decomposition/qr.js\"],\n\"sourcesContent\":[\"shadow$provide[277] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createQr = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\\n\\nvar name = 'qr';\\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\\nvar createQr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      zeros = _ref.zeros,\\n      identity = _ref.identity,\\n      isZero = _ref.isZero,\\n      equal = _ref.equal,\\n      sign = _ref.sign,\\n      sqrt = _ref.sqrt,\\n      conj = _ref.conj,\\n      unaryMinus = _ref.unaryMinus,\\n      addScalar = _ref.addScalar,\\n      divideScalar = _ref.divideScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      subtract = _ref.subtract,\\n      complex = _ref.complex;\\n\\n  /**\\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\\n   * two matrices (`Q`, `R`) where `Q` is an\\n   * orthogonal matrix and `R` is an upper triangular matrix.\\n   *\\n   * Syntax:\\n   *\\n   *    math.qr(A)\\n   *\\n   * Example:\\n   *\\n   *    const m = [\\n   *      [1, -1,  4],\\n   *      [1,  4, -2],\\n   *      [1,  4,  2],\\n   *      [1,  -1, 0]\\n   *    ]\\n   *    const result = math.qr(m)\\n   *    // r = {\\n   *    //   Q: [\\n   *    //     [0.5, -0.5,   0.5],\\n   *    //     [0.5,  0.5,  -0.5],\\n   *    //     [0.5,  0.5,   0.5],\\n   *    //     [0.5, -0.5,  -0.5],\\n   *    //   ],\\n   *    //   R: [\\n   *    //     [2, 3,  2],\\n   *    //     [0, 5, -2],\\n   *    //     [0, 0,  4],\\n   *    //     [0, 0,  0]\\n   *    //   ]\\n   *    // }\\n   *\\n   * See also:\\n   *\\n   *    lup, lusolve\\n   *\\n   * @param {Matrix | Array} A    A two dimensional matrix or array\\n   * for which to get the QR decomposition.\\n   *\\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\\n   * matrix and R: the upper triangular matrix\\n   */\\n  return _extends(typed(name, {\\n    DenseMatrix: function DenseMatrix(m) {\\n      return _denseQR(m);\\n    },\\n    SparseMatrix: function SparseMatrix(m) {\\n      return _sparseQR(m);\\n    },\\n    Array: function Array(a) {\\n      // create dense matrix from array\\n      var m = matrix(a); // lup, use matrix implementation\\n\\n      var r = _denseQR(m); // result\\n\\n\\n      return {\\n        Q: r.Q.valueOf(),\\n        R: r.R.valueOf()\\n      };\\n    }\\n  }), {\\n    _denseQRimpl: _denseQRimpl\\n  });\\n\\n  function _denseQRimpl(m) {\\n    // rows & columns (m x n)\\n    var rows = m._size[0]; // m\\n\\n    var cols = m._size[1]; // n\\n\\n    var Q = identity([rows], 'dense');\\n    var Qdata = Q._data;\\n    var R = m.clone();\\n    var Rdata = R._data; // vars\\n\\n    var i, j, k;\\n    var w = zeros([rows], '');\\n\\n    for (k = 0; k < Math.min(cols, rows); ++k) {\\n      /*\\n       * **k-th Household matrix**\\n       *\\n       * The matrix I - 2*v*transpose(v)\\n       * x     = first column of A\\n       * x1    = first element of x\\n       * alpha = x1 / |x1| * |x|\\n       * e1    = tranpose([1, 0, 0, ...])\\n       * u     = x - alpha * e1\\n       * v     = u / |u|\\n       *\\n       * Household matrix = I - 2 * v * tranpose(v)\\n       *\\n       *  * Initially Q = I and R = A.\\n       *  * Household matrix is a reflection in a plane normal to v which\\n       *    will zero out all but the top right element in R.\\n       *  * Appplying reflection to both Q and R will not change product.\\n       *  * Repeat this process on the (1,1) minor to get R as an upper\\n       *    triangular matrix.\\n       *  * Reflections leave the magnitude of the columns of Q unchanged\\n       *    so Q remains othoganal.\\n       *\\n       */\\n      var pivot = Rdata[k][k];\\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\\n      var conjSgn = conj(sgn);\\n      var alphaSquared = 0;\\n\\n      for (i = k; i < rows; i++) {\\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\\n      }\\n\\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\\n\\n      if (!isZero(alpha)) {\\n        // first element in vector u\\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\\n\\n        w[k] = 1;\\n\\n        for (i = k + 1; i < rows; i++) {\\n          w[i] = divideScalar(Rdata[i][k], u1);\\n        } // tau = - conj(u1 / alpha)\\n\\n\\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\\n        var s = void 0;\\n        /*\\n         * tau and w have been choosen so that\\n         *\\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\\n         */\\n\\n        /*\\n         * -- calculate R = R - tau * w * tranpose(w) * R --\\n         * Only do calculation with rows k to (rows-1)\\n         * Additionally columns 0 to (k-1) will not be changed by this\\n         *   multiplication so do not bother recalculating them\\n         */\\n\\n        for (j = k; j < cols; j++) {\\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\\n\\n          for (i = k; i < rows; i++) {\\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\\n          } // calculate the jth element of [tau * transpose(w) * R]\\n\\n\\n          s = multiplyScalar(s, tau);\\n\\n          for (i = k; i < rows; i++) {\\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\\n          }\\n        }\\n        /*\\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\\n         * Q is a square matrix (rows x rows)\\n         * Only do calculation with columns k to (rows-1)\\n         * Additionally rows 0 to (k-1) will not be changed by this\\n         *   multiplication so do not bother recalculating them\\n         */\\n\\n\\n        for (i = 0; i < rows; i++) {\\n          s = 0.0; // calculate ith element of [Q * w]\\n\\n          for (j = k; j < rows; j++) {\\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\\n          } // calculate the ith element of [tau * Q * w]\\n\\n\\n          s = multiplyScalar(s, tau);\\n\\n          for (j = k; j < rows; ++j) {\\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\\n          }\\n        }\\n      }\\n    } // return matrices\\n\\n\\n    return {\\n      Q: Q,\\n      R: R,\\n      toString: function toString() {\\n        return 'Q: ' + this.Q.toString() + '\\\\nR: ' + this.R.toString();\\n      }\\n    };\\n  }\\n\\n  function _denseQR(m) {\\n    var ret = _denseQRimpl(m);\\n\\n    var Rdata = ret.R._data;\\n\\n    if (m._data.length > 0) {\\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\\n\\n      for (var i = 0; i < Rdata.length; ++i) {\\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\\n          Rdata[i][j] = zero;\\n        }\\n      }\\n    }\\n\\n    return ret;\\n  }\\n\\n  function _sparseQR(m) {\\n    throw new Error('qr not implemented for sparse matrices yet');\\n  }\\n});\\nexports.createQr = createQr;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_extends\",\"Object\",\"assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"apply\",\"defineProperty\",\"value\",\"createQr\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_denseQRimpl\",\"m\",\"rows\",\"_size\",\"cols\",\"Q\",\"identity\",\"Qdata\",\"_data\",\"R\",\"clone\",\"Rdata\",\"k\",\"w\",\"zeros\",\"Math\",\"min\",\"pivot\",\"sgn\",\"unaryMinus\",\"equal\",\"sign\",\"conjSgn\",\"conj\",\"alphaSquared\",\"addScalar\",\"multiplyScalar\",\"alpha\",\"sqrt\",\"isZero\",\"u1\",\"subtract\",\"divideScalar\",\"tau\",\"s\",\"j\",\"toString\",\"_denseQR\",\"ret\",\"zero\",\"type\",\"complex\",\"typed\",\"matrix\",\"DenseMatrix\",\"SparseMatrix\",\"Error\",\"Array\",\"a\",\"r\",\"valueOf\"]\n}\n"]