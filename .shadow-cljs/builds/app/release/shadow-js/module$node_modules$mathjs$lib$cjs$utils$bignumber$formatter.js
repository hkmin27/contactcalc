["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/bignumber/formatter.js"],"~:js","shadow$provide[20]=function(c,b,y,a){function q(t,p,g){var d=new t.constructor(2),l=\"\";if(g){if(1>g)throw Error(\"size must be in greater than 0\");if(!(0,k.isInteger)(g))throw Error(\"size must be an integer\");if(t.greaterThan(d.pow(g-1).sub(1))||t.lessThan(d.pow(g-1).mul(-1)))throw Error(\"Value must be in range [-2^\".concat(g-1,\", 2^\").concat(g-1,\"-1]\"));if(!t.isInteger())throw Error(\"Value must be an integer\");t.lessThan(0)&&(t=t.add(d.pow(g)));l=\"i\".concat(g)}switch(p){case 2:return\"\".concat(t.toBinary()).concat(l);\ncase 8:return\"\".concat(t.toOctal()).concat(l);case 16:return\"\".concat(t.toHexadecimal()).concat(l);default:throw Error(\"Base \".concat(p,\" not supported \"));}}function f(t,p){var g=t.e,d=0===g%3?g:0>g?g-3-g%3:g-g%3;t=t.mul(Math.pow(10,-d));p=t.toPrecision(p);-1!==p.indexOf(\"e\")&&(p=t.toString());return p+\"e\"+(0<=g?\"+\":\"\")+d.toString()}function u(t,p){return void 0!==p?t.toExponential(p-1):t.toExponential()}Object.defineProperty(a,\"__esModule\",{value:!0});a.format=function(t,p){if(\"function\"===typeof p)return p(t);\nif(!t.isFinite())return t.isNaN()?\"NaN\":t.gt(0)?\"Infinity\":\"-Infinity\";var g=\"auto\";if(void 0!==p){p.notation&&(g=p.notation);if(\"number\"===typeof p)var d=p;else p.precision&&(d=p.precision);if(p.wordSize){var l=p.wordSize;if(\"number\"!==typeof l)throw Error('Option \"wordSize\" must be a number');}}switch(g){case \"fixed\":return t.toFixed(d);case \"exponential\":return u(t,d);case \"engineering\":return f(t,d);case \"bin\":return q(t,2,l);case \"oct\":return q(t,8,l);case \"hex\":return q(t,16,l);case \"auto\":g=\np&&void 0!==p.lowerExp?p.lowerExp:-3;p=p&&void 0!==p.upperExp?p.upperExp:5;if(t.isZero())return\"0\";l=t.toSignificantDigits(d);var h=l.e;return(h>=g&&h<p?l.toFixed():u(t,d)).replace(/((\\.\\d*?)(0+))($|e)/,function(n,r,v,C,z){return\".\"!==v?v+z:z});default:throw Error('Unknown notation \"'+g+'\". Choose \"auto\", \"exponential\", \"fixed\", \"bin\", \"oct\", or \"hex.');}};a.toEngineering=f;a.toExponential=u;a.toFixed=function(t,p){return t.toFixed(p)};var k=b(19)}","~:source","shadow$provide[20] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.format = format;\nexports.toEngineering = toEngineering;\nexports.toExponential = toExponential;\nexports.toFixed = toFixed;\n\nvar _number = require(\"../number.js\");\n\n/**\n * Formats a BigNumber in a given base\n * @param {BigNumber} n\n * @param {number} base\n * @param {number} size\n * @returns {string}\n */\nfunction formatBigNumberToBase(n, base, size) {\n  var BigNumberCtor = n.constructor;\n  var big2 = new BigNumberCtor(2);\n  var suffix = '';\n\n  if (size) {\n    if (size < 1) {\n      throw new Error('size must be in greater than 0');\n    }\n\n    if (!(0, _number.isInteger)(size)) {\n      throw new Error('size must be an integer');\n    }\n\n    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {\n      throw new Error(\"Value must be in range [-2^\".concat(size - 1, \", 2^\").concat(size - 1, \"-1]\"));\n    }\n\n    if (!n.isInteger()) {\n      throw new Error('Value must be an integer');\n    }\n\n    if (n.lessThan(0)) {\n      n = n.add(big2.pow(size));\n    }\n\n    suffix = \"i\".concat(size);\n  }\n\n  switch (base) {\n    case 2:\n      return \"\".concat(n.toBinary()).concat(suffix);\n\n    case 8:\n      return \"\".concat(n.toOctal()).concat(suffix);\n\n    case 16:\n      return \"\".concat(n.toHexadecimal()).concat(suffix);\n\n    default:\n      throw new Error(\"Base \".concat(base, \" not supported \"));\n  }\n}\n/**\n * Convert a BigNumber to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lower` and `upper` bounds, and uses\n *                                          exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                         'bin', 'oct, or\n *                         'hex'            Format the number using binary, octal,\n *                                          or hexadecimal notation.\n *                                          For example '0b1101' and '0x10fe'.\n *                     {number} wordSize    The word size in bits to use for formatting\n *                                          in binary, octal, or hexadecimal notation.\n *                                          To be used only with 'bin', 'oct', or 'hex'\n *                                          values for 'notation' option. When this option\n *                                          is defined the value is formatted as a signed\n *                                          twos complement integer of the given word size\n *                                          and the size suffix is appended to the output.\n *                                          For example\n *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.\n *                                          Default value is undefined.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential',\n *                                          'engineering', and 'auto',\n *                                          `precision` defines the total\n *                                          number of significant digits returned.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point.\n *                                          `precision` is undefined by default.\n *                     {number} lowerExp    Exponent determining the lower boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `-3`.\n *                     {number} upperExp    Exponent determining the upper boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `5`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4)                                        // '6.4'\n *    format(1240000)                                    // '1.24e6'\n *    format(1/3)                                        // '0.3333333333333333'\n *    format(1/3, 3)                                     // '0.333'\n *    format(21385, 2)                                   // '21000'\n *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'\n *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'\n *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'\n *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'\n *\n * @param {BigNumber} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\n\n\nfunction format(value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  } // handle special cases\n\n\n  if (!value.isFinite()) {\n    return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';\n  } // default values for options\n\n\n  var notation = 'auto';\n  var precision;\n  var wordSize;\n\n  if (options !== undefined) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    } // determine precision from options\n\n\n    if (typeof options === 'number') {\n      precision = options;\n    } else if (options.precision) {\n      precision = options.precision;\n    }\n\n    if (options.wordSize) {\n      wordSize = options.wordSize;\n\n      if (typeof wordSize !== 'number') {\n        throw new Error('Option \"wordSize\" must be a number');\n      }\n    }\n  } // handle the various notations\n\n\n  switch (notation) {\n    case 'fixed':\n      return toFixed(value, precision);\n\n    case 'exponential':\n      return toExponential(value, precision);\n\n    case 'engineering':\n      return toEngineering(value, precision);\n\n    case 'bin':\n      return formatBigNumberToBase(value, 2, wordSize);\n\n    case 'oct':\n      return formatBigNumberToBase(value, 8, wordSize);\n\n    case 'hex':\n      return formatBigNumberToBase(value, 16, wordSize);\n\n    case 'auto':\n      {\n        // determine lower and upper bound for exponential notation.\n        // TODO: implement support for upper and lower to be BigNumbers themselves\n        var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\n        var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero\n\n        if (value.isZero()) return '0'; // determine whether or not to output exponential notation\n\n        var str;\n        var rounded = value.toSignificantDigits(precision);\n        var exp = rounded.e;\n\n        if (exp >= lowerExp && exp < upperExp) {\n          // normal number notation\n          str = rounded.toFixed();\n        } else {\n          // exponential notation\n          str = toExponential(value, precision);\n        } // remove trailing zeros after the decimal point\n\n\n        return str.replace(/((\\.\\d*?)(0+))($|e)/, function () {\n          var digits = arguments[2];\n          var e = arguments[4];\n          return digits !== '.' ? digits + e : e;\n        });\n      }\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' + 'Choose \"auto\", \"exponential\", \"fixed\", \"bin\", \"oct\", or \"hex.');\n  }\n}\n/**\n * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\n * @param {BigNumber | string} value\n * @param {number} [precision]        Optional number of significant figures to return.\n */\n\n\nfunction toEngineering(value, precision) {\n  // find nearest lower multiple of 3 for exponent\n  var e = value.e;\n  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent\n\n  var valueWithoutExp = value.mul(Math.pow(10, -newExp));\n  var valueStr = valueWithoutExp.toPrecision(precision);\n\n  if (valueStr.indexOf('e') !== -1) {\n    valueStr = valueWithoutExp.toString();\n  }\n\n  return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();\n}\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {BigNumber} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n * @returns {string} str\n */\n\n\nfunction toExponential(value, precision) {\n  if (precision !== undefined) {\n    return value.toExponential(precision - 1); // Note the offset of one\n  } else {\n    return value.toExponential();\n  }\n}\n/**\n * Format a number with fixed notation.\n * @param {BigNumber} value\n * @param {number} [precision=undefined] Optional number of decimals after the\n *                                       decimal point. Undefined by default.\n */\n\n\nfunction toFixed(value, precision) {\n  return value.toFixed(precision);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number"]],"~:properties",["^5",["toFixed","__esModule","toEngineering","value","toExponential","format"]],"~:compiled-at",1619135723712,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$bignumber$formatter.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAoB7DC,QAASA,EAAqB,CAACC,CAAD,CAAIC,CAAJ,CAAUC,CAAV,CAAgB,CAE5C,IAAIC,EAAO,IADSH,CAAEI,CAAAA,WACX,CAAkB,CAAlB,CAAX,CACIC,EAAS,EAEb,IAAIH,CAAJ,CAAU,CACR,GAAW,CAAX,CAAIA,CAAJ,CACE,KAAUI,MAAJ,CAAU,gCAAV,CAAN,CAGF,GAAI,CAAC,CAAC,CAAA,CAAGC,CAAQC,CAAAA,SAAZ,EAAuBN,CAAvB,CAAL,CACE,KAAUI,MAAJ,CAAU,yBAAV,CAAN,CAGF,GAAIN,CAAES,CAAAA,WAAF,CAAcN,CAAKO,CAAAA,GAAL,CAASR,CAAT,CAAgB,CAAhB,CAAmBS,CAAAA,GAAnB,CAAuB,CAAvB,CAAd,CAAJ,EAAgDX,CAAEY,CAAAA,QAAF,CAAWT,CAAKO,CAAAA,GAAL,CAASR,CAAT,CAAgB,CAAhB,CAAmBW,CAAAA,GAAnB,CAAuB,EAAvB,CAAX,CAAhD,CACE,KAAUP,MAAJ,CAAU,6BAA8BQ,CAAAA,MAA9B,CAAqCZ,CAArC,CAA4C,CAA5C,CAA+C,MAA/C,CAAuDY,CAAAA,MAAvD,CAA8DZ,CAA9D,CAAqE,CAArE,CAAwE,KAAxE,CAAV,CAAN,CAGF,GAAI,CAACF,CAAEQ,CAAAA,SAAF,EAAL,CACE,KAAUF,MAAJ,CAAU,0BAAV,CAAN,CAGEN,CAAEY,CAAAA,QAAF,CAAW,CAAX,CAAJ,GACEZ,CADF,CACMA,CAAEe,CAAAA,GAAF,CAAMZ,CAAKO,CAAAA,GAAL,CAASR,CAAT,CAAN,CADN,CAIAG,EAAA,CAAS,GAAIS,CAAAA,MAAJ,CAAWZ,CAAX,CArBD,CAwBV,OAAQD,CAAR,EACE,KAAK,CAAL,CACE,MAAO,EAAGa,CAAAA,MAAH,CAAUd,CAAEgB,CAAAA,QAAF,EAAV,CAAwBF,CAAAA,MAAxB,CAA+BT,CAA/B,CAET;KAAK,CAAL,CACE,MAAO,EAAGS,CAAAA,MAAH,CAAUd,CAAEiB,CAAAA,OAAF,EAAV,CAAuBH,CAAAA,MAAvB,CAA8BT,CAA9B,CAET,MAAK,EAAL,CACE,MAAO,EAAGS,CAAAA,MAAH,CAAUd,CAAEkB,CAAAA,aAAF,EAAV,CAA6BJ,CAAAA,MAA7B,CAAoCT,CAApC,CAET,SACE,KAAUC,MAAJ,CAAU,OAAQQ,CAAAA,MAAR,CAAeb,CAAf,CAAqB,iBAArB,CAAV,CAAN,CAXJ,CA7B4C,CAgO9CkB,QAASA,EAAa,CAACC,CAAD,CAAQC,CAAR,CAAmB,CAEvC,IAAIC,EAAIF,CAAME,CAAAA,CAAd,CACIC,EAAmB,CAAV,GAAAD,CAAA,CAAI,CAAJ,CAAcA,CAAd,CAAsB,CAAJ,CAAAA,CAAA,CAAQA,CAAR,CAAY,CAAZ,CAAgBA,CAAhB,CAAoB,CAApB,CAAwBA,CAAxB,CAA4BA,CAA5B,CAAgC,CAE3DE,EAAAA,CAAkBJ,CAAMP,CAAAA,GAAN,CAAUY,IAAKf,CAAAA,GAAL,CAAS,EAAT,CAAa,CAACa,CAAd,CAAV,CAClBG,EAAAA,CAAWF,CAAgBG,CAAAA,WAAhB,CAA4BN,CAA5B,CAEe,GAA9B,GAAIK,CAASE,CAAAA,OAAT,CAAiB,GAAjB,CAAJ,GACEF,CADF,CACaF,CAAgBK,CAAAA,QAAhB,EADb,CAIA,OAAOH,EAAP,CAAkB,GAAlB,EAA8B,CAAL,EAAAJ,CAAA,CAAS,GAAT,CAAe,EAAxC,EAA8CC,CAAOM,CAAAA,QAAP,EAZP,CAwBzCC,QAASA,EAAa,CAACV,CAAD,CAAQC,CAAR,CAAmB,CACvC,MAAkBU,KAAAA,EAAlB,GAAIV,CAAJ,CACSD,CAAMU,CAAAA,aAAN,CAAoBT,CAApB,CAAgC,CAAhC,CADT,CAGSD,CAAMU,CAAAA,aAAN,EAJ8B,CAzQzCE,MAAOC,CAAAA,cAAP,CAAsBnC,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CsB,MAAO,CAAA,CADoC,CAA7C,CAGAtB,EAAQoC,CAAAA,MAAR,CA4IAA,QAAe,CAACd,CAAD,CAAQe,CAAR,CAAiB,CAC9B,GAAuB,UAAvB,GAAI,MAAOA,EAAX,CAEE,MAAOA,EAAA,CAAQf,CAAR,CAIT;GAAI,CAACA,CAAMgB,CAAAA,QAAN,EAAL,CACE,MAAOhB,EAAMiB,CAAAA,KAAN,EAAA,CAAgB,KAAhB,CAAwBjB,CAAMkB,CAAAA,EAAN,CAAS,CAAT,CAAA,CAAc,UAAd,CAA2B,WAI5D,KAAIC,EAAW,MAIf,IAAgBR,IAAAA,EAAhB,GAAII,CAAJ,CAA2B,CAErBA,CAAQI,CAAAA,QAAZ,GACEA,CADF,CACaJ,CAAQI,CAAAA,QADrB,CAKA,IAAuB,QAAvB,GAAI,MAAOJ,EAAX,CACE,IAAAd,EAAYc,CADd,KAEWA,EAAQd,CAAAA,SAAZ,GACLA,CADK,CACOc,CAAQd,CAAAA,SADf,CAIP,IAAIc,CAAQK,CAAAA,QAAZ,CAAsB,CACpB,IAAAA,EAAWL,CAAQK,CAAAA,QAEnB,IAAwB,QAAxB,GAAI,MAAOA,EAAX,CACE,KAAUlC,MAAJ,CAAU,oCAAV,CAAN,CAJkB,CAbG,CAuB3B,OAAQiC,CAAR,EACE,KAAK,OAAL,CACE,MAAenB,EAiGNqB,CAAAA,OAAN,CAjGmBpB,CAiGnB,CA/FL,MAAK,aAAL,CACE,MAAOS,EAAA,CAAcV,CAAd,CAAqBC,CAArB,CAET,MAAK,aAAL,CACE,MAAOF,EAAA,CAAcC,CAAd,CAAqBC,CAArB,CAET,MAAK,KAAL,CACE,MAAOtB,EAAA,CAAsBqB,CAAtB,CAA6B,CAA7B,CAAgCoB,CAAhC,CAET,MAAK,KAAL,CACE,MAAOzC,EAAA,CAAsBqB,CAAtB,CAA6B,CAA7B,CAAgCoB,CAAhC,CAET,MAAK,KAAL,CACE,MAAOzC,EAAA,CAAsBqB,CAAtB,CAA6B,EAA7B,CAAiCoB,CAAjC,CAET,MAAK,MAAL,CAIQE,CAAAA;AAAWP,CAAA,EAAgCJ,IAAAA,EAAhC,GAAWI,CAAQO,CAAAA,QAAnB,CAA4CP,CAAQO,CAAAA,QAApD,CAA+D,EAC1EC,EAAAA,CAAWR,CAAA,EAAgCJ,IAAAA,EAAhC,GAAWI,CAAQQ,CAAAA,QAAnB,CAA4CR,CAAQQ,CAAAA,QAApD,CAA+D,CAE9E,IAAIvB,CAAMwB,CAAAA,MAAN,EAAJ,CAAoB,MAAO,GAGvBC,EAAAA,CAAUzB,CAAM0B,CAAAA,mBAAN,CAA0BzB,CAA1B,CACd,KAAI0B,EAAMF,CAAQvB,CAAAA,CAWlB,OAAW0B,CATPD,CAAJE,EAAWP,CAAXO,EAAuBF,CAAvBE,CAA6BN,CAA7BM,CAEQJ,CAAQJ,CAAAA,OAAR,EAFRQ,CAKQnB,CAAA,CAAcV,CAAd,CAAqBC,CAArB,CAIG2B,EAAAA,OAAJ,CAAY,qBAAZ,CAAmC,QAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAG,CAGpD,MAAkB,GAAX,GAFME,CAEN,CAFMA,CAEN,CADC5B,CACD,CADCA,CAF4C,CAA/C,CAOX,SACE,KAAUhB,MAAJ,CAAU,oBAAV,CAAiCiC,CAAjC,CAA4C,kEAA5C,CAAN,CAjDJ,CAvC8B,CA3IhCzC,EAAQqB,CAAAA,aAAR,CAAwBA,CACxBrB,EAAQgC,CAAAA,aAAR,CAAwBA,CACxBhC,EAAQ2C,CAAAA,OAAR,CAkRAA,QAAgB,CAACrB,CAAD,CAAQC,CAAR,CAAmB,CACjC,MAAOD,EAAMqB,CAAAA,OAAN,CAAcpB,CAAd,CAD0B,CAhRnC,KAAId,EAAUX,CAAA,CAAQ,EAAR,CAX+C;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/bignumber/formatter.js\"],\n\"sourcesContent\":[\"shadow$provide[20] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.format = format;\\nexports.toEngineering = toEngineering;\\nexports.toExponential = toExponential;\\nexports.toFixed = toFixed;\\n\\nvar _number = require(\\\"../number.js\\\");\\n\\n/**\\n * Formats a BigNumber in a given base\\n * @param {BigNumber} n\\n * @param {number} base\\n * @param {number} size\\n * @returns {string}\\n */\\nfunction formatBigNumberToBase(n, base, size) {\\n  var BigNumberCtor = n.constructor;\\n  var big2 = new BigNumberCtor(2);\\n  var suffix = '';\\n\\n  if (size) {\\n    if (size < 1) {\\n      throw new Error('size must be in greater than 0');\\n    }\\n\\n    if (!(0, _number.isInteger)(size)) {\\n      throw new Error('size must be an integer');\\n    }\\n\\n    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {\\n      throw new Error(\\\"Value must be in range [-2^\\\".concat(size - 1, \\\", 2^\\\").concat(size - 1, \\\"-1]\\\"));\\n    }\\n\\n    if (!n.isInteger()) {\\n      throw new Error('Value must be an integer');\\n    }\\n\\n    if (n.lessThan(0)) {\\n      n = n.add(big2.pow(size));\\n    }\\n\\n    suffix = \\\"i\\\".concat(size);\\n  }\\n\\n  switch (base) {\\n    case 2:\\n      return \\\"\\\".concat(n.toBinary()).concat(suffix);\\n\\n    case 8:\\n      return \\\"\\\".concat(n.toOctal()).concat(suffix);\\n\\n    case 16:\\n      return \\\"\\\".concat(n.toHexadecimal()).concat(suffix);\\n\\n    default:\\n      throw new Error(\\\"Base \\\".concat(base, \\\" not supported \\\"));\\n  }\\n}\\n/**\\n * Convert a BigNumber to a formatted string representation.\\n *\\n * Syntax:\\n *\\n *    format(value)\\n *    format(value, options)\\n *    format(value, precision)\\n *    format(value, fn)\\n *\\n * Where:\\n *\\n *    {number} value   The value to be formatted\\n *    {Object} options An object with formatting options. Available options:\\n *                     {string} notation\\n *                         Number notation. Choose from:\\n *                         'fixed'          Always use regular number notation.\\n *                                          For example '123.40' and '14000000'\\n *                         'exponential'    Always use exponential notation.\\n *                                          For example '1.234e+2' and '1.4e+7'\\n *                         'auto' (default) Regular number notation for numbers\\n *                                          having an absolute value between\\n *                                          `lower` and `upper` bounds, and uses\\n *                                          exponential notation elsewhere.\\n *                                          Lower bound is included, upper bound\\n *                                          is excluded.\\n *                                          For example '123.4' and '1.4e7'.\\n *                         'bin', 'oct, or\\n *                         'hex'            Format the number using binary, octal,\\n *                                          or hexadecimal notation.\\n *                                          For example '0b1101' and '0x10fe'.\\n *                     {number} wordSize    The word size in bits to use for formatting\\n *                                          in binary, octal, or hexadecimal notation.\\n *                                          To be used only with 'bin', 'oct', or 'hex'\\n *                                          values for 'notation' option. When this option\\n *                                          is defined the value is formatted as a signed\\n *                                          twos complement integer of the given word size\\n *                                          and the size suffix is appended to the output.\\n *                                          For example\\n *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.\\n *                                          Default value is undefined.\\n *                     {number} precision   A number between 0 and 16 to round\\n *                                          the digits of the number.\\n *                                          In case of notations 'exponential',\\n *                                          'engineering', and 'auto',\\n *                                          `precision` defines the total\\n *                                          number of significant digits returned.\\n *                                          In case of notation 'fixed',\\n *                                          `precision` defines the number of\\n *                                          significant digits after the decimal\\n *                                          point.\\n *                                          `precision` is undefined by default.\\n *                     {number} lowerExp    Exponent determining the lower boundary\\n *                                          for formatting a value with an exponent\\n *                                          when `notation='auto`.\\n *                                          Default value is `-3`.\\n *                     {number} upperExp    Exponent determining the upper boundary\\n *                                          for formatting a value with an exponent\\n *                                          when `notation='auto`.\\n *                                          Default value is `5`.\\n *    {Function} fn    A custom formatting function. Can be used to override the\\n *                     built-in notations. Function `fn` is called with `value` as\\n *                     parameter and must return a string. Is useful for example to\\n *                     format all values inside a matrix in a particular way.\\n *\\n * Examples:\\n *\\n *    format(6.4)                                        // '6.4'\\n *    format(1240000)                                    // '1.24e6'\\n *    format(1/3)                                        // '0.3333333333333333'\\n *    format(1/3, 3)                                     // '0.333'\\n *    format(21385, 2)                                   // '21000'\\n *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'\\n *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'\\n *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'\\n *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'\\n *\\n * @param {BigNumber} value\\n * @param {Object | Function | number} [options]\\n * @return {string} str The formatted value\\n */\\n\\n\\nfunction format(value, options) {\\n  if (typeof options === 'function') {\\n    // handle format(value, fn)\\n    return options(value);\\n  } // handle special cases\\n\\n\\n  if (!value.isFinite()) {\\n    return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';\\n  } // default values for options\\n\\n\\n  var notation = 'auto';\\n  var precision;\\n  var wordSize;\\n\\n  if (options !== undefined) {\\n    // determine notation from options\\n    if (options.notation) {\\n      notation = options.notation;\\n    } // determine precision from options\\n\\n\\n    if (typeof options === 'number') {\\n      precision = options;\\n    } else if (options.precision) {\\n      precision = options.precision;\\n    }\\n\\n    if (options.wordSize) {\\n      wordSize = options.wordSize;\\n\\n      if (typeof wordSize !== 'number') {\\n        throw new Error('Option \\\"wordSize\\\" must be a number');\\n      }\\n    }\\n  } // handle the various notations\\n\\n\\n  switch (notation) {\\n    case 'fixed':\\n      return toFixed(value, precision);\\n\\n    case 'exponential':\\n      return toExponential(value, precision);\\n\\n    case 'engineering':\\n      return toEngineering(value, precision);\\n\\n    case 'bin':\\n      return formatBigNumberToBase(value, 2, wordSize);\\n\\n    case 'oct':\\n      return formatBigNumberToBase(value, 8, wordSize);\\n\\n    case 'hex':\\n      return formatBigNumberToBase(value, 16, wordSize);\\n\\n    case 'auto':\\n      {\\n        // determine lower and upper bound for exponential notation.\\n        // TODO: implement support for upper and lower to be BigNumbers themselves\\n        var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\\n        var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero\\n\\n        if (value.isZero()) return '0'; // determine whether or not to output exponential notation\\n\\n        var str;\\n        var rounded = value.toSignificantDigits(precision);\\n        var exp = rounded.e;\\n\\n        if (exp >= lowerExp && exp < upperExp) {\\n          // normal number notation\\n          str = rounded.toFixed();\\n        } else {\\n          // exponential notation\\n          str = toExponential(value, precision);\\n        } // remove trailing zeros after the decimal point\\n\\n\\n        return str.replace(/((\\\\.\\\\d*?)(0+))($|e)/, function () {\\n          var digits = arguments[2];\\n          var e = arguments[4];\\n          return digits !== '.' ? digits + e : e;\\n        });\\n      }\\n\\n    default:\\n      throw new Error('Unknown notation \\\"' + notation + '\\\". ' + 'Choose \\\"auto\\\", \\\"exponential\\\", \\\"fixed\\\", \\\"bin\\\", \\\"oct\\\", or \\\"hex.');\\n  }\\n}\\n/**\\n * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\\n * @param {BigNumber | string} value\\n * @param {number} [precision]        Optional number of significant figures to return.\\n */\\n\\n\\nfunction toEngineering(value, precision) {\\n  // find nearest lower multiple of 3 for exponent\\n  var e = value.e;\\n  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent\\n\\n  var valueWithoutExp = value.mul(Math.pow(10, -newExp));\\n  var valueStr = valueWithoutExp.toPrecision(precision);\\n\\n  if (valueStr.indexOf('e') !== -1) {\\n    valueStr = valueWithoutExp.toString();\\n  }\\n\\n  return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();\\n}\\n/**\\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\\n * @param {BigNumber} value\\n * @param {number} [precision]  Number of digits in formatted output.\\n *                              If not provided, the maximum available digits\\n *                              is used.\\n * @returns {string} str\\n */\\n\\n\\nfunction toExponential(value, precision) {\\n  if (precision !== undefined) {\\n    return value.toExponential(precision - 1); // Note the offset of one\\n  } else {\\n    return value.toExponential();\\n  }\\n}\\n/**\\n * Format a number with fixed notation.\\n * @param {BigNumber} value\\n * @param {number} [precision=undefined] Optional number of decimals after the\\n *                                       decimal point. Undefined by default.\\n */\\n\\n\\nfunction toFixed(value, precision) {\\n  return value.toFixed(precision);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"formatBigNumberToBase\",\"n\",\"base\",\"size\",\"big2\",\"constructor\",\"suffix\",\"Error\",\"_number\",\"isInteger\",\"greaterThan\",\"pow\",\"sub\",\"lessThan\",\"mul\",\"concat\",\"add\",\"toBinary\",\"toOctal\",\"toHexadecimal\",\"toEngineering\",\"value\",\"precision\",\"e\",\"newExp\",\"valueWithoutExp\",\"Math\",\"valueStr\",\"toPrecision\",\"indexOf\",\"toString\",\"toExponential\",\"undefined\",\"Object\",\"defineProperty\",\"format\",\"options\",\"isFinite\",\"isNaN\",\"gt\",\"notation\",\"wordSize\",\"toFixed\",\"lowerExp\",\"upperExp\",\"isZero\",\"rounded\",\"toSignificantDigits\",\"exp\",\"replace\",\"str\",\"digits\"]\n}\n"]