["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js"],"~:js","shadow$provide[265]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createOperatorNode=void 0;var q=b(14),f=b(24),u=b(21),k=b(147),t=b(255),p=b(260);c=b(25);c=(0,c.factory)(\"OperatorNode\",[\"Node\"],function(g){function d(h,n,r,v){if(!(this instanceof d))throw new SyntaxError(\"Constructor must be called with the new operator\");if(\"string\"!==typeof h)throw new TypeError('string expected for parameter \"op\"');if(\"string\"!==typeof n)throw new TypeError('string expected for parameter \"fn\"');\nif(!Array.isArray(r)||!r.every(q.isNode))throw new TypeError('Array containing Nodes expected for parameter \"args\"');this.implicit=!0===v;this.op=h;this.fn=n;this.args=r||[]}function l(h,n,r,v,C){var z=(0,t.getPrecedence)(h,n),w=(0,t.getAssociativity)(h,n);if(\"all\"===n||2<v.length&&\"OperatorNode:add\"!==h.getIdentifier()&&\"OperatorNode:multiply\"!==h.getIdentifier())return v.map(function(L){switch(L.getContent().type){case \"ArrayNode\":case \"ConstantNode\":case \"SymbolNode\":case \"ParenthesisNode\":return!1;\ndefault:return!0}});switch(v.length){case 0:var B=[];break;case 1:var x=(0,t.getPrecedence)(v[0],n);if(C&&null!==x){if(\"keep\"===n){var D=v[0].getIdentifier();var F=h.getIdentifier()}else D=v[0].getContent().getIdentifier(),F=h.getContent().getIdentifier();if(!1===t.properties[z][F].latexLeftParens){B=[!1];break}if(!1===t.properties[x][D].latexParens){B=[!1];break}}if(null===x){B=[!1];break}if(x<=z){B=[!0];break}B=[!1];break;case 2:x=(0,t.getPrecedence)(v[0],n);D=(0,t.isAssociativeWith)(h,v[0],n);\nD=null===x?!1:x!==z||\"right\"!==w||D?x<z?!0:!1:!0;F=(0,t.getPrecedence)(v[1],n);var E=(0,t.isAssociativeWith)(h,v[1],n);E=null===F?!1:F!==z||\"left\"!==w||E?F<z?!0:!1:!0;if(C){if(\"keep\"===n){C=h.getIdentifier();var G=h.args[0].getIdentifier();var I=h.args[1].getIdentifier()}else C=h.getContent().getIdentifier(),G=h.args[0].getContent().getIdentifier(),I=h.args[1].getContent().getIdentifier();null!==x&&(!1===t.properties[z][C].latexLeftParens&&(D=!1),!1===t.properties[x][G].latexParens&&(D=!1));null!==\nF&&(!1===t.properties[z][C].latexRightParens&&(E=!1),!1===t.properties[F][I].latexParens&&(E=!1))}B=[D,E];break;default:if(\"OperatorNode:add\"===h.getIdentifier()||\"OperatorNode:multiply\"===h.getIdentifier())B=v.map(function(L){var M=(0,t.getPrecedence)(L,n),S=(0,t.isAssociativeWith)(h,L,n);L=(0,t.getAssociativity)(L,n);return null!==M&&(z===M&&w===L&&!S||M<z)?!0:!1})}2<=v.length&&\"OperatorNode:multiply\"===h.getIdentifier()&&h.implicit&&\"auto\"===n&&\"hide\"===r&&(B=v.map(function(L,M){L=\"ParenthesisNode\"===\nL.getIdentifier();return B[M]||L?!0:!1}));return B}d.prototype=new g.Node;d.prototype.type=\"OperatorNode\";d.prototype.isOperatorNode=!0;d.prototype._compile=function(h,n){if(\"string\"!==typeof this.fn||!(0,k.isSafeMethod)(h,this.fn)){if(h[this.fn])throw Error('No access to function \"'+this.fn+'\"');throw Error(\"Function \"+this.fn+' missing in provided namespace \"math\"');}var r=(0,k.getSafeProperty)(h,this.fn),v=(0,f.map)(this.args,function(B){return B._compile(h,n)});if(1===v.length){var C=v[0];return function(B,\nx,D){return r(C(B,x,D))}}if(2===v.length){var z=v[0],w=v[1];return function(B,x,D){return r(z(B,x,D),w(B,x,D))}}return function(B,x,D){return r.apply(null,(0,f.map)(v,function(F){return F(B,x,D)}))}};d.prototype.forEach=function(h){for(var n=0;n<this.args.length;n++)h(this.args[n],\"args[\"+n+\"]\",this)};d.prototype.map=function(h){for(var n=[],r=0;r<this.args.length;r++)n[r]=this._ifNode(h(this.args[r],\"args[\"+r+\"]\",this));return new d(this.op,this.fn,n,this.implicit)};d.prototype.clone=function(){return new d(this.op,\nthis.fn,this.args.slice(0),this.implicit)};d.prototype.isUnary=function(){return 1===this.args.length};d.prototype.isBinary=function(){return 2===this.args.length};d.prototype._toString=function(h){var n=h&&h.parenthesis?h.parenthesis:\"keep\",r=h&&h.implicit?h.implicit:\"hide\",v=this.args,C=l(this,n,r,v,!1);return 1===v.length?(r=(0,t.getAssociativity)(this,n),v=v[0].toString(h),C[0]&&(v=\"(\"+v+\")\"),n=/[a-zA-Z]+/.test(this.op),\"right\"===r?this.op+(n?\" \":\"\")+v:\"left\"===r?v+(n?\" \":\"\")+this.op:v+this.op):\n2===v.length?(n=v[0].toString(h),v=v[1].toString(h),C[0]&&(n=\"(\"+n+\")\"),C[1]&&(v=\"(\"+v+\")\"),this.implicit&&\"OperatorNode:multiply\"===this.getIdentifier()&&\"hide\"===r?n+\" \"+v:n+\" \"+this.op+\" \"+v):2<v.length&&(\"OperatorNode:add\"===this.getIdentifier()||\"OperatorNode:multiply\"===this.getIdentifier())?(v=v.map(function(z,w){z=z.toString(h);C[w]&&(z=\"(\"+z+\")\");return z}),this.implicit&&\"OperatorNode:multiply\"===this.getIdentifier()&&\"hide\"===r?v.join(\" \"):v.join(\" \"+this.op+\" \")):this.fn+\"(\"+this.args.join(\", \")+\n\")\"};d.prototype.toJSON=function(){return{mathjs:\"OperatorNode\",op:this.op,fn:this.fn,args:this.args,implicit:this.implicit}};d.fromJSON=function(h){return new d(h.op,h.fn,h.args,h.implicit)};d.prototype.toHTML=function(h){var n=h&&h.parenthesis?h.parenthesis:\"keep\",r=h&&h.implicit?h.implicit:\"hide\",v=this.args,C=l(this,n,r,v,!1);if(1===v.length)return r=(0,t.getAssociativity)(this,n),v=v[0].toHTML(h),C[0]&&(v='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+v+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e'),\n\"right\"===r?'\\x3cspan class\\x3d\"math-operator math-unary-operator math-lefthand-unary-operator\"\\x3e'+(0,u.escape)(this.op)+\"\\x3c/span\\x3e\"+v:v+'\\x3cspan class\\x3d\"math-operator math-unary-operator math-righthand-unary-operator\"\\x3e'+(0,u.escape)(this.op)+\"\\x3c/span\\x3e\";if(2===v.length)return n=v[0].toHTML(h),v=v[1].toHTML(h),C[0]&&(n='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+n+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e'),C[1]&&\n(v='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+v+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e'),this.implicit&&\"OperatorNode:multiply\"===this.getIdentifier()&&\"hide\"===r?n+'\\x3cspan class\\x3d\"math-operator math-binary-operator math-implicit-binary-operator\"\\x3e\\x3c/span\\x3e'+v:n+'\\x3cspan class\\x3d\"math-operator math-binary-operator math-explicit-binary-operator\"\\x3e'+(0,u.escape)(this.op)+\"\\x3c/span\\x3e\"+v;n=v.map(function(z,w){z=\nz.toHTML(h);C[w]&&(z='\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+z+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e');return z});return 2<v.length&&(\"OperatorNode:add\"===this.getIdentifier()||\"OperatorNode:multiply\"===this.getIdentifier())?this.implicit&&\"OperatorNode:multiply\"===this.getIdentifier()&&\"hide\"===r?n.join('\\x3cspan class\\x3d\"math-operator math-binary-operator math-implicit-binary-operator\"\\x3e\\x3c/span\\x3e'):n.join('\\x3cspan class\\x3d\"math-operator math-binary-operator math-explicit-binary-operator\"\\x3e'+\n(0,u.escape)(this.op)+\"\\x3c/span\\x3e\"):'\\x3cspan class\\x3d\"math-function\"\\x3e'+(0,u.escape)(this.fn)+'\\x3c/span\\x3e\\x3cspan class\\x3d\"math-paranthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+n.join('\\x3cspan class\\x3d\"math-separator\"\\x3e,\\x3c/span\\x3e')+'\\x3cspan class\\x3d\"math-paranthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e'};d.prototype._toTex=function(h){var n=h&&h.parenthesis?h.parenthesis:\"keep\",r=h&&h.implicit?h.implicit:\"hide\",v=this.args,C=l(this,n,r,v,!0),z=p.latexOperators[this.fn];\nz=\"undefined\"===typeof z?this.op:z;if(1===v.length){r=(0,t.getAssociativity)(this,n);var w=v[0].toTex(h);C[0]&&(w=\"\\\\left(\".concat(w,\"\\\\right)\"));return\"right\"===r?z+w:w+z}if(2===v.length){var B=v[0];w=B.toTex(h);C[0]&&(w=\"\\\\left(\".concat(w,\"\\\\right)\"));v=v[1].toTex(h);C[1]&&(v=\"\\\\left(\".concat(v,\"\\\\right)\"));n=\"keep\"===n?B.getIdentifier():B.getContent().getIdentifier();switch(this.getIdentifier()){case \"OperatorNode:divide\":return z+\"{\"+w+\"}{\"+v+\"}\";case \"OperatorNode:pow\":w=\"{\"+w+\"}\";v=\"{\"+v+\"}\";\nswitch(n){case \"ConditionalNode\":case \"OperatorNode:divide\":w=\"\\\\left(\".concat(w,\"\\\\right)\")}break;case \"OperatorNode:multiply\":if(this.implicit&&\"hide\"===r)return w+\"~\"+v}return w+z+v}return 2<v.length&&(\"OperatorNode:add\"===this.getIdentifier()||\"OperatorNode:multiply\"===this.getIdentifier())?(r=v.map(function(x,D){x=x.toTex(h);C[D]&&(x=\"\\\\left(\".concat(x,\"\\\\right)\"));return x}),\"OperatorNode:multiply\"===this.getIdentifier()&&this.implicit?r.join(\"~\"):r.join(z)):\"\\\\mathrm{\"+this.fn+\"}\\\\left(\"+v.map(function(x){return x.toTex(h)}).join(\",\")+\n\"\\\\right)\"};d.prototype.getIdentifier=function(){return this.type+\":\"+this.fn};return d},{isClass:!0,isNode:!0});a.createOperatorNode=c}","~:source","shadow$provide[265] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = (0, _customs.getSafeProperty)(math, this.fn);\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = _latex.latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$module$node_modules$mathjs$lib$cjs$expression$operators","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$latex","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["isUnary","map","forEach","fromJSON","isClass","toHTML","createOperatorNode","prototype","args","_toString","isNode","_toTex","__esModule","fn","implicit","value","getIdentifier","isOperatorNode","mathjs","type","clone","isBinary","op","_compile","toJSON"]],"~:compiled-at",1619135723967,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$OperatorNode.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js\"],\n\"sourcesContent\":[\"shadow$provide[265] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createOperatorNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nvar _operators = require(\\\"../operators.js\\\");\\n\\nvar _latex = require(\\\"../../utils/latex.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'OperatorNode';\\nvar dependencies = ['Node'];\\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Node = _ref.Node;\\n\\n  /**\\n   * @constructor OperatorNode\\n   * @extends {Node}\\n   * An operator with two arguments, like 2+3\\n   *\\n   * @param {string} op           Operator name, for example '+'\\n   * @param {string} fn           Function name, for example 'add'\\n   * @param {Node[]} args         Operator arguments\\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\\n   */\\n  function OperatorNode(op, fn, args, implicit) {\\n    if (!(this instanceof OperatorNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // validate input\\n\\n\\n    if (typeof op !== 'string') {\\n      throw new TypeError('string expected for parameter \\\"op\\\"');\\n    }\\n\\n    if (typeof fn !== 'string') {\\n      throw new TypeError('string expected for parameter \\\"fn\\\"');\\n    }\\n\\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\\n      throw new TypeError('Array containing Nodes expected for parameter \\\"args\\\"');\\n    }\\n\\n    this.implicit = implicit === true;\\n    this.op = op;\\n    this.fn = fn;\\n    this.args = args || [];\\n  }\\n\\n  OperatorNode.prototype = new Node();\\n  OperatorNode.prototype.type = 'OperatorNode';\\n  OperatorNode.prototype.isOperatorNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  OperatorNode.prototype._compile = function (math, argNames) {\\n    // validate fn\\n    if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\\n      if (!math[this.fn]) {\\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \\\"math\\\"');\\n      } else {\\n        throw new Error('No access to function \\\"' + this.fn + '\\\"');\\n      }\\n    }\\n\\n    var fn = (0, _customs.getSafeProperty)(math, this.fn);\\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\\n      return arg._compile(math, argNames);\\n    });\\n\\n    if (evalArgs.length === 1) {\\n      var evalArg0 = evalArgs[0];\\n      return function evalOperatorNode(scope, args, context) {\\n        return fn(evalArg0(scope, args, context));\\n      };\\n    } else if (evalArgs.length === 2) {\\n      var _evalArg = evalArgs[0];\\n      var evalArg1 = evalArgs[1];\\n      return function evalOperatorNode(scope, args, context) {\\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\\n      };\\n    } else {\\n      return function evalOperatorNode(scope, args, context) {\\n        return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\\n          return evalArg(scope, args, context);\\n        }));\\n      };\\n    }\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  OperatorNode.prototype.forEach = function (callback) {\\n    for (var i = 0; i < this.args.length; i++) {\\n      callback(this.args[i], 'args[' + i + ']', this);\\n    }\\n  };\\n  /**\\n   * Create a new OperatorNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {OperatorNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  OperatorNode.prototype.map = function (callback) {\\n    var args = [];\\n\\n    for (var i = 0; i < this.args.length; i++) {\\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\\n    }\\n\\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {OperatorNode}\\n   */\\n\\n\\n  OperatorNode.prototype.clone = function () {\\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\\n  };\\n  /**\\n   * Check whether this is an unary OperatorNode:\\n   * has exactly one argument, like `-a`.\\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\\n   */\\n\\n\\n  OperatorNode.prototype.isUnary = function () {\\n    return this.args.length === 1;\\n  };\\n  /**\\n   * Check whether this is a binary OperatorNode:\\n   * has exactly two arguments, like `a + b`.\\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\\n   */\\n\\n\\n  OperatorNode.prototype.isBinary = function () {\\n    return this.args.length === 2;\\n  };\\n  /**\\n   * Calculate which parentheses are necessary. Gets an OperatorNode\\n   * (which is the root of the tree) and an Array of Nodes\\n   * (this.args) and returns an array where 'true' means that an argument\\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\\n   *\\n   * @param {OperatorNode} root\\n   * @param {string} parenthesis\\n   * @param {Node[]} args\\n   * @param {boolean} latex\\n   * @return {boolean[]}\\n   * @private\\n   */\\n\\n\\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\\n    // precedence of the root OperatorNode\\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis);\\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\\n\\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\\n      return args.map(function (arg) {\\n        switch (arg.getContent().type) {\\n          // Nodes that don't need extra parentheses\\n          case 'ArrayNode':\\n          case 'ConstantNode':\\n          case 'SymbolNode':\\n          case 'ParenthesisNode':\\n            return false;\\n\\n          default:\\n            return true;\\n        }\\n      });\\n    }\\n\\n    var result;\\n\\n    switch (args.length) {\\n      case 0:\\n        result = [];\\n        break;\\n\\n      case 1:\\n        // unary operators\\n        {\\n          // precedence of the operand\\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\\n\\n          if (latex && operandPrecedence !== null) {\\n            var operandIdentifier;\\n            var rootIdentifier;\\n\\n            if (parenthesis === 'keep') {\\n              operandIdentifier = args[0].getIdentifier();\\n              rootIdentifier = root.getIdentifier();\\n            } else {\\n              // Ignore Parenthesis Nodes when not in 'keep' mode\\n              operandIdentifier = args[0].getContent().getIdentifier();\\n              rootIdentifier = root.getContent().getIdentifier();\\n            }\\n\\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\\n              result = [false];\\n              break;\\n            }\\n\\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\\n              result = [false];\\n              break;\\n            }\\n          }\\n\\n          if (operandPrecedence === null) {\\n            // if the operand has no defined precedence, no parens are needed\\n            result = [false];\\n            break;\\n          }\\n\\n          if (operandPrecedence <= precedence) {\\n            // if the operands precedence is lower, parens are needed\\n            result = [true];\\n            break;\\n          } // otherwise, no parens needed\\n\\n\\n          result = [false];\\n        }\\n        break;\\n\\n      case 2:\\n        // binary operators\\n        {\\n          var lhsParens; // left hand side needs parenthesis?\\n          // precedence of the left hand side\\n\\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // is the root node associative with the left hand side\\n\\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\\n\\n          if (lhsPrecedence === null) {\\n            // if the left hand side has no defined precedence, no parens are needed\\n            // FunctionNode for example\\n            lhsParens = false;\\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\\n            // In case of equal precedence, if the root node is left associative\\n            // parens are **never** necessary for the left hand side.\\n            // If it is right associative however, parens are necessary\\n            // if the root node isn't associative with the left hand side\\n            lhsParens = true;\\n          } else if (lhsPrecedence < precedence) {\\n            lhsParens = true;\\n          } else {\\n            lhsParens = false;\\n          }\\n\\n          var rhsParens; // right hand side needs parenthesis?\\n          // precedence of the right hand side\\n\\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis); // is the root node associative with the right hand side?\\n\\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\\n\\n          if (rhsPrecedence === null) {\\n            // if the right hand side has no defined precedence, no parens are needed\\n            // FunctionNode for example\\n            rhsParens = false;\\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\\n            // In case of equal precedence, if the root node is right associative\\n            // parens are **never** necessary for the right hand side.\\n            // If it is left associative however, parens are necessary\\n            // if the root node isn't associative with the right hand side\\n            rhsParens = true;\\n          } else if (rhsPrecedence < precedence) {\\n            rhsParens = true;\\n          } else {\\n            rhsParens = false;\\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\\n\\n\\n          if (latex) {\\n            var _rootIdentifier;\\n\\n            var lhsIdentifier;\\n            var rhsIdentifier;\\n\\n            if (parenthesis === 'keep') {\\n              _rootIdentifier = root.getIdentifier();\\n              lhsIdentifier = root.args[0].getIdentifier();\\n              rhsIdentifier = root.args[1].getIdentifier();\\n            } else {\\n              // Ignore ParenthesisNodes when not in 'keep' mode\\n              _rootIdentifier = root.getContent().getIdentifier();\\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\\n            }\\n\\n            if (lhsPrecedence !== null) {\\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\\n                lhsParens = false;\\n              }\\n\\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\\n                lhsParens = false;\\n              }\\n            }\\n\\n            if (rhsPrecedence !== null) {\\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\\n                rhsParens = false;\\n              }\\n\\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\\n                rhsParens = false;\\n              }\\n            }\\n          }\\n\\n          result = [lhsParens, rhsParens];\\n        }\\n        break;\\n\\n      default:\\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\\n          result = args.map(function (arg) {\\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis);\\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\\n\\n            if (argPrecedence === null) {\\n              // if the argument has no defined precedence, no parens are needed\\n              return false;\\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\\n              return true;\\n            } else if (argPrecedence < precedence) {\\n              return true;\\n            }\\n\\n            return false;\\n          });\\n        }\\n\\n        break;\\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\\n    // printed.\\n\\n\\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\\n      result = args.map(function (arg, index) {\\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\\n\\n        if (result[index] || isParenthesisNode) {\\n          // put in parenthesis?\\n          return true;\\n        }\\n\\n        return false;\\n      });\\n    }\\n\\n    return result;\\n  }\\n  /**\\n   * Get string representation.\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  OperatorNode.prototype._toString = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var implicit = options && options.implicit ? options.implicit : 'hide';\\n    var args = this.args;\\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\\n\\n    if (args.length === 1) {\\n      // unary operators\\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\\n      var operand = args[0].toString(options);\\n\\n      if (parens[0]) {\\n        operand = '(' + operand + ')';\\n      } // for example for \\\"not\\\", we want a space between operand and argument\\n\\n\\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\\n\\n      if (assoc === 'right') {\\n        // prefix operator\\n        return this.op + (opIsNamed ? ' ' : '') + operand;\\n      } else if (assoc === 'left') {\\n        // postfix\\n        return operand + (opIsNamed ? ' ' : '') + this.op;\\n      } // fall back to postfix\\n\\n\\n      return operand + this.op;\\n    } else if (args.length === 2) {\\n      var lhs = args[0].toString(options); // left hand side\\n\\n      var rhs = args[1].toString(options); // right hand side\\n\\n      if (parens[0]) {\\n        // left hand side in parenthesis?\\n        lhs = '(' + lhs + ')';\\n      }\\n\\n      if (parens[1]) {\\n        // right hand side in parenthesis?\\n        rhs = '(' + rhs + ')';\\n      }\\n\\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\\n        return lhs + ' ' + rhs;\\n      }\\n\\n      return lhs + ' ' + this.op + ' ' + rhs;\\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\\n      var stringifiedArgs = args.map(function (arg, index) {\\n        arg = arg.toString(options);\\n\\n        if (parens[index]) {\\n          // put in parenthesis?\\n          arg = '(' + arg + ')';\\n        }\\n\\n        return arg;\\n      });\\n\\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\\n        return stringifiedArgs.join(' ');\\n      }\\n\\n      return stringifiedArgs.join(' ' + this.op + ' ');\\n    } else {\\n      // fallback to formatting as a function call\\n      return this.fn + '(' + this.args.join(', ') + ')';\\n    }\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  OperatorNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'OperatorNode',\\n      op: this.op,\\n      fn: this.fn,\\n      args: this.args,\\n      implicit: this.implicit\\n    };\\n  };\\n  /**\\n   * Instantiate an OperatorNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"OperatorNode\\\", \\\"op\\\": \\\"+\\\", \\\"fn\\\": \\\"add\\\", \\\"args\\\": [...], \\\"implicit\\\": false}`,\\n   *                       where mathjs is optional\\n   * @returns {OperatorNode}\\n   */\\n\\n\\n  OperatorNode.fromJSON = function (json) {\\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\\n  };\\n  /**\\n   * Get HTML representation.\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  OperatorNode.prototype.toHTML = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var implicit = options && options.implicit ? options.implicit : 'hide';\\n    var args = this.args;\\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\\n\\n    if (args.length === 1) {\\n      // unary operators\\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\\n      var operand = args[0].toHTML(options);\\n\\n      if (parens[0]) {\\n        operand = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + operand + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n      }\\n\\n      if (assoc === 'right') {\\n        // prefix operator\\n        return '<span class=\\\"math-operator math-unary-operator math-lefthand-unary-operator\\\">' + (0, _string.escape)(this.op) + '</span>' + operand;\\n      } else {\\n        // postfix when assoc === 'left' or undefined\\n        return operand + '<span class=\\\"math-operator math-unary-operator math-righthand-unary-operator\\\">' + (0, _string.escape)(this.op) + '</span>';\\n      }\\n    } else if (args.length === 2) {\\n      // binary operatoes\\n      var lhs = args[0].toHTML(options); // left hand side\\n\\n      var rhs = args[1].toHTML(options); // right hand side\\n\\n      if (parens[0]) {\\n        // left hand side in parenthesis?\\n        lhs = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + lhs + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n      }\\n\\n      if (parens[1]) {\\n        // right hand side in parenthesis?\\n        rhs = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + rhs + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n      }\\n\\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\\n        return lhs + '<span class=\\\"math-operator math-binary-operator math-implicit-binary-operator\\\"></span>' + rhs;\\n      }\\n\\n      return lhs + '<span class=\\\"math-operator math-binary-operator math-explicit-binary-operator\\\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\\n    } else {\\n      var stringifiedArgs = args.map(function (arg, index) {\\n        arg = arg.toHTML(options);\\n\\n        if (parens[index]) {\\n          // put in parenthesis?\\n          arg = '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + arg + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n        }\\n\\n        return arg;\\n      });\\n\\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\\n          return stringifiedArgs.join('<span class=\\\"math-operator math-binary-operator math-implicit-binary-operator\\\"></span>');\\n        }\\n\\n        return stringifiedArgs.join('<span class=\\\"math-operator math-binary-operator math-explicit-binary-operator\\\">' + (0, _string.escape)(this.op) + '</span>');\\n      } else {\\n        // fallback to formatting as a function call\\n        return '<span class=\\\"math-function\\\">' + (0, _string.escape)(this.fn) + '</span><span class=\\\"math-paranthesis math-round-parenthesis\\\">(</span>' + stringifiedArgs.join('<span class=\\\"math-separator\\\">,</span>') + '<span class=\\\"math-paranthesis math-round-parenthesis\\\">)</span>';\\n      }\\n    }\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  OperatorNode.prototype._toTex = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var implicit = options && options.implicit ? options.implicit : 'hide';\\n    var args = this.args;\\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\\n    var op = _latex.latexOperators[this.fn];\\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\\n\\n    if (args.length === 1) {\\n      // unary operators\\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\\n      var operand = args[0].toTex(options);\\n\\n      if (parens[0]) {\\n        operand = \\\"\\\\\\\\left(\\\".concat(operand, \\\"\\\\\\\\right)\\\");\\n      }\\n\\n      if (assoc === 'right') {\\n        // prefix operator\\n        return op + operand;\\n      } else if (assoc === 'left') {\\n        // postfix operator\\n        return operand + op;\\n      } // fall back to postfix\\n\\n\\n      return operand + op;\\n    } else if (args.length === 2) {\\n      // binary operators\\n      var lhs = args[0]; // left hand side\\n\\n      var lhsTex = lhs.toTex(options);\\n\\n      if (parens[0]) {\\n        lhsTex = \\\"\\\\\\\\left(\\\".concat(lhsTex, \\\"\\\\\\\\right)\\\");\\n      }\\n\\n      var rhs = args[1]; // right hand side\\n\\n      var rhsTex = rhs.toTex(options);\\n\\n      if (parens[1]) {\\n        rhsTex = \\\"\\\\\\\\left(\\\".concat(rhsTex, \\\"\\\\\\\\right)\\\");\\n      } // handle some exceptions (due to the way LaTeX works)\\n\\n\\n      var lhsIdentifier;\\n\\n      if (parenthesis === 'keep') {\\n        lhsIdentifier = lhs.getIdentifier();\\n      } else {\\n        // Ignore ParenthesisNodes if in 'keep' mode\\n        lhsIdentifier = lhs.getContent().getIdentifier();\\n      }\\n\\n      switch (this.getIdentifier()) {\\n        case 'OperatorNode:divide':\\n          // op contains '\\\\\\\\frac' at this point\\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\\n\\n        case 'OperatorNode:pow':\\n          lhsTex = '{' + lhsTex + '}';\\n          rhsTex = '{' + rhsTex + '}';\\n\\n          switch (lhsIdentifier) {\\n            case 'ConditionalNode': //\\n\\n            case 'OperatorNode:divide':\\n              lhsTex = \\\"\\\\\\\\left(\\\".concat(lhsTex, \\\"\\\\\\\\right)\\\");\\n          }\\n\\n          break;\\n\\n        case 'OperatorNode:multiply':\\n          if (this.implicit && implicit === 'hide') {\\n            return lhsTex + '~' + rhsTex;\\n          }\\n\\n      }\\n\\n      return lhsTex + op + rhsTex;\\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\\n      var texifiedArgs = args.map(function (arg, index) {\\n        arg = arg.toTex(options);\\n\\n        if (parens[index]) {\\n          arg = \\\"\\\\\\\\left(\\\".concat(arg, \\\"\\\\\\\\right)\\\");\\n        }\\n\\n        return arg;\\n      });\\n\\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\\n        return texifiedArgs.join('~');\\n      }\\n\\n      return texifiedArgs.join(op);\\n    } else {\\n      // fall back to formatting as a function call\\n      // as this is a fallback, it doesn't use\\n      // fancy function names\\n      return '\\\\\\\\mathrm{' + this.fn + '}\\\\\\\\left(' + args.map(function (arg) {\\n        return arg.toTex(options);\\n      }).join(',') + '\\\\\\\\right)';\\n    }\\n  };\\n  /**\\n   * Get identifier.\\n   * @return {string}\\n   */\\n\\n\\n  OperatorNode.prototype.getIdentifier = function () {\\n    return this.type + ':' + this.fn;\\n  };\\n\\n  return OperatorNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createOperatorNode = createOperatorNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createOperatorNode\",\"_is\",\"_array\",\"_string\",\"_customs\",\"_operators\",\"_latex\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"OperatorNode\",\"op\",\"fn\",\"args\",\"implicit\",\"SyntaxError\",\"TypeError\",\"Array\",\"isArray\",\"every\",\"isNode\",\"calculateNecessaryParentheses\",\"root\",\"parenthesis\",\"latex\",\"precedence\",\"getPrecedence\",\"associativity\",\"getAssociativity\",\"length\",\"getIdentifier\",\"map\",\"arg\",\"getContent\",\"type\",\"result\",\"operandPrecedence\",\"operandIdentifier\",\"rootIdentifier\",\"properties\",\"latexLeftParens\",\"latexParens\",\"lhsPrecedence\",\"assocWithLhs\",\"isAssociativeWith\",\"lhsParens\",\"rhsPrecedence\",\"assocWithRhs\",\"rhsParens\",\"_rootIdentifier\",\"lhsIdentifier\",\"rhsIdentifier\",\"latexRightParens\",\"argPrecedence\",\"assocWithArg\",\"argAssociativity\",\"index\",\"isParenthesisNode\",\"prototype\",\"Node\",\"isOperatorNode\",\"_compile\",\"OperatorNode.prototype._compile\",\"math\",\"argNames\",\"isSafeMethod\",\"Error\",\"getSafeProperty\",\"evalArgs\",\"evalArg0\",\"evalOperatorNode\",\"scope\",\"context\",\"_evalArg\",\"evalArg1\",\"apply\",\"evalArg\",\"forEach\",\"OperatorNode.prototype.forEach\",\"callback\",\"i\",\"OperatorNode.prototype.map\",\"_ifNode\",\"clone\",\"OperatorNode.prototype.clone\",\"slice\",\"isUnary\",\"OperatorNode.prototype.isUnary\",\"isBinary\",\"OperatorNode.prototype.isBinary\",\"_toString\",\"OperatorNode.prototype._toString\",\"options\",\"parens\",\"assoc\",\"operand\",\"toString\",\"opIsNamed\",\"test\",\"lhs\",\"rhs\",\"stringifiedArgs\",\"join\",\"toJSON\",\"OperatorNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"OperatorNode.fromJSON\",\"json\",\"toHTML\",\"OperatorNode.prototype.toHTML\",\"escape\",\"_toTex\",\"OperatorNode.prototype._toTex\",\"latexOperators\",\"toTex\",\"concat\",\"lhsTex\",\"rhsTex\",\"texifiedArgs\",\"OperatorNode.prototype.getIdentifier\",\"isClass\"]\n}\n"]