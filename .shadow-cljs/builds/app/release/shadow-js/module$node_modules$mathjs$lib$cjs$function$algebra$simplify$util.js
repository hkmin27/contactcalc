["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js"],"~:js","shadow$provide[562]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createUtil=void 0;var q=b(14);c=b(25);var f=b(15);b=(0,c.factory)(\"simplifyUtil\",[\"FunctionNode\",\"OperatorNode\",\"SymbolNode\"],function(u){function k(z,w){if(!(0,q.isOperatorNode)(z))return!1;z=z.fn.toString();return w&&(0,f.hasOwnProperty)(w,z)&&(0,f.hasOwnProperty)(w[z],\"associative\")?w[z].associative:C[z]||!1}function t(z){if(!z.args||0===z.args.length)return z;z.args=p(z);for(var w=0;w<z.args.length;w++)t(z.args[w])}\nfunction p(z){var w=[],B=function E(F){for(var G=0;G<F.args.length;G++){var I=F.args[G];(0,q.isOperatorNode)(I)&&x===I.op?E(I):w.push(I)}};if(k(z)){var x=z.op;B(z);return w}return z.args}function g(z){if(z.args&&0!==z.args.length){for(var w=l(z),B=z.args.length,x=0;x<B;x++)g(z.args[x]);if(2<B&&k(z)){for(B=z.args.pop();0<z.args.length;)B=w([z.args.pop(),B]);z.args=B.args}}}function d(z){if(z.args&&0!==z.args.length){for(var w=l(z),B=z.args.length,x=0;x<B;x++)d(z.args[x]);if(2<B&&k(z)){for(B=z.args.shift();0<\nz.args.length;)B=w([B,z.args.shift()]);z.args=B.args}}}function l(z){return(0,q.isOperatorNode)(z)?function(w){try{return new n(z.op,z.fn,w,z.implicit)}catch(B){return console.error(B),[]}}:function(w){return new h(new r(z.name),w)}}var h=u.FunctionNode,n=u.OperatorNode,r=u.SymbolNode,v={add:!0,multiply:!0},C={add:!0,multiply:!0};return{createMakeNodeFunction:l,isCommutative:function(z,w){if(!(0,q.isOperatorNode)(z))return!0;z=z.fn.toString();return w&&(0,f.hasOwnProperty)(w,z)&&(0,f.hasOwnProperty)(w[z],\n\"commutative\")?w[z].commutative:v[z]||!1},isAssociative:k,flatten:t,allChildren:p,unflattenr:g,unflattenl:d}});a.createUtil=b}","~:source","shadow$provide[562] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUtil = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _object = require(\"../../../utils/object.js\");\n\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if ((0, _is.isOperatorNode)(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});\nexports.createUtil = createUtil;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["unflattenl","isCommutative","multiply","args","__esModule","allChildren","value","unflattenr","createUtil","add","flatten","isAssociative","createMakeNodeFunction"]],"~:compiled-at",1619135724033,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js\"],\n\"sourcesContent\":[\"shadow$provide[562] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createUtil = void 0;\\n\\nvar _is = require(\\\"../../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _object = require(\\\"../../../utils/object.js\\\");\\n\\nvar name = 'simplifyUtil';\\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var FunctionNode = _ref.FunctionNode,\\n      OperatorNode = _ref.OperatorNode,\\n      SymbolNode = _ref.SymbolNode;\\n  // TODO commutative/associative properties rely on the arguments\\n  // e.g. multiply is not commutative for matrices\\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\\n  var commutative = {\\n    add: true,\\n    multiply: true\\n  };\\n  var associative = {\\n    add: true,\\n    multiply: true\\n  };\\n\\n  function isCommutative(node, context) {\\n    if (!(0, _is.isOperatorNode)(node)) {\\n      return true;\\n    }\\n\\n    var name = node.fn.toString();\\n\\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'commutative')) {\\n      return context[name].commutative;\\n    }\\n\\n    return commutative[name] || false;\\n  }\\n\\n  function isAssociative(node, context) {\\n    if (!(0, _is.isOperatorNode)(node)) {\\n      return false;\\n    }\\n\\n    var name = node.fn.toString();\\n\\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'associative')) {\\n      return context[name].associative;\\n    }\\n\\n    return associative[name] || false;\\n  }\\n  /**\\n   * Flatten all associative operators in an expression tree.\\n   * Assumes parentheses have already been removed.\\n   */\\n\\n\\n  function flatten(node) {\\n    if (!node.args || node.args.length === 0) {\\n      return node;\\n    }\\n\\n    node.args = allChildren(node);\\n\\n    for (var i = 0; i < node.args.length; i++) {\\n      flatten(node.args[i]);\\n    }\\n  }\\n  /**\\n   * Get the children of a node as if it has been flattened.\\n   * TODO implement for FunctionNodes\\n   */\\n\\n\\n  function allChildren(node) {\\n    var op;\\n    var children = [];\\n\\n    var findChildren = function findChildren(node) {\\n      for (var i = 0; i < node.args.length; i++) {\\n        var child = node.args[i];\\n\\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\\n          findChildren(child);\\n        } else {\\n          children.push(child);\\n        }\\n      }\\n    };\\n\\n    if (isAssociative(node)) {\\n      op = node.op;\\n      findChildren(node);\\n      return children;\\n    } else {\\n      return node.args;\\n    }\\n  }\\n  /**\\n   *  Unflatten all flattened operators to a right-heavy binary tree.\\n   */\\n\\n\\n  function unflattenr(node) {\\n    if (!node.args || node.args.length === 0) {\\n      return;\\n    }\\n\\n    var makeNode = createMakeNodeFunction(node);\\n    var l = node.args.length;\\n\\n    for (var i = 0; i < l; i++) {\\n      unflattenr(node.args[i]);\\n    }\\n\\n    if (l > 2 && isAssociative(node)) {\\n      var curnode = node.args.pop();\\n\\n      while (node.args.length > 0) {\\n        curnode = makeNode([node.args.pop(), curnode]);\\n      }\\n\\n      node.args = curnode.args;\\n    }\\n  }\\n  /**\\n   *  Unflatten all flattened operators to a left-heavy binary tree.\\n   */\\n\\n\\n  function unflattenl(node) {\\n    if (!node.args || node.args.length === 0) {\\n      return;\\n    }\\n\\n    var makeNode = createMakeNodeFunction(node);\\n    var l = node.args.length;\\n\\n    for (var i = 0; i < l; i++) {\\n      unflattenl(node.args[i]);\\n    }\\n\\n    if (l > 2 && isAssociative(node)) {\\n      var curnode = node.args.shift();\\n\\n      while (node.args.length > 0) {\\n        curnode = makeNode([curnode, node.args.shift()]);\\n      }\\n\\n      node.args = curnode.args;\\n    }\\n  }\\n\\n  function createMakeNodeFunction(node) {\\n    if ((0, _is.isOperatorNode)(node)) {\\n      return function (args) {\\n        try {\\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\\n        } catch (err) {\\n          console.error(err);\\n          return [];\\n        }\\n      };\\n    } else {\\n      return function (args) {\\n        return new FunctionNode(new SymbolNode(node.name), args);\\n      };\\n    }\\n  }\\n\\n  return {\\n    createMakeNodeFunction: createMakeNodeFunction,\\n    isCommutative: isCommutative,\\n    isAssociative: isAssociative,\\n    flatten: flatten,\\n    allChildren: allChildren,\\n    unflattenr: unflattenr,\\n    unflattenl: unflattenl\\n  };\\n});\\nexports.createUtil = createUtil;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createUtil\",\"_is\",\"_factory\",\"_object\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"isAssociative\",\"node\",\"context\",\"isOperatorNode\",\"fn\",\"toString\",\"hasOwnProperty\",\"associative\",\"flatten\",\"args\",\"length\",\"allChildren\",\"i\",\"children\",\"findChildren\",\"child\",\"op\",\"push\",\"unflattenr\",\"makeNode\",\"createMakeNodeFunction\",\"l\",\"curnode\",\"pop\",\"unflattenl\",\"shift\",\"OperatorNode\",\"implicit\",\"err\",\"console\",\"error\",\"FunctionNode\",\"SymbolNode\",\"commutative\",\"add\",\"multiply\",\"isCommutative\"]\n}\n"]