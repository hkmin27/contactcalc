["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/pow.js"],"~:js","shadow$provide[165]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createPow=void 0;c=b(25);var q=b(19),f=b(24),u=b(50);b=(0,c.factory)(\"pow\",\"typed config identity multiply matrix fraction number Complex\".split(\" \"),function(k){function t(w,B){if(l.predictable&&!(0,q.isInteger)(B)&&0>w)try{var x=C(B),D=v(x);if((B===D||1E-14>Math.abs((B-D)/B))&&1===x.d%2)return(0===x.n%2?1:-1)*Math.pow(-w,B)}catch(F){}return l.predictable&&(-1>w&&Infinity===B||-1<w&&0>w&&-Infinity===B)?NaN:(0,\nq.isInteger)(B)||0<=w||l.predictable?(0,u.powNumber)(w,B):1>w*w&&Infinity===B||1<w*w&&-Infinity===B?0:(new z(w,0)).pow(B,0)}function p(w,B){if(!(0,q.isInteger)(B)||0>B)throw new TypeError(\"For A^b, b must be a positive integer (value is \"+B+\")\");var x=(0,f.arraySize)(w);if(2!==x.length)throw Error(\"For A^b, A must be 2 dimensional (A has \"+x.length+\" dimensions)\");if(x[0]!==x[1])throw Error(\"For A^b, A must be square (size is \"+x[0]+\"x\"+x[1]+\")\");for(x=h(x[0]).valueOf();1<=B;)1===(B&1)&&(x=n(w,x)),\nB>>=1,w=n(w,w);return x}function g(w,B){return r(p(w.valueOf(),B))}var d=k.typed,l=k.config,h=k.identity,n=k.multiply,r=k.matrix,v=k.number,C=k.fraction,z=k.Complex;return d(\"pow\",{\"number, number\":t,\"Complex, Complex\":function(w,B){return w.pow(B)},\"BigNumber, BigNumber\":function(w,B){return B.isInteger()||0<=w||l.predictable?w.pow(B):(new z(w.toNumber(),0)).pow(B.toNumber(),0)},\"Fraction, Fraction\":function(w,B){if(1!==B.d){if(l.predictable)throw Error(\"Function pow does not support non-integer exponents for fractions.\");\nreturn t(w.valueOf(),B.valueOf())}return w.pow(B)},\"Array, number\":p,\"Array, BigNumber\":function(w,B){return p(w,B.toNumber())},\"Matrix, number\":g,\"Matrix, BigNumber\":function(w,B){return g(w,B.toNumber())},\"Unit, number | BigNumber\":function(w,B){return w.pow(B)}})});a.createPow=b}","~:source","shadow$provide[165] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPow = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _index = require(\"../../plain/number/index.js\");\n\nvar name = 'pow';\nvar dependencies = ['typed', 'config', 'identity', 'multiply', 'matrix', 'fraction', 'number', 'Complex'];\nvar createPow = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      identity = _ref.identity,\n      multiply = _ref.multiply,\n      matrix = _ref.matrix,\n      number = _ref.number,\n      fraction = _ref.fraction,\n      Complex = _ref.Complex;\n\n  /**\n   * Calculates the power of x to y, `x ^ y`.\n   * Matrix exponentiation is supported for square matrices `x`, and positive\n   * integer exponents `y`.\n   *\n   * For cubic roots of negative numbers, the function returns the principal\n   * root by default. In order to let the function return the real root,\n   * math.js can be configured with `math.config({predictable: true})`.\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\n   *\n   * Syntax:\n   *\n   *    math.pow(x, y)\n   *\n   * Examples:\n   *\n   *    math.pow(2, 3)               // returns number 8\n   *\n   *    const a = math.complex(2, 3)\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\n   *\n   *    const b = [[1, 2], [4, 3]]\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\n   *\n   * See also:\n   *\n   *    multiply, sqrt, cbrt, nthRoot\n   *\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\n   * @param  {number | BigNumber | Complex} y                          The exponent\n   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`\n   */\n  return typed(name, {\n    'number, number': _pow,\n    'Complex, Complex': function ComplexComplex(x, y) {\n      return x.pow(y);\n    },\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\n      if (y.isInteger() || x >= 0 || config.predictable) {\n        return x.pow(y);\n      } else {\n        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\n      }\n    },\n    'Fraction, Fraction': function FractionFraction(x, y) {\n      if (y.d !== 1) {\n        if (config.predictable) {\n          throw new Error('Function pow does not support non-integer exponents for fractions.');\n        } else {\n          return _pow(x.valueOf(), y.valueOf());\n        }\n      } else {\n        return x.pow(y);\n      }\n    },\n    'Array, number': _powArray,\n    'Array, BigNumber': function ArrayBigNumber(x, y) {\n      return _powArray(x, y.toNumber());\n    },\n    'Matrix, number': _powMatrix,\n    'Matrix, BigNumber': function MatrixBigNumber(x, y) {\n      return _powMatrix(x, y.toNumber());\n    },\n    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {\n      return x.pow(y);\n    }\n  });\n  /**\n   * Calculates the power of x to y, x^y, for two numbers.\n   * @param {number} x\n   * @param {number} y\n   * @return {number | Complex} res\n   * @private\n   */\n\n  function _pow(x, y) {\n    // Alternatively could define a 'realmode' config option or something, but\n    // 'predictable' will work for now\n    if (config.predictable && !(0, _number.isInteger)(y) && x < 0) {\n      // Check to see if y can be represented as a fraction\n      try {\n        var yFrac = fraction(y);\n        var yNum = number(yFrac);\n\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\n          if (yFrac.d % 2 === 1) {\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\n          }\n        }\n      } catch (ex) {// fraction() throws an error if y is Infinity, etc.\n      } // Unable to express y as a fraction, so continue on\n\n    } // **for predictable mode** x^Infinity === NaN if x < -1\n    // N.B. this behavour is different from `Math.pow` which gives\n    // (-2)^Infinity === Infinity\n\n\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\n      return NaN;\n    }\n\n    if ((0, _number.isInteger)(y) || x >= 0 || config.predictable) {\n      return (0, _index.powNumber)(x, y);\n    } else {\n      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow\n      // x^Infinity === 0 if -1 < x < 1\n      // A real number 0 is returned instead of complex(0)\n      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\n        return 0;\n      }\n\n      return new Complex(x, 0).pow(y, 0);\n    }\n  }\n  /**\n   * Calculate the power of a 2d array\n   * @param {Array} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a positive, integer value\n   * @returns {Array}\n   * @private\n   */\n\n\n  function _powArray(x, y) {\n    if (!(0, _number.isInteger)(y) || y < 0) {\n      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');\n    } // verify that A is a 2 dimensional square matrix\n\n\n    var s = (0, _array.arraySize)(x);\n\n    if (s.length !== 2) {\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\n    }\n\n    if (s[0] !== s[1]) {\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\n    }\n\n    var res = identity(s[0]).valueOf();\n    var px = x;\n\n    while (y >= 1) {\n      if ((y & 1) === 1) {\n        res = multiply(px, res);\n      }\n\n      y >>= 1;\n      px = multiply(px, px);\n    }\n\n    return res;\n  }\n  /**\n   * Calculate the power of a 2d matrix\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a positive, integer value\n   * @returns {Matrix}\n   * @private\n   */\n\n\n  function _powMatrix(x, y) {\n    return matrix(_powArray(x.valueOf(), y));\n  }\n});\nexports.createPow = createPow;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$plain$number$index","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","createPow"]],"~:compiled-at",1619135723898,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$pow.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/pow.js\"],\n\"sourcesContent\":[\"shadow$provide[165] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createPow = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _index = require(\\\"../../plain/number/index.js\\\");\\n\\nvar name = 'pow';\\nvar dependencies = ['typed', 'config', 'identity', 'multiply', 'matrix', 'fraction', 'number', 'Complex'];\\nvar createPow = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      config = _ref.config,\\n      identity = _ref.identity,\\n      multiply = _ref.multiply,\\n      matrix = _ref.matrix,\\n      number = _ref.number,\\n      fraction = _ref.fraction,\\n      Complex = _ref.Complex;\\n\\n  /**\\n   * Calculates the power of x to y, `x ^ y`.\\n   * Matrix exponentiation is supported for square matrices `x`, and positive\\n   * integer exponents `y`.\\n   *\\n   * For cubic roots of negative numbers, the function returns the principal\\n   * root by default. In order to let the function return the real root,\\n   * math.js can be configured with `math.config({predictable: true})`.\\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\\n   *\\n   * Syntax:\\n   *\\n   *    math.pow(x, y)\\n   *\\n   * Examples:\\n   *\\n   *    math.pow(2, 3)               // returns number 8\\n   *\\n   *    const a = math.complex(2, 3)\\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\\n   *\\n   *    const b = [[1, 2], [4, 3]]\\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\\n   *\\n   * See also:\\n   *\\n   *    multiply, sqrt, cbrt, nthRoot\\n   *\\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\\n   * @param  {number | BigNumber | Complex} y                          The exponent\\n   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`\\n   */\\n  return typed(name, {\\n    'number, number': _pow,\\n    'Complex, Complex': function ComplexComplex(x, y) {\\n      return x.pow(y);\\n    },\\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\\n      if (y.isInteger() || x >= 0 || config.predictable) {\\n        return x.pow(y);\\n      } else {\\n        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\\n      }\\n    },\\n    'Fraction, Fraction': function FractionFraction(x, y) {\\n      if (y.d !== 1) {\\n        if (config.predictable) {\\n          throw new Error('Function pow does not support non-integer exponents for fractions.');\\n        } else {\\n          return _pow(x.valueOf(), y.valueOf());\\n        }\\n      } else {\\n        return x.pow(y);\\n      }\\n    },\\n    'Array, number': _powArray,\\n    'Array, BigNumber': function ArrayBigNumber(x, y) {\\n      return _powArray(x, y.toNumber());\\n    },\\n    'Matrix, number': _powMatrix,\\n    'Matrix, BigNumber': function MatrixBigNumber(x, y) {\\n      return _powMatrix(x, y.toNumber());\\n    },\\n    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {\\n      return x.pow(y);\\n    }\\n  });\\n  /**\\n   * Calculates the power of x to y, x^y, for two numbers.\\n   * @param {number} x\\n   * @param {number} y\\n   * @return {number | Complex} res\\n   * @private\\n   */\\n\\n  function _pow(x, y) {\\n    // Alternatively could define a 'realmode' config option or something, but\\n    // 'predictable' will work for now\\n    if (config.predictable && !(0, _number.isInteger)(y) && x < 0) {\\n      // Check to see if y can be represented as a fraction\\n      try {\\n        var yFrac = fraction(y);\\n        var yNum = number(yFrac);\\n\\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\\n          if (yFrac.d % 2 === 1) {\\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\\n          }\\n        }\\n      } catch (ex) {// fraction() throws an error if y is Infinity, etc.\\n      } // Unable to express y as a fraction, so continue on\\n\\n    } // **for predictable mode** x^Infinity === NaN if x < -1\\n    // N.B. this behavour is different from `Math.pow` which gives\\n    // (-2)^Infinity === Infinity\\n\\n\\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\\n      return NaN;\\n    }\\n\\n    if ((0, _number.isInteger)(y) || x >= 0 || config.predictable) {\\n      return (0, _index.powNumber)(x, y);\\n    } else {\\n      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow\\n      // x^Infinity === 0 if -1 < x < 1\\n      // A real number 0 is returned instead of complex(0)\\n      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\\n        return 0;\\n      }\\n\\n      return new Complex(x, 0).pow(y, 0);\\n    }\\n  }\\n  /**\\n   * Calculate the power of a 2d array\\n   * @param {Array} x     must be a 2 dimensional, square matrix\\n   * @param {number} y    a positive, integer value\\n   * @returns {Array}\\n   * @private\\n   */\\n\\n\\n  function _powArray(x, y) {\\n    if (!(0, _number.isInteger)(y) || y < 0) {\\n      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');\\n    } // verify that A is a 2 dimensional square matrix\\n\\n\\n    var s = (0, _array.arraySize)(x);\\n\\n    if (s.length !== 2) {\\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\\n    }\\n\\n    if (s[0] !== s[1]) {\\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\\n    }\\n\\n    var res = identity(s[0]).valueOf();\\n    var px = x;\\n\\n    while (y >= 1) {\\n      if ((y & 1) === 1) {\\n        res = multiply(px, res);\\n      }\\n\\n      y >>= 1;\\n      px = multiply(px, px);\\n    }\\n\\n    return res;\\n  }\\n  /**\\n   * Calculate the power of a 2d matrix\\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\\n   * @param {number} y    a positive, integer value\\n   * @returns {Matrix}\\n   * @private\\n   */\\n\\n\\n  function _powMatrix(x, y) {\\n    return matrix(_powArray(x.valueOf(), y));\\n  }\\n});\\nexports.createPow = createPow;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createPow\",\"_factory\",\"_number\",\"_array\",\"_index\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_pow\",\"x\",\"y\",\"config\",\"predictable\",\"isInteger\",\"yFrac\",\"fraction\",\"yNum\",\"number\",\"Math\",\"abs\",\"d\",\"n\",\"pow\",\"ex\",\"Infinity\",\"NaN\",\"powNumber\",\"Complex\",\"_powArray\",\"TypeError\",\"s\",\"arraySize\",\"length\",\"Error\",\"res\",\"identity\",\"valueOf\",\"multiply\",\"px\",\"_powMatrix\",\"matrix\",\"typed\",\"ComplexComplex\",\"BigNumberBigNumber\",\"toNumber\",\"FractionFraction\",\"ArrayBigNumber\",\"MatrixBigNumber\",\"UnitNumberBigNumber\"]\n}\n"]