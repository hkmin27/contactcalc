["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyCore.js"],"~:js","shadow$provide[563]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createSimplifyCore=void 0;var q=b(14);c=b(25);c=(0,c.factory)(\"simplifyCore\",\"equal isZero add subtract multiply divide pow ConstantNode OperatorNode FunctionNode ParenthesisNode\".split(\" \"),function(f){function u(B){if((0,q.isOperatorNode)(B)&&B.isUnary()){var x=u(B.args[0]);if(\"+\"===B.op)return x;if(\"-\"===B.op){if((0,q.isOperatorNode)(x)){if(x.isUnary()&&\"-\"===x.op)return x.args[0];if(x.isBinary()&&\"subtract\"===\nx.fn)return new r(\"-\",\"subtract\",[x.args[1],x.args[0]])}return new r(B.op,B.fn,[x])}}else if((0,q.isOperatorNode)(B)&&B.isBinary()){x=u(B.args[0]);var D=u(B.args[1]);if(\"+\"===B.op){if((0,q.isConstantNode)(x)){if(t(x.value))return D;if((0,q.isConstantNode)(D))return new n(p(x.value,D.value))}return(0,q.isConstantNode)(D)&&t(D.value)?x:(0,q.isOperatorNode)(D)&&D.isUnary()&&\"-\"===D.op?new r(\"-\",\"subtract\",[x,D.args[0]]):new r(B.op,B.fn,D?[x,D]:[x])}if(\"-\"===B.op){if((0,q.isConstantNode)(x)&&D){if((0,\nq.isConstantNode)(D))return new n(g(x.value,D.value));if(t(x.value))return new r(\"-\",\"unaryMinus\",[D])}if(\"subtract\"===B.fn)return(0,q.isConstantNode)(D)&&t(D.value)?x:(0,q.isOperatorNode)(D)&&D.isUnary()&&\"-\"===D.op?u(new r(\"+\",\"add\",[x,D.args[0]])):new r(B.op,B.fn,[x,D])}else{if(\"*\"===B.op){if((0,q.isConstantNode)(x)){if(t(x.value))return z;if(k(x.value,1))return D;if((0,q.isConstantNode)(D))return new n(d(x.value,D.value))}if((0,q.isConstantNode)(D)){if(t(D.value))return z;if(k(D.value,1))return x;\nif((0,q.isOperatorNode)(x)&&x.isBinary()&&x.op===B.op){var F=x.args[0];if((0,q.isConstantNode)(F))return D=new n(d(F.value,D.value)),new r(B.op,B.fn,[D,x.args[1]],B.implicit)}return new r(B.op,B.fn,[D,x],B.implicit)}return new r(B.op,B.fn,[x,D],B.implicit)}if(\"/\"===B.op){if((0,q.isConstantNode)(x)){if(t(x.value))return z;if((0,q.isConstantNode)(D)&&(k(D.value,1)||k(D.value,2)||k(D.value,4)))return new n(l(x.value,D.value))}return new r(B.op,B.fn,[x,D])}if(\"^\"===B.op){if((0,q.isConstantNode)(D)){if(t(D.value))return w;\nif(k(D.value,1))return x;if((0,q.isConstantNode)(x))return new n(h(x.value,D.value));if((0,q.isOperatorNode)(x)&&x.isBinary()&&\"^\"===x.op&&(F=x.args[1],(0,q.isConstantNode)(F)))return new r(B.op,B.fn,[x.args[0],new n(d(F.value,D.value))])}return new r(B.op,B.fn,[x,D])}}}else{if((0,q.isParenthesisNode)(B))return B=u(B.content),(0,q.isParenthesisNode)(B)||(0,q.isSymbolNode)(B)||(0,q.isConstantNode)(B)?B:new C(B);if((0,q.isFunctionNode)(B))return x=B.args.map(u).map(function(E){return(0,q.isParenthesisNode)(E)?\nE.content:E}),new v(u(B.fn),x)}return B}var k=f.equal,t=f.isZero,p=f.add,g=f.subtract,d=f.multiply,l=f.divide,h=f.pow,n=f.ConstantNode,r=f.OperatorNode,v=f.FunctionNode,C=f.ParenthesisNode,z=new n(0),w=new n(1);return u});a.createSimplifyCore=c}","~:source","shadow$provide[563] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyCore = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nvar createSimplifyCore = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if ((0, _is.isOperatorNode)(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if ((0, _is.isOperatorNode)(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if ((0, _is.isConstantNode)(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if ((0, _is.isConstantNode)(_a) && a1) {\n          if ((0, _is.isConstantNode)(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if ((0, _is.isConstantNode)(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if ((0, _is.isOperatorNode)(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if ((0, _is.isConstantNode)(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if ((0, _is.isConstantNode)(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if ((0, _is.isConstantNode)(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if ((0, _is.isOperatorNode)(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if ((0, _is.isConstantNode)(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      var c = simplifyCore(node.content);\n\n      if ((0, _is.isParenthesisNode)(c) || (0, _is.isSymbolNode)(c) || (0, _is.isConstantNode)(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return (0, _is.isParenthesisNode)(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});\nexports.createSimplifyCore = createSimplifyCore;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","createSimplifyCore"]],"~:compiled-at",1619135724033,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyCore.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyCore.js\"],\n\"sourcesContent\":[\"shadow$provide[563] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSimplifyCore = void 0;\\n\\nvar _is = require(\\\"../../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar name = 'simplifyCore';\\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\\nvar createSimplifyCore = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var equal = _ref.equal,\\n      isZero = _ref.isZero,\\n      add = _ref.add,\\n      subtract = _ref.subtract,\\n      multiply = _ref.multiply,\\n      divide = _ref.divide,\\n      pow = _ref.pow,\\n      ConstantNode = _ref.ConstantNode,\\n      OperatorNode = _ref.OperatorNode,\\n      FunctionNode = _ref.FunctionNode,\\n      ParenthesisNode = _ref.ParenthesisNode;\\n  var node0 = new ConstantNode(0);\\n  var node1 = new ConstantNode(1);\\n  /**\\n   * simplifyCore() performs single pass simplification suitable for\\n   * applications requiring ultimate performance. In contrast, simplify()\\n   * extends simplifyCore() with additional passes to provide deeper\\n   * simplification.\\n   *\\n   * Syntax:\\n   *\\n   *     simplify.simplifyCore(expr)\\n   *\\n   * Examples:\\n   *\\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\\n   *\\n   * See also:\\n   *\\n   *     derivative\\n   *\\n   * @param {Node} node\\n   *     The expression to be simplified\\n   */\\n\\n  function simplifyCore(node) {\\n    if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\\n      var a0 = simplifyCore(node.args[0]);\\n\\n      if (node.op === '+') {\\n        // unary plus\\n        return a0;\\n      }\\n\\n      if (node.op === '-') {\\n        // unary minus\\n        if ((0, _is.isOperatorNode)(a0)) {\\n          if (a0.isUnary() && a0.op === '-') {\\n            return a0.args[0];\\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\\n          }\\n        }\\n\\n        return new OperatorNode(node.op, node.fn, [a0]);\\n      }\\n    } else if ((0, _is.isOperatorNode)(node) && node.isBinary()) {\\n      var _a = simplifyCore(node.args[0]);\\n\\n      var a1 = simplifyCore(node.args[1]);\\n\\n      if (node.op === '+') {\\n        if ((0, _is.isConstantNode)(_a)) {\\n          if (isZero(_a.value)) {\\n            return a1;\\n          } else if ((0, _is.isConstantNode)(a1)) {\\n            return new ConstantNode(add(_a.value, a1.value));\\n          }\\n        }\\n\\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\\n          return _a;\\n        }\\n\\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\\n        }\\n\\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\\n      } else if (node.op === '-') {\\n        if ((0, _is.isConstantNode)(_a) && a1) {\\n          if ((0, _is.isConstantNode)(a1)) {\\n            return new ConstantNode(subtract(_a.value, a1.value));\\n          } else if (isZero(_a.value)) {\\n            return new OperatorNode('-', 'unaryMinus', [a1]);\\n          }\\n        } // if (node.fn === \\\"subtract\\\" && node.args.length === 2) {\\n\\n\\n        if (node.fn === 'subtract') {\\n          if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\\n            return _a;\\n          }\\n\\n          if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\\n          }\\n\\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\\n        }\\n      } else if (node.op === '*') {\\n        if ((0, _is.isConstantNode)(_a)) {\\n          if (isZero(_a.value)) {\\n            return node0;\\n          } else if (equal(_a.value, 1)) {\\n            return a1;\\n          } else if ((0, _is.isConstantNode)(a1)) {\\n            return new ConstantNode(multiply(_a.value, a1.value));\\n          }\\n        }\\n\\n        if ((0, _is.isConstantNode)(a1)) {\\n          if (isZero(a1.value)) {\\n            return node0;\\n          } else if (equal(a1.value, 1)) {\\n            return _a;\\n          } else if ((0, _is.isOperatorNode)(_a) && _a.isBinary() && _a.op === node.op) {\\n            var a00 = _a.args[0];\\n\\n            if ((0, _is.isConstantNode)(a00)) {\\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\\n            }\\n          }\\n\\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\\n        }\\n\\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\\n      } else if (node.op === '/') {\\n        if ((0, _is.isConstantNode)(_a)) {\\n          if (isZero(_a.value)) {\\n            return node0;\\n          } else if ((0, _is.isConstantNode)(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\\n            return new ConstantNode(divide(_a.value, a1.value));\\n          }\\n        }\\n\\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\\n      } else if (node.op === '^') {\\n        if ((0, _is.isConstantNode)(a1)) {\\n          if (isZero(a1.value)) {\\n            return node1;\\n          } else if (equal(a1.value, 1)) {\\n            return _a;\\n          } else {\\n            if ((0, _is.isConstantNode)(_a)) {\\n              // fold constant\\n              return new ConstantNode(pow(_a.value, a1.value));\\n            } else if ((0, _is.isOperatorNode)(_a) && _a.isBinary() && _a.op === '^') {\\n              var a01 = _a.args[1];\\n\\n              if ((0, _is.isConstantNode)(a01)) {\\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\\n              }\\n            }\\n          }\\n        }\\n\\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\\n      }\\n    } else if ((0, _is.isParenthesisNode)(node)) {\\n      var c = simplifyCore(node.content);\\n\\n      if ((0, _is.isParenthesisNode)(c) || (0, _is.isSymbolNode)(c) || (0, _is.isConstantNode)(c)) {\\n        return c;\\n      }\\n\\n      return new ParenthesisNode(c);\\n    } else if ((0, _is.isFunctionNode)(node)) {\\n      var args = node.args.map(simplifyCore).map(function (arg) {\\n        return (0, _is.isParenthesisNode)(arg) ? arg.content : arg;\\n      });\\n      return new FunctionNode(simplifyCore(node.fn), args);\\n    } else {// cannot simplify\\n    }\\n\\n    return node;\\n  }\\n\\n  return simplifyCore;\\n});\\nexports.createSimplifyCore = createSimplifyCore;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSimplifyCore\",\"_is\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"simplifyCore\",\"node\",\"isOperatorNode\",\"isUnary\",\"a0\",\"args\",\"op\",\"isBinary\",\"fn\",\"OperatorNode\",\"_a\",\"a1\",\"isConstantNode\",\"isZero\",\"ConstantNode\",\"add\",\"subtract\",\"node0\",\"equal\",\"multiply\",\"a00\",\"a00a1\",\"implicit\",\"divide\",\"node1\",\"pow\",\"a01\",\"isParenthesisNode\",\"c\",\"content\",\"isSymbolNode\",\"ParenthesisNode\",\"isFunctionNode\",\"map\",\"arg\",\"FunctionNode\"]\n}\n"]