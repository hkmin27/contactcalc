["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/factory.js"],"~:js","shadow$provide[25]=function(c,b,y,a){function q(d){function l(v,C){return f(v)&&((0,p.contains)(v.dependencies,C.fn||C.name)||v.dependencies.some(function(z){return l(n[z],C)}))?!0:!1}function h(v){for(var C=0;C<r.length&&!l(r[C],v);)C++;r.splice(C,0,v)}var n={};d.forEach(function(v){n[v.fn]=v});var r=[];d.filter(f).forEach(h);d.filter(function(v){return!f(v)}).forEach(h);return r}function f(d){return\"function\"===typeof d&&\"string\"===typeof d.fn&&Array.isArray(d.dependencies)}function u(d,l,h){if(!l.filter(function(n){return!k(n)}).every(function(n){return void 0!==\nh[n]}))throw l=l.filter(function(n){return void 0===h[n]}),Error('Cannot create function \"'.concat(d,'\", ')+\"some dependencies are missing: \".concat(l.map(function(n){return'\"'.concat(n,'\"')}).join(\", \"),\".\"));}function k(d){return d&&\"?\"===d[0]}function t(d){return d&&\"?\"===d[0]?d.slice(1):d}Object.defineProperty(a,\"__esModule\",{value:!0});a.factory=function(d,l,h,n){function r(v){var C=(0,g.pickShallow)(v,l.map(t));u(d,l,v);return h(C)}r.isFactory=!0;r.fn=d;r.dependencies=l.slice().sort();n&&(r.meta=\nn);return r};a.sortFactories=q;a.create=function(d){var l=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};q(d).forEach(function(h){return h(l)});return l};a.isFactory=f;a.assertDependencies=u;a.isOptionalDependency=k;a.stripOptionalNotation=t;var p=b(24),g=b(15)}","~:source","shadow$provide[25] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factory = factory;\nexports.sortFactories = sortFactories;\nexports.create = create;\nexports.isFactory = isFactory;\nexports.assertDependencies = assertDependencies;\nexports.isOptionalDependency = isOptionalDependency;\nexports.stripOptionalNotation = stripOptionalNotation;\n\nvar _array = require(\"./array.js\");\n\nvar _object = require(\"./object.js\");\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nfunction factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = (0, _object.pickShallow)(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\n\nfunction sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if ((0, _array.contains)(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\n\nfunction create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\n\nfunction isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\n\nfunction assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\n\nfunction isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\n\nfunction stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object"]],"~:properties",["^5",["assertDependencies","factory","isFactory","dependencies","__esModule","fn","value","isOptionalDependency","meta","create","sortFactories","stripOptionalNotation"]],"~:compiled-at",1619135723716,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$factory.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/factory.js\"],\n\"sourcesContent\":[\"shadow$provide[25] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.factory = factory;\\nexports.sortFactories = sortFactories;\\nexports.create = create;\\nexports.isFactory = isFactory;\\nexports.assertDependencies = assertDependencies;\\nexports.isOptionalDependency = isOptionalDependency;\\nexports.stripOptionalNotation = stripOptionalNotation;\\n\\nvar _array = require(\\\"./array.js\\\");\\n\\nvar _object = require(\\\"./object.js\\\");\\n\\n/**\\n * Create a factory function, which can be used to inject dependencies.\\n *\\n * The created functions are memoized, a consecutive call of the factory\\n * with the exact same inputs will return the same function instance.\\n * The memoized cache is exposed on `factory.cache` and can be cleared\\n * if needed.\\n *\\n * Example:\\n *\\n *     const name = 'log'\\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\\n *\\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\\n *       // ... create the function log here and return it\\n *     }\\n *\\n * @param {string} name           Name of the function to be created\\n * @param {string[]} dependencies The names of all required dependencies\\n * @param {function} create       Callback function called with an object with all dependencies\\n * @param {Object} [meta]         Optional object with meta information that will be attached\\n *                                to the created factory function as property `meta`.\\n * @returns {function}\\n */\\nfunction factory(name, dependencies, create, meta) {\\n  function assertAndCreate(scope) {\\n    // we only pass the requested dependencies to the factory function\\n    // to prevent functions to rely on dependencies that are not explicitly\\n    // requested.\\n    var deps = (0, _object.pickShallow)(scope, dependencies.map(stripOptionalNotation));\\n    assertDependencies(name, dependencies, scope);\\n    return create(deps);\\n  }\\n\\n  assertAndCreate.isFactory = true;\\n  assertAndCreate.fn = name;\\n  assertAndCreate.dependencies = dependencies.slice().sort();\\n\\n  if (meta) {\\n    assertAndCreate.meta = meta;\\n  }\\n\\n  return assertAndCreate;\\n}\\n/**\\n * Sort all factories such that when loading in order, the dependencies are resolved.\\n *\\n * @param {Array} factories\\n * @returns {Array} Returns a new array with the sorted factories.\\n */\\n\\n\\nfunction sortFactories(factories) {\\n  var factoriesByName = {};\\n  factories.forEach(function (factory) {\\n    factoriesByName[factory.fn] = factory;\\n  });\\n\\n  function containsDependency(factory, dependency) {\\n    // TODO: detect circular references\\n    if (isFactory(factory)) {\\n      if ((0, _array.contains)(factory.dependencies, dependency.fn || dependency.name)) {\\n        return true;\\n      }\\n\\n      if (factory.dependencies.some(function (d) {\\n        return containsDependency(factoriesByName[d], dependency);\\n      })) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  var sorted = [];\\n\\n  function addFactory(factory) {\\n    var index = 0;\\n\\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\\n      index++;\\n    }\\n\\n    sorted.splice(index, 0, factory);\\n  } // sort regular factory functions\\n\\n\\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\\n\\n  factories.filter(function (factory) {\\n    return !isFactory(factory);\\n  }).forEach(addFactory);\\n  return sorted;\\n} // TODO: comment or cleanup if unused in the end\\n\\n\\nfunction create(factories) {\\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n  sortFactories(factories).forEach(function (factory) {\\n    return factory(scope);\\n  });\\n  return scope;\\n}\\n/**\\n * Test whether an object is a factory. This is the case when it has\\n * properties name, dependencies, and a function create.\\n * @param {*} obj\\n * @returns {boolean}\\n */\\n\\n\\nfunction isFactory(obj) {\\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\\n}\\n/**\\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\\n *\\n * Will throw an exception when there are dependencies missing.\\n *\\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\\n * @param {string[]} dependencies\\n * @param {Object} scope\\n */\\n\\n\\nfunction assertDependencies(name, dependencies, scope) {\\n  var allDefined = dependencies.filter(function (dependency) {\\n    return !isOptionalDependency(dependency);\\n  }) // filter optionals\\n  .every(function (dependency) {\\n    return scope[dependency] !== undefined;\\n  });\\n\\n  if (!allDefined) {\\n    var missingDependencies = dependencies.filter(function (dependency) {\\n      return scope[dependency] === undefined;\\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\\n\\n    throw new Error(\\\"Cannot create function \\\\\\\"\\\".concat(name, \\\"\\\\\\\", \\\") + \\\"some dependencies are missing: \\\".concat(missingDependencies.map(function (d) {\\n      return \\\"\\\\\\\"\\\".concat(d, \\\"\\\\\\\"\\\");\\n    }).join(', '), \\\".\\\"));\\n  }\\n}\\n\\nfunction isOptionalDependency(dependency) {\\n  return dependency && dependency[0] === '?';\\n}\\n\\nfunction stripOptionalNotation(dependency) {\\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"sortFactories\",\"factories\",\"containsDependency\",\"factory\",\"dependency\",\"isFactory\",\"_array\",\"contains\",\"dependencies\",\"fn\",\"name\",\"some\",\"d\",\"factoriesByName\",\"addFactory\",\"index\",\"sorted\",\"length\",\"splice\",\"forEach\",\"filter\",\"obj\",\"Array\",\"isArray\",\"assertDependencies\",\"scope\",\"isOptionalDependency\",\"every\",\"allDefined\",\"undefined\",\"missingDependencies\",\"Error\",\"concat\",\"map\",\"join\",\"stripOptionalNotation\",\"slice\",\"Object\",\"defineProperty\",\"value\",\"create\",\"meta\",\"assertAndCreate\",\"deps\",\"_object\",\"pickShallow\",\"sort\",\"arguments\"]\n}\n"]