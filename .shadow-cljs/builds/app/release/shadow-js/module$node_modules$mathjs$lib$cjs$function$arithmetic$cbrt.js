["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/cbrt.js"],"~:js","shadow$provide[75]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createCbrt=void 0;c=b(25);var q=b(14),f=b(38),u=b(50);b=(0,c.factory)(\"cbrt\",\"config typed isNegative unaryMinus matrix Complex BigNumber Fraction\".split(\" \"),function(k){function t(C,z){var w=C.arg()/3;C=C.abs();var B=(new n((0,u.cbrtNumber)(C),0)).mul((new n(0,w)).exp());return z?(z=[B,(new n((0,u.cbrtNumber)(C),0)).mul((new n(0,w+2*Math.PI/3)).exp()),(new n((0,u.cbrtNumber)(C),0)).mul((new n(0,w-2*Math.PI/3)).exp())],\n\"Array\"===p.matrix?z:h(z)):B}var p=k.config,g=k.typed,d=k.isNegative,l=k.unaryMinus,h=k.matrix,n=k.Complex,r=k.BigNumber,v=k.Fraction;return g(\"cbrt\",{number:u.cbrtNumber,Complex:t,\"Complex, boolean\":t,BigNumber:function(C){return C.cbrt()},Unit:function(C){if(C.value&&(0,q.isComplex)(C.value)){var z=C.clone();z.value=1;z=z.pow(1/3);z.value=t(C.value);return z}if(z=d(C.value))C.value=l(C.value);var w=(0,q.isBigNumber)(C.value)?(new r(1)).div(3):(0,q.isFraction)(C.value)?new v(1,3):1/3;C=C.pow(w);\nz&&(C.value=l(C.value));return C},\"Array | Matrix\":function(C){return(0,f.deepMap)(C,this,!0)}})});a.createCbrt=b}","~:source","shadow$provide[75] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCbrt = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _collection = require(\"../../utils/collection.js\");\n\nvar _index = require(\"../../plain/number/index.js\");\n\nvar name = 'cbrt';\nvar dependencies = ['config', 'typed', 'isNegative', 'unaryMinus', 'matrix', 'Complex', 'BigNumber', 'Fraction'];\nvar createCbrt = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      isNegative = _ref.isNegative,\n      unaryMinus = _ref.unaryMinus,\n      matrix = _ref.matrix,\n      Complex = _ref.Complex,\n      BigNumber = _ref.BigNumber,\n      Fraction = _ref.Fraction;\n\n  /**\n   * Calculate the cubic root of a value.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.cbrt(x)\n   *    math.cbrt(x, allRoots)\n   *\n   * Examples:\n   *\n   *    math.cbrt(27)                  // returns 3\n   *    math.cube(3)                   // returns 27\n   *    math.cbrt(-64)                 // returns -4\n   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m\n   *    math.cbrt([27, 64, 125])       // returns [3, 4, 5]\n   *\n   *    const x = math.complex('8i')\n   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i\n   *    math.cbrt(x, true)             // returns Matrix [\n   *                                    //    1.7320508075689 + i\n   *                                    //   -1.7320508075689 + i\n   *                                    //   -2i\n   *                                    // ]\n   *\n   * See also:\n   *\n   *    square, sqrt, cube\n   *\n   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x\n   *            Value for which to calculate the cubic root.\n   * @param {boolean} [allRoots]  Optional, false by default. Only applicable\n   *            when `x` is a number or complex number. If true, all complex\n   *            roots are returned, if false (default) the principal root is\n   *            returned.\n   * @return {number | BigNumber | Complex | Unit | Array | Matrix}\n   *            Returns the cubic root of `x`\n   */\n  return typed(name, {\n    number: _index.cbrtNumber,\n    // note: signature 'number, boolean' is also supported,\n    //       created by typed as it knows how to convert number to Complex\n    Complex: _cbrtComplex,\n    'Complex, boolean': _cbrtComplex,\n    BigNumber: function BigNumber(x) {\n      return x.cbrt();\n    },\n    Unit: _cbrtUnit,\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since cbrt(0) = 0\n      return (0, _collection.deepMap)(x, this, true);\n    }\n  });\n  /**\n   * Calculate the cubic root for a complex number\n   * @param {Complex} x\n   * @param {boolean} [allRoots]   If true, the function will return an array\n   *                               with all three roots. If false or undefined,\n   *                               the principal root is returned.\n   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x\n   * @private\n   */\n\n  function _cbrtComplex(x, allRoots) {\n    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers\n    var arg3 = x.arg() / 3;\n    var abs = x.abs(); // principal root:\n\n    var principal = new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3).exp());\n\n    if (allRoots) {\n      var all = [principal, new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()), new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())];\n      return config.matrix === 'Array' ? all : matrix(all);\n    } else {\n      return principal;\n    }\n  }\n  /**\n   * Calculate the cubic root for a Unit\n   * @param {Unit} x\n   * @return {Unit} Returns the cubic root of x\n   * @private\n   */\n\n\n  function _cbrtUnit(x) {\n    if (x.value && (0, _is.isComplex)(x.value)) {\n      var result = x.clone();\n      result.value = 1.0;\n      result = result.pow(1.0 / 3); // Compute the units\n\n      result.value = _cbrtComplex(x.value); // Compute the value\n\n      return result;\n    } else {\n      var negate = isNegative(x.value);\n\n      if (negate) {\n        x.value = unaryMinus(x.value);\n      } // TODO: create a helper function for this\n\n\n      var third;\n\n      if ((0, _is.isBigNumber)(x.value)) {\n        third = new BigNumber(1).div(3);\n      } else if ((0, _is.isFraction)(x.value)) {\n        third = new Fraction(1, 3);\n      } else {\n        third = 1 / 3;\n      }\n\n      var _result = x.pow(third);\n\n      if (negate) {\n        _result.value = unaryMinus(_result.value);\n      }\n\n      return _result;\n    }\n  }\n});\nexports.createCbrt = createCbrt;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$plain$number$index","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$collection","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["Unit","Complex","__esModule","value","number","BigNumber","createCbrt"]],"~:compiled-at",1619135723768,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$cbrt.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/cbrt.js\"],\n\"sourcesContent\":[\"shadow$provide[75] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCbrt = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _collection = require(\\\"../../utils/collection.js\\\");\\n\\nvar _index = require(\\\"../../plain/number/index.js\\\");\\n\\nvar name = 'cbrt';\\nvar dependencies = ['config', 'typed', 'isNegative', 'unaryMinus', 'matrix', 'Complex', 'BigNumber', 'Fraction'];\\nvar createCbrt = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var config = _ref.config,\\n      typed = _ref.typed,\\n      isNegative = _ref.isNegative,\\n      unaryMinus = _ref.unaryMinus,\\n      matrix = _ref.matrix,\\n      Complex = _ref.Complex,\\n      BigNumber = _ref.BigNumber,\\n      Fraction = _ref.Fraction;\\n\\n  /**\\n   * Calculate the cubic root of a value.\\n   *\\n   * For matrices, the function is evaluated element wise.\\n   *\\n   * Syntax:\\n   *\\n   *    math.cbrt(x)\\n   *    math.cbrt(x, allRoots)\\n   *\\n   * Examples:\\n   *\\n   *    math.cbrt(27)                  // returns 3\\n   *    math.cube(3)                   // returns 27\\n   *    math.cbrt(-64)                 // returns -4\\n   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m\\n   *    math.cbrt([27, 64, 125])       // returns [3, 4, 5]\\n   *\\n   *    const x = math.complex('8i')\\n   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i\\n   *    math.cbrt(x, true)             // returns Matrix [\\n   *                                    //    1.7320508075689 + i\\n   *                                    //   -1.7320508075689 + i\\n   *                                    //   -2i\\n   *                                    // ]\\n   *\\n   * See also:\\n   *\\n   *    square, sqrt, cube\\n   *\\n   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x\\n   *            Value for which to calculate the cubic root.\\n   * @param {boolean} [allRoots]  Optional, false by default. Only applicable\\n   *            when `x` is a number or complex number. If true, all complex\\n   *            roots are returned, if false (default) the principal root is\\n   *            returned.\\n   * @return {number | BigNumber | Complex | Unit | Array | Matrix}\\n   *            Returns the cubic root of `x`\\n   */\\n  return typed(name, {\\n    number: _index.cbrtNumber,\\n    // note: signature 'number, boolean' is also supported,\\n    //       created by typed as it knows how to convert number to Complex\\n    Complex: _cbrtComplex,\\n    'Complex, boolean': _cbrtComplex,\\n    BigNumber: function BigNumber(x) {\\n      return x.cbrt();\\n    },\\n    Unit: _cbrtUnit,\\n    'Array | Matrix': function ArrayMatrix(x) {\\n      // deep map collection, skip zeros since cbrt(0) = 0\\n      return (0, _collection.deepMap)(x, this, true);\\n    }\\n  });\\n  /**\\n   * Calculate the cubic root for a complex number\\n   * @param {Complex} x\\n   * @param {boolean} [allRoots]   If true, the function will return an array\\n   *                               with all three roots. If false or undefined,\\n   *                               the principal root is returned.\\n   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x\\n   * @private\\n   */\\n\\n  function _cbrtComplex(x, allRoots) {\\n    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers\\n    var arg3 = x.arg() / 3;\\n    var abs = x.abs(); // principal root:\\n\\n    var principal = new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3).exp());\\n\\n    if (allRoots) {\\n      var all = [principal, new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()), new Complex((0, _index.cbrtNumber)(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())];\\n      return config.matrix === 'Array' ? all : matrix(all);\\n    } else {\\n      return principal;\\n    }\\n  }\\n  /**\\n   * Calculate the cubic root for a Unit\\n   * @param {Unit} x\\n   * @return {Unit} Returns the cubic root of x\\n   * @private\\n   */\\n\\n\\n  function _cbrtUnit(x) {\\n    if (x.value && (0, _is.isComplex)(x.value)) {\\n      var result = x.clone();\\n      result.value = 1.0;\\n      result = result.pow(1.0 / 3); // Compute the units\\n\\n      result.value = _cbrtComplex(x.value); // Compute the value\\n\\n      return result;\\n    } else {\\n      var negate = isNegative(x.value);\\n\\n      if (negate) {\\n        x.value = unaryMinus(x.value);\\n      } // TODO: create a helper function for this\\n\\n\\n      var third;\\n\\n      if ((0, _is.isBigNumber)(x.value)) {\\n        third = new BigNumber(1).div(3);\\n      } else if ((0, _is.isFraction)(x.value)) {\\n        third = new Fraction(1, 3);\\n      } else {\\n        third = 1 / 3;\\n      }\\n\\n      var _result = x.pow(third);\\n\\n      if (negate) {\\n        _result.value = unaryMinus(_result.value);\\n      }\\n\\n      return _result;\\n    }\\n  }\\n});\\nexports.createCbrt = createCbrt;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCbrt\",\"_factory\",\"_is\",\"_collection\",\"_index\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_cbrtComplex\",\"x\",\"allRoots\",\"arg3\",\"arg\",\"abs\",\"principal\",\"mul\",\"Complex\",\"cbrtNumber\",\"exp\",\"all\",\"Math\",\"PI\",\"config\",\"matrix\",\"typed\",\"isNegative\",\"unaryMinus\",\"BigNumber\",\"Fraction\",\"number\",\"cbrt\",\"Unit\",\"_cbrtUnit\",\"isComplex\",\"result\",\"clone\",\"pow\",\"negate\",\"third\",\"isBigNumber\",\"div\",\"isFraction\",\"_result\",\"ArrayMatrix\",\"deepMap\"]\n}\n"]