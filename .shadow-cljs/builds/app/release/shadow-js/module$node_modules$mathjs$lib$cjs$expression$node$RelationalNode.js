["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/RelationalNode.js"],"~:js","shadow$provide[268]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createRelationalNode=void 0;var q=b(255),f=b(21),u=b(147),k=b(260);c=b(25);c=(0,c.factory)(\"RelationalNode\",[\"Node\"],function(t){function p(g,d){if(!(this instanceof p))throw new SyntaxError(\"Constructor must be called with the new operator\");if(!Array.isArray(g))throw new TypeError(\"Parameter conditionals must be an array\");if(!Array.isArray(d))throw new TypeError(\"Parameter params must be an array\");if(g.length!==\nd.length-1)throw new TypeError(\"Parameter params must contain exactly one more element than parameter conditionals\");this.conditionals=g;this.params=d}p.prototype=new t.Node;p.prototype.type=\"RelationalNode\";p.prototype.isRelationalNode=!0;p.prototype._compile=function(g,d){var l=this,h=this.params.map(function(n){return n._compile(g,d)});return function(n,r,v){for(var C,z=h[0](n,r,v),w=0;w<l.conditionals.length;w++)if(C=z,z=h[w+1](n,r,v),!(0,u.getSafeProperty)(g,l.conditionals[w])(C,z))return!1;\nreturn!0}};p.prototype.forEach=function(g){var d=this;this.params.forEach(function(l,h){return g(l,\"params[\"+h+\"]\",d)},this)};p.prototype.map=function(g){var d=this;return new p(this.conditionals.slice(),this.params.map(function(l,h){return d._ifNode(g(l,\"params[\"+h+\"]\",d))},this))};p.prototype.clone=function(){return new p(this.conditionals,this.params)};p.prototype._toString=function(g){for(var d=g&&g.parenthesis?g.parenthesis:\"keep\",l=(0,q.getPrecedence)(this,d),h=this.params.map(function(C,z){z=\n(0,q.getPrecedence)(C,d);return\"all\"===d||null!==z&&z<=l?\"(\"+C.toString(g)+\")\":C.toString(g)}),n={equal:\"\\x3d\\x3d\",unequal:\"!\\x3d\",smaller:\"\\x3c\",larger:\"\\x3e\",smallerEq:\"\\x3c\\x3d\",largerEq:\"\\x3e\\x3d\"},r=h[0],v=0;v<this.conditionals.length;v++)r+=\" \"+n[this.conditionals[v]]+\" \"+h[v+1];return r};p.prototype.toJSON=function(){return{mathjs:\"RelationalNode\",conditionals:this.conditionals,params:this.params}};p.fromJSON=function(g){return new p(g.conditionals,g.params)};p.prototype.toHTML=function(g){for(var d=\ng&&g.parenthesis?g.parenthesis:\"keep\",l=(0,q.getPrecedence)(this,d),h=this.params.map(function(C,z){z=(0,q.getPrecedence)(C,d);return\"all\"===d||null!==z&&z<=l?'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+C.toHTML(g)+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e':C.toHTML(g)}),n={equal:\"\\x3d\\x3d\",unequal:\"!\\x3d\",smaller:\"\\x3c\",larger:\"\\x3e\",smallerEq:\"\\x3c\\x3d\",largerEq:\"\\x3e\\x3d\"},r=h[0],v=0;v<this.conditionals.length;v++)r+='\\x3cspan class\\x3d\"math-operator math-binary-operator math-explicit-binary-operator\"\\x3e'+\n(0,f.escape)(n[this.conditionals[v]])+\"\\x3c/span\\x3e\"+h[v+1];return r};p.prototype._toTex=function(g){for(var d=g&&g.parenthesis?g.parenthesis:\"keep\",l=(0,q.getPrecedence)(this,d),h=this.params.map(function(v,C){C=(0,q.getPrecedence)(v,d);return\"all\"===d||null!==C&&C<=l?\"\\\\left(\"+v.toTex(g)+\"\\right)\":v.toTex(g)}),n=h[0],r=0;r<this.conditionals.length;r++)n+=k.latexOperators[this.conditionals[r]]+h[r+1];return n};return p},{isClass:!0,isNode:!0});a.createRelationalNode=c}","~:source","shadow$provide[268] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRelationalNode = void 0;\n\nvar _operators = require(\"../operators.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nvar createRelationalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = (0, _customs.getSafeProperty)(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += _latex.latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createRelationalNode = createRelationalNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$module$node_modules$mathjs$lib$cjs$expression$operators","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$latex","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","forEach","fromJSON","isClass","toHTML","smaller","params","prototype","_toString","larger","isNode","_toTex","__esModule","largerEq","unequal","value","conditionals","mathjs","type","clone","createRelationalNode","equal","_compile","isRelationalNode","smallerEq","toJSON"]],"~:compiled-at",1619135723969,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$RelationalNode.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/RelationalNode.js\"],\n\"sourcesContent\":[\"shadow$provide[268] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createRelationalNode = void 0;\\n\\nvar _operators = require(\\\"../operators.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nvar _latex = require(\\\"../../utils/latex.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'RelationalNode';\\nvar dependencies = ['Node'];\\nvar createRelationalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Node = _ref.Node;\\n\\n  /**\\n   * A node representing a chained conditional expression, such as 'x > y > z'\\n   *\\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\\n   * @param {Node[]} params   The parameters that will be compared\\n   *\\n   * @constructor RelationalNode\\n   * @extends {Node}\\n   */\\n  function RelationalNode(conditionals, params) {\\n    if (!(this instanceof RelationalNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\\n    this.conditionals = conditionals;\\n    this.params = params;\\n  }\\n\\n  RelationalNode.prototype = new Node();\\n  RelationalNode.prototype.type = 'RelationalNode';\\n  RelationalNode.prototype.isRelationalNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  RelationalNode.prototype._compile = function (math, argNames) {\\n    var self = this;\\n    var compiled = this.params.map(function (p) {\\n      return p._compile(math, argNames);\\n    });\\n    return function evalRelationalNode(scope, args, context) {\\n      var evalLhs;\\n      var evalRhs = compiled[0](scope, args, context);\\n\\n      for (var i = 0; i < self.conditionals.length; i++) {\\n        evalLhs = evalRhs;\\n        evalRhs = compiled[i + 1](scope, args, context);\\n        var condFn = (0, _customs.getSafeProperty)(math, self.conditionals[i]);\\n\\n        if (!condFn(evalLhs, evalRhs)) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    };\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  RelationalNode.prototype.forEach = function (callback) {\\n    var _this = this;\\n\\n    this.params.forEach(function (n, i) {\\n      return callback(n, 'params[' + i + ']', _this);\\n    }, this);\\n  };\\n  /**\\n   * Create a new RelationalNode having its childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {RelationalNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  RelationalNode.prototype.map = function (callback) {\\n    var _this2 = this;\\n\\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\\n    }, this));\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {RelationalNode}\\n   */\\n\\n\\n  RelationalNode.prototype.clone = function () {\\n    return new RelationalNode(this.conditionals, this.params);\\n  };\\n  /**\\n   * Get string representation.\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RelationalNode.prototype._toString = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\\n    var paramStrings = this.params.map(function (p, index) {\\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\\n    });\\n    var operatorMap = {\\n      equal: '==',\\n      unequal: '!=',\\n      smaller: '<',\\n      larger: '>',\\n      smallerEq: '<=',\\n      largerEq: '>='\\n    };\\n    var ret = paramStrings[0];\\n\\n    for (var i = 0; i < this.conditionals.length; i++) {\\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\\n    }\\n\\n    return ret;\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  RelationalNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'RelationalNode',\\n      conditionals: this.conditionals,\\n      params: this.params\\n    };\\n  };\\n  /**\\n   * Instantiate a RelationalNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"RelationalNode\\\", \\\"condition\\\": ..., \\\"trueExpr\\\": ..., \\\"falseExpr\\\": ...}`,\\n   *                       where mathjs is optional\\n   * @returns {RelationalNode}\\n   */\\n\\n\\n  RelationalNode.fromJSON = function (json) {\\n    return new RelationalNode(json.conditionals, json.params);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RelationalNode.prototype.toHTML = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\\n    var paramStrings = this.params.map(function (p, index) {\\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + p.toHTML(options) + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>' : p.toHTML(options);\\n    });\\n    var operatorMap = {\\n      equal: '==',\\n      unequal: '!=',\\n      smaller: '<',\\n      larger: '>',\\n      smallerEq: '<=',\\n      largerEq: '>='\\n    };\\n    var ret = paramStrings[0];\\n\\n    for (var i = 0; i < this.conditionals.length; i++) {\\n      ret += '<span class=\\\"math-operator math-binary-operator math-explicit-binary-operator\\\">' + (0, _string.escape)(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\\n    }\\n\\n    return ret;\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  RelationalNode.prototype._toTex = function (options) {\\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\\n    var paramStrings = this.params.map(function (p, index) {\\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\\\\\left(' + p.toTex(options) + '\\\\right)' : p.toTex(options);\\n    });\\n    var ret = paramStrings[0];\\n\\n    for (var i = 0; i < this.conditionals.length; i++) {\\n      ret += _latex.latexOperators[this.conditionals[i]] + paramStrings[i + 1];\\n    }\\n\\n    return ret;\\n  };\\n\\n  return RelationalNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createRelationalNode = createRelationalNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createRelationalNode\",\"_operators\",\"_string\",\"_customs\",\"_latex\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"RelationalNode\",\"conditionals\",\"params\",\"SyntaxError\",\"Array\",\"isArray\",\"TypeError\",\"length\",\"prototype\",\"Node\",\"type\",\"isRelationalNode\",\"_compile\",\"RelationalNode.prototype._compile\",\"math\",\"argNames\",\"self\",\"compiled\",\"map\",\"p\",\"evalRelationalNode\",\"scope\",\"args\",\"context\",\"evalLhs\",\"evalRhs\",\"i\",\"condFn\",\"getSafeProperty\",\"forEach\",\"RelationalNode.prototype.forEach\",\"callback\",\"_this\",\"n\",\"RelationalNode.prototype.map\",\"_this2\",\"slice\",\"_ifNode\",\"clone\",\"RelationalNode.prototype.clone\",\"_toString\",\"RelationalNode.prototype._toString\",\"options\",\"parenthesis\",\"precedence\",\"getPrecedence\",\"paramStrings\",\"index\",\"paramPrecedence\",\"toString\",\"operatorMap\",\"equal\",\"unequal\",\"smaller\",\"larger\",\"smallerEq\",\"largerEq\",\"ret\",\"toJSON\",\"RelationalNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"RelationalNode.fromJSON\",\"json\",\"toHTML\",\"RelationalNode.prototype.toHTML\",\"escape\",\"_toTex\",\"RelationalNode.prototype._toTex\",\"toTex\",\"latexOperators\",\"isClass\",\"isNode\"]\n}\n"]