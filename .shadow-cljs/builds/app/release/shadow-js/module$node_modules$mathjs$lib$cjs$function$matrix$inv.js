["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/inv.js"],"~:js","shadow$provide[523]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createInv=void 0;var q=b(14),f=b(24);c=b(25);var u=b(21);b=(0,c.factory)(\"inv\",\"typed matrix divideScalar addScalar multiply unaryMinus det identity abs\".split(\" \"),function(k){function t(z,w,B){if(1===w){w=z[0][0];if(0===w)throw Error(\"Cannot calculate inverse, determinant is zero\");return[[d(1,w)]]}if(2===w){w=r(z);if(0===w)throw Error(\"Cannot calculate inverse, determinant is zero\");return[[d(z[1][1],w),d(n(z[0][1]),\nw)],[d(n(z[1][0]),w),d(z[0][0],w)]]}var x=z.concat();for(z=0;z<w;z++)x[z]=x[z].concat();for(var D=v(w).valueOf(),F=0;F<B;F++){var E=C(x[F][F]);var G=F;for(z=F+1;z<w;)C(x[z][F])>E&&(E=C(x[z][F]),G=z),z++;if(0===E)throw Error(\"Cannot calculate inverse, determinant is zero\");z=G;z!==F&&(E=x[F],x[F]=x[z],x[z]=E,E=D[F],D[F]=D[z],D[z]=E);var I=x[F],L=D[F];for(z=0;z<w;z++){var M=x[z],S=D[z];if(z!==F){if(0!==M[F]){G=d(n(M[F]),I[F]);for(E=F;E<B;E++)M[E]=l(M[E],h(G,I[E]));for(E=0;E<B;E++)S[E]=l(S[E],h(G,L[E]))}}else{G=\nI[F];for(E=F;E<B;E++)M[E]=d(M[E],G);for(E=0;E<B;E++)S[E]=d(S[E],G)}}}return D}var p=k.typed,g=k.matrix,d=k.divideScalar,l=k.addScalar,h=k.multiply,n=k.unaryMinus,r=k.det,v=k.identity,C=k.abs;return p(\"inv\",{\"Array | Matrix\":function(z){var w=(0,q.isMatrix)(z)?z.size():(0,f.arraySize)(z);switch(w.length){case 1:if(1===w[0])return(0,q.isMatrix)(z)?g([d(1,z.valueOf()[0])]):[d(1,z[0])];throw new RangeError(\"Matrix must be square (size: \"+(0,u.format)(w)+\")\");case 2:var B=w[0],x=w[1];if(B===x)return(0,\nq.isMatrix)(z)?g(t(z.valueOf(),B,x),z.storage()):t(z,B,x);throw new RangeError(\"Matrix must be square (size: \"+(0,u.format)(w)+\")\");default:throw new RangeError(\"Matrix must be two dimensional (size: \"+(0,u.format)(w)+\")\");}},any:function(z){return d(1,z)}})});a.createInv=b}","~:source","shadow$provide[523] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInv = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      addScalar = _ref.addScalar,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      det = _ref.det,\n      identity = _ref.identity,\n      abs = _ref.abs;\n\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if ((0, _is.isMatrix)(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              if ((0, _is.isMatrix)(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n});\nexports.createInv = createInv;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","createInv","any","value"]],"~:compiled-at",1619135724016,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$inv.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/inv.js\"],\n\"sourcesContent\":[\"shadow$provide[523] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createInv = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar name = 'inv';\\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divideScalar = _ref.divideScalar,\\n      addScalar = _ref.addScalar,\\n      multiply = _ref.multiply,\\n      unaryMinus = _ref.unaryMinus,\\n      det = _ref.det,\\n      identity = _ref.identity,\\n      abs = _ref.abs;\\n\\n  /**\\n   * Calculate the inverse of a square matrix.\\n   *\\n   * Syntax:\\n   *\\n   *     math.inv(x)\\n   *\\n   * Examples:\\n   *\\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\\n   *     math.inv(4)                 // returns 0.25\\n   *     1 / 4                       // returns 0.25\\n   *\\n   * See also:\\n   *\\n   *     det, transpose\\n   *\\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\\n   */\\n  return typed(name, {\\n    'Array | Matrix': function ArrayMatrix(x) {\\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\\n\\n      switch (size.length) {\\n        case 1:\\n          // vector\\n          if (size[0] === 1) {\\n            if ((0, _is.isMatrix)(x)) {\\n              return matrix([divideScalar(1, x.valueOf()[0])]);\\n            } else {\\n              return [divideScalar(1, x[0])];\\n            }\\n          } else {\\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n          }\\n\\n        case 2:\\n          // two dimensional array\\n          {\\n            var rows = size[0];\\n            var cols = size[1];\\n\\n            if (rows === cols) {\\n              if ((0, _is.isMatrix)(x)) {\\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\\n              } else {\\n                // return an Array\\n                return _inv(x, rows, cols);\\n              }\\n            } else {\\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n            }\\n          }\\n\\n        default:\\n          // multi dimensional array\\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\\n      }\\n    },\\n    any: function any(x) {\\n      // scalar\\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\\n    }\\n  });\\n  /**\\n   * Calculate the inverse of a square matrix\\n   * @param {Array[]} mat     A square matrix\\n   * @param {number} rows     Number of rows\\n   * @param {number} cols     Number of columns, must equal rows\\n   * @return {Array[]} inv    Inverse matrix\\n   * @private\\n   */\\n\\n  function _inv(mat, rows, cols) {\\n    var r, s, f, value, temp;\\n\\n    if (rows === 1) {\\n      // this is a 1 x 1 matrix\\n      value = mat[0][0];\\n\\n      if (value === 0) {\\n        throw Error('Cannot calculate inverse, determinant is zero');\\n      }\\n\\n      return [[divideScalar(1, value)]];\\n    } else if (rows === 2) {\\n      // this is a 2 x 2 matrix\\n      var d = det(mat);\\n\\n      if (d === 0) {\\n        throw Error('Cannot calculate inverse, determinant is zero');\\n      }\\n\\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\\n    } else {\\n      // this is a matrix of 3 x 3 or larger\\n      // calculate inverse using gauss-jordan elimination\\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\\n      //      http://mathworld.wolfram.com/MatrixInverse.html\\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\\n      // make a copy of the matrix (only the arrays, not of the elements)\\n      var A = mat.concat();\\n\\n      for (r = 0; r < rows; r++) {\\n        A[r] = A[r].concat();\\n      } // create an identity matrix which in the end will contain the\\n      // matrix inverse\\n\\n\\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\\n\\n      for (var c = 0; c < cols; c++) {\\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\\n        var ABig = abs(A[c][c]);\\n        var rBig = c;\\n        r = c + 1;\\n\\n        while (r < rows) {\\n          if (abs(A[r][c]) > ABig) {\\n            ABig = abs(A[r][c]);\\n            rBig = r;\\n          }\\n\\n          r++;\\n        }\\n\\n        if (ABig === 0) {\\n          throw Error('Cannot calculate inverse, determinant is zero');\\n        }\\n\\n        r = rBig;\\n\\n        if (r !== c) {\\n          temp = A[c];\\n          A[c] = A[r];\\n          A[r] = temp;\\n          temp = B[c];\\n          B[c] = B[r];\\n          B[r] = temp;\\n        } // eliminate non-zero values on the other rows at column c\\n\\n\\n        var Ac = A[c];\\n        var Bc = B[c];\\n\\n        for (r = 0; r < rows; r++) {\\n          var Ar = A[r];\\n          var Br = B[r];\\n\\n          if (r !== c) {\\n            // eliminate value at column c and row r\\n            if (Ar[c] !== 0) {\\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\\n              // at column c\\n\\n              for (s = c; s < cols; s++) {\\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\\n              }\\n\\n              for (s = 0; s < cols; s++) {\\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\\n              }\\n            }\\n          } else {\\n            // normalize value at Acc to 1,\\n            // divide each value on row r with the value at Acc\\n            f = Ac[c];\\n\\n            for (s = c; s < cols; s++) {\\n              Ar[s] = divideScalar(Ar[s], f);\\n            }\\n\\n            for (s = 0; s < cols; s++) {\\n              Br[s] = divideScalar(Br[s], f);\\n            }\\n          }\\n        }\\n      }\\n\\n      return B;\\n    }\\n  }\\n});\\nexports.createInv = createInv;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createInv\",\"_is\",\"_array\",\"_factory\",\"_string\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_inv\",\"mat\",\"rows\",\"cols\",\"Error\",\"divideScalar\",\"d\",\"det\",\"unaryMinus\",\"A\",\"concat\",\"r\",\"B\",\"identity\",\"valueOf\",\"c\",\"ABig\",\"abs\",\"rBig\",\"temp\",\"Ac\",\"Bc\",\"Ar\",\"Br\",\"f\",\"s\",\"addScalar\",\"multiply\",\"typed\",\"matrix\",\"ArrayMatrix\",\"x\",\"size\",\"isMatrix\",\"arraySize\",\"length\",\"RangeError\",\"format\",\"storage\",\"any\"]\n}\n"]