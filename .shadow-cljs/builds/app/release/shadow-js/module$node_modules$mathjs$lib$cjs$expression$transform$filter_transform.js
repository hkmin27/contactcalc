["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/transform/filter.transform.js"],"~:js","shadow$provide[577]=function(c,b,y,a){function q(p,g){var d=(0,k.maxArgumentCount)(g);return(0,u.filter)(p,function(l,h,n){return 1===d?g(l):2===d?g(l,[h+1]):g(l,[h+1],n)})}Object.defineProperty(a,\"__esModule\",{value:!0});a.createFilterTransform=void 0;var f=b(14),u=b(24),k=b(127),t=b(576);c=b(25);c=(0,c.factory)(\"filter\",[\"typed\"],function(p){function g(l,h,n){var r,v;l[0]&&(r=l[0].compile().evaluate(n));l[1]&&(v=(0,f.isSymbolNode)(l[1])||(0,f.isFunctionAssignmentNode)(l[1])?l[1].compile().evaluate(n):\n(0,t.compileInlineExpression)(l[1],h,n));return d(r,v)}p=p.typed;g.rawArgs=!0;var d=p(\"filter\",{\"Array, function\":q,\"Matrix, function\":function(l,h){return l.create(q(l.toArray(),h))},\"Array, RegExp\":u.filterRegExp,\"Matrix, RegExp\":function(l,h){return l.create((0,u.filterRegExp)(l.toArray(),h))}});return g},{isTransformFunction:!0});a.createFilterTransform=c}","~:source","shadow$provide[577] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFilterTransform = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _function = require(\"../../utils/function.js\");\n\nvar _compileInlineExpression = require(\"./utils/compileInlineExpression.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'filter';\nvar dependencies = ['typed'];\nvar createFilterTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Attach a transform function to math.filter\n   * Adds a property transform containing the transform function.\n   *\n   * This transform adds support for equations as test function for math.filter,\n   * so you can do something like 'filter([3, -2, 5], x > 0)'.\n   */\n  function filterTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().evaluate(scope);\n    }\n\n    if (args[1]) {\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().evaluate(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\n      }\n    }\n\n    return filter(x, callback);\n  }\n\n  filterTransform.rawArgs = true; // one based version of function filter\n\n  var filter = typed('filter', {\n    'Array, function': _filter,\n    'Matrix, function': function MatrixFunction(x, test) {\n      return x.create(_filter(x.toArray(), test));\n    },\n    'Array, RegExp': _array.filterRegExp,\n    'Matrix, RegExp': function MatrixRegExp(x, test) {\n      return x.create((0, _array.filterRegExp)(x.toArray(), test));\n    }\n  });\n  return filterTransform;\n}, {\n  isTransformFunction: true\n});\n/**\n * Filter values in a callback given a callback function\n *\n * !!! Passes a one-based index !!!\n *\n * @param {Array} x\n * @param {Function} callback\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexports.createFilterTransform = createFilterTransform;\n\nfunction _filter(x, callback) {\n  // figure out what number of arguments the callback function expects\n  var args = (0, _function.maxArgumentCount)(callback);\n  return (0, _array.filter)(x, function (value, index, array) {\n    // invoke the callback function with the right number of arguments\n    if (args === 1) {\n      return callback(value);\n    } else if (args === 2) {\n      return callback(value, [index + 1]);\n    } else {\n      // 3 or -1\n      return callback(value, [index + 1], array);\n    }\n  });\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$expression$transform$utils$compileInlineExpression","~$module$node_modules$mathjs$lib$cjs$utils$function"]],"~:properties",["^5",["rawArgs","__esModule","isTransformFunction","value","createFilterTransform"]],"~:compiled-at",1619135724041,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$transform$filter_transform.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/transform/filter.transform.js\"],\n\"sourcesContent\":[\"shadow$provide[577] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createFilterTransform = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _function = require(\\\"../../utils/function.js\\\");\\n\\nvar _compileInlineExpression = require(\\\"./utils/compileInlineExpression.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'filter';\\nvar dependencies = ['typed'];\\nvar createFilterTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed;\\n\\n  /**\\n   * Attach a transform function to math.filter\\n   * Adds a property transform containing the transform function.\\n   *\\n   * This transform adds support for equations as test function for math.filter,\\n   * so you can do something like 'filter([3, -2, 5], x > 0)'.\\n   */\\n  function filterTransform(args, math, scope) {\\n    var x, callback;\\n\\n    if (args[0]) {\\n      x = args[0].compile().evaluate(scope);\\n    }\\n\\n    if (args[1]) {\\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\\n        callback = args[1].compile().evaluate(scope);\\n      } else {\\n        // an expression like filter([3, -2, 5], x > 0)\\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\\n      }\\n    }\\n\\n    return filter(x, callback);\\n  }\\n\\n  filterTransform.rawArgs = true; // one based version of function filter\\n\\n  var filter = typed('filter', {\\n    'Array, function': _filter,\\n    'Matrix, function': function MatrixFunction(x, test) {\\n      return x.create(_filter(x.toArray(), test));\\n    },\\n    'Array, RegExp': _array.filterRegExp,\\n    'Matrix, RegExp': function MatrixRegExp(x, test) {\\n      return x.create((0, _array.filterRegExp)(x.toArray(), test));\\n    }\\n  });\\n  return filterTransform;\\n}, {\\n  isTransformFunction: true\\n});\\n/**\\n * Filter values in a callback given a callback function\\n *\\n * !!! Passes a one-based index !!!\\n *\\n * @param {Array} x\\n * @param {Function} callback\\n * @return {Array} Returns the filtered array\\n * @private\\n */\\n\\nexports.createFilterTransform = createFilterTransform;\\n\\nfunction _filter(x, callback) {\\n  // figure out what number of arguments the callback function expects\\n  var args = (0, _function.maxArgumentCount)(callback);\\n  return (0, _array.filter)(x, function (value, index, array) {\\n    // invoke the callback function with the right number of arguments\\n    if (args === 1) {\\n      return callback(value);\\n    } else if (args === 2) {\\n      return callback(value, [index + 1]);\\n    } else {\\n      // 3 or -1\\n      return callback(value, [index + 1], array);\\n    }\\n  });\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_filter\",\"x\",\"callback\",\"args\",\"_function\",\"maxArgumentCount\",\"_array\",\"filter\",\"value\",\"index\",\"array\",\"Object\",\"defineProperty\",\"createFilterTransform\",\"_is\",\"_compileInlineExpression\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"filterTransform\",\"math\",\"scope\",\"compile\",\"evaluate\",\"isSymbolNode\",\"isFunctionAssignmentNode\",\"compileInlineExpression\",\"typed\",\"rawArgs\",\"MatrixFunction\",\"test\",\"create\",\"toArray\",\"filterRegExp\",\"MatrixRegExp\",\"isTransformFunction\"]\n}\n"]