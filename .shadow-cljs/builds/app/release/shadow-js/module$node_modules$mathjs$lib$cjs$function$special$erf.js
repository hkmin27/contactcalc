["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/special/erf.js"],"~:js","shadow$provide[152]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createErf=void 0;var q=b(38),f=b(19);c=b(25);c=(0,c.factory)(\"erf\",[\"typed\"],function(g){g=g.typed;return g(\"name\",{number:function(d){var l=Math.abs(d);if(l>=p)return(0,f.sign)(d);if(l<=u){d=(0,f.sign)(d);var h=l*l,n=k[0][4]*h,r=h,v;for(v=0;3>v;v+=1)n=(n+k[0][v])*h,r=(r+t[0][v])*h;return l*(n+k[0][3])/(r+t[0][3])*d}if(4>=l){d=(0,f.sign)(d);h=k[1][8]*l;n=l;for(r=0;7>r;r+=1)h=(h+k[1][r])*l,n=(n+t[1][r])*l;h=(h+\nk[1][7])/(n+t[1][7]);n=parseInt(16*l)/16;return d*(1-Math.exp(-n*n)*Math.exp(-((l-n)*(l+n)))*h)}d=(0,f.sign)(d);h=1/(l*l);n=k[2][5]*h;r=h;for(v=0;4>v;v+=1)n=(n+k[2][v])*h,r=(r+t[2][v])*h;n=h*(n+k[2][4])/(r+t[2][4]);n=(.5641895835477563-n)/l;h=parseInt(16*l)/16;return d*(1-Math.exp(-h*h)*Math.exp(-((l-h)*(l+h)))*n)},\"Array | Matrix\":function(d){return(0,q.deepMap)(d,this)}})});a.createErf=c;var u=.46875,k=[[3.1611237438705655,113.86415415105016,377.485237685302,3209.3775891384694,.18577770618460315],\n[.5641884969886701,8.883149794388377,66.11919063714163,298.6351381974001,881.952221241769,1712.0476126340707,2051.0783778260716,1230.3393547979972,2.1531153547440383E-8],[.30532663496123236,.36034489994980445,.12578172611122926,.016083785148742275,6.587491615298378E-4,.016315387137302097]],t=[[23.601290952344122,244.02463793444417,1282.6165260773723,2844.236833439171],[15.744926110709835,117.6939508913125,537.1811018620099,1621.3895745666903,3290.7992357334597,4362.619090143247,3439.3676741437216,\n1230.3393548037495],[2.568520192289822,1.8729528499234604,.5279051029514285,.06051834131244132,.0023352049762686918]],p=Math.pow(2,53)}","~:source","shadow$provide[152] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createErf = void 0;\n\nvar _collection = require(\"../../utils/collection.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\n/* eslint-disable no-loss-of-precision */\nvar name = 'erf';\nvar dependencies = ['typed'];\nvar createErf = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Compute the erf function of a value using a rational Chebyshev\n   * approximations for different intervals of x.\n   *\n   * This is a translation of W. J. Cody's Fortran implementation from 1987\n   * ( https://www.netlib.org/specfun/erf ). See the AMS publication\n   * \"Rational Chebyshev Approximations for the Error Function\" by W. J. Cody\n   * for an explanation of this process.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.erf(x)\n   *\n   * Examples:\n   *\n   *    math.erf(0.2)    // returns 0.22270258921047847\n   *    math.erf(-0.5)   // returns -0.5204998778130465\n   *    math.erf(4)      // returns 0.9999999845827421\n   *\n   * @param {number | Array | Matrix} x   A real number\n   * @return {number | Array | Matrix}    The erf of `x`\n   */\n  return typed('name', {\n    number: function number(x) {\n      var y = Math.abs(x);\n\n      if (y >= MAX_NUM) {\n        return (0, _number.sign)(x);\n      }\n\n      if (y <= THRESH) {\n        return (0, _number.sign)(x) * erf1(y);\n      }\n\n      if (y <= 4.0) {\n        return (0, _number.sign)(x) * (1 - erfc2(y));\n      }\n\n      return (0, _number.sign)(x) * (1 - erfc3(y));\n    },\n    'Array | Matrix': function ArrayMatrix(n) {\n      return (0, _collection.deepMap)(n, this);\n    } // TODO: For complex numbers, use the approximation for the Faddeeva function\n    //  from \"More Efficient Computation of the Complex Error Function\" (AMS)\n\n  });\n  /**\n   * Approximates the error function erf() for x <= 0.46875 using this function:\n   *               n\n   * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))\n   *              j=0\n   */\n\n  function erf1(y) {\n    var ysq = y * y;\n    var xnum = P[0][4] * ysq;\n    var xden = ysq;\n    var i;\n\n    for (i = 0; i < 3; i += 1) {\n      xnum = (xnum + P[0][i]) * ysq;\n      xden = (xden + Q[0][i]) * ysq;\n    }\n\n    return y * (xnum + P[0][3]) / (xden + Q[0][3]);\n  }\n  /**\n   * Approximates the complement of the error function erfc() for\n   * 0.46875 <= x <= 4.0 using this function:\n   *                       n\n   * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)\n   *                      j=0\n   */\n\n\n  function erfc2(y) {\n    var xnum = P[1][8] * y;\n    var xden = y;\n    var i;\n\n    for (i = 0; i < 7; i += 1) {\n      xnum = (xnum + P[1][i]) * y;\n      xden = (xden + Q[1][i]) * y;\n    }\n\n    var result = (xnum + P[1][7]) / (xden + Q[1][7]);\n    var ysq = parseInt(y * 16) / 16;\n    var del = (y - ysq) * (y + ysq);\n    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;\n  }\n  /**\n   * Approximates the complement of the error function erfc() for x > 4.0 using\n   * this function:\n   *\n   * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +\n   *               n\n   *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]\n   *              j=0\n   */\n\n\n  function erfc3(y) {\n    var ysq = 1 / (y * y);\n    var xnum = P[2][5] * ysq;\n    var xden = ysq;\n    var i;\n\n    for (i = 0; i < 4; i += 1) {\n      xnum = (xnum + P[2][i]) * ysq;\n      xden = (xden + Q[2][i]) * ysq;\n    }\n\n    var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);\n    result = (SQRPI - result) / y;\n    ysq = parseInt(y * 16) / 16;\n    var del = (y - ysq) * (y + ysq);\n    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;\n  }\n});\n/**\n * Upper bound for the first approximation interval, 0 <= x <= THRESH\n * @constant\n */\n\nexports.createErf = createErf;\nvar THRESH = 0.46875;\n/**\n * Constant used by W. J. Cody's Fortran77 implementation to denote sqrt(pi)\n * @constant\n */\n\nvar SQRPI = 5.6418958354775628695e-1;\n/**\n * Coefficients for each term of the numerator sum (p_j) for each approximation\n * interval (see W. J. Cody's paper for more details)\n * @constant\n */\n\nvar P = [[3.16112374387056560e00, 1.13864154151050156e02, 3.77485237685302021e02, 3.20937758913846947e03, 1.85777706184603153e-1], [5.64188496988670089e-1, 8.88314979438837594e00, 6.61191906371416295e01, 2.98635138197400131e02, 8.81952221241769090e02, 1.71204761263407058e03, 2.05107837782607147e03, 1.23033935479799725e03, 2.15311535474403846e-8], [3.05326634961232344e-1, 3.60344899949804439e-1, 1.25781726111229246e-1, 1.60837851487422766e-2, 6.58749161529837803e-4, 1.63153871373020978e-2]];\n/**\n * Coefficients for each term of the denominator sum (q_j) for each approximation\n * interval (see W. J. Cody's paper for more details)\n * @constant\n */\n\nvar Q = [[2.36012909523441209e01, 2.44024637934444173e02, 1.28261652607737228e03, 2.84423683343917062e03], [1.57449261107098347e01, 1.17693950891312499e02, 5.37181101862009858e02, 1.62138957456669019e03, 3.29079923573345963e03, 4.36261909014324716e03, 3.43936767414372164e03, 1.23033935480374942e03], [2.56852019228982242e00, 1.87295284992346047e00, 5.27905102951428412e-1, 6.05183413124413191e-2, 2.33520497626869185e-3]];\n/**\n * Maximum/minimum safe numbers to input to erf() (in ES6+, this number is\n * Number.[MAX|MIN]_SAFE_INTEGER). erf() for all numbers beyond this limit will\n * return 1\n */\n\nvar MAX_NUM = Math.pow(2, 53);\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$collection","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","number","createErf"]],"~:compiled-at",1619135723893,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$special$erf.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,SAAR,CAAoB,IAAK,EAEzB,KAAIC,EAAcP,CAAA,CAAQ,EAAR,CAAlB,CAEIQ,EAAUR,CAAA,CAAQ,EAAR,CAEVS,EAAAA,CAAWT,CAAA,CAAQ,EAAR,CAKXM,EAAAA,CAA2B,CAAC,CAAA,CAAGG,CAASC,CAAAA,OAAb,EAFpBC,KAEoB,CADZC,CAAC,OAADA,CACY,CAA0C,QAAS,CAACC,CAAD,CAAO,CACnFC,CAAAA,CAAQD,CAAKC,CAAAA,KA0BjB,OAAOA,EAAA,CAAM,MAAN,CAAc,CACnBC,OAAQA,QAAe,CAACC,CAAD,CAAI,CACzB,IAAIC,EAAIC,IAAKC,CAAAA,GAAL,CAASH,CAAT,CAER,IAAIC,CAAJ,EAASG,CAAT,CACE,MAAO,CAAC,CAAA,CAAGZ,CAAQa,CAAAA,IAAZ,EAAkBL,CAAlB,CAGT,IAAIC,CAAJ,EAASK,CAAT,CAAiB,CACR,CAAA,CAAA,CAAC,CAAA,CAAGd,CAAQa,CAAAA,IAAZ,EAAkBL,CAAlB,CAuBX,KAAIO,EAvBmCN,CAuBnCM,CAvBmCN,CAuBvC,CACIO,EAAOC,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAAPD,CAAiBD,CADrB,CAEIG,EAAOH,CAFX,CAGII,CAEJ,KAAKA,CAAL,CAAS,CAAT,CAAgB,CAAhB,CAAYA,CAAZ,CAAmBA,CAAnB,EAAwB,CAAxB,CACEH,CACA,EADQA,CACR,CADeC,CAAA,CAAE,CAAF,CAAA,CAAKE,CAAL,CACf,EAD0BJ,CAC1B,CAAAG,CAAA,EAAQA,CAAR,CAAeE,CAAA,CAAE,CAAF,CAAA,CAAKD,CAAL,CAAf,EAA0BJ,CA9BxB,OAAmCN,EAAnC,EAiCQO,CAjCR,CAiCeC,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAjCf,GAiC2BC,CAjC3B,CAiCkCE,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAjClC,EAAO,CADQ,CAIjB,GAAS,CAAT,EAAIX,CAAJ,CAAc,CACL,CAAA,CAAA,CAAC,CAAA,CAAGT,CAAQa,CAAAA,IAAZ,EAAkBL,CAAlB,CAyCPQ,EAAAA,CAAOC,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAAPD,CAzCyCP,CA0CzCS,EAAAA,CA1CyCT,CA6C7C,KAAKU,CAAL,CAAS,CAAT,CAAgB,CAAhB,CAAYA,CAAZ,CAAmBA,CAAnB,EAAwB,CAAxB,CACEH,CACA,EADQA,CACR,CADeC,CAAA,CAAE,CAAF,CAAA,CAAKE,CAAL,CACf,EA/C2CV,CA+C3C,CAAAS,CAAA,EAAQA,CAAR,CAAeE,CAAA,CAAE,CAAF,CAAA,CAAKD,CAAL,CAAf,EA/C2CV,CAkDzCY,EAAAA,EAAUL,CAAVK;AAAiBJ,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAAjBI,GAA6BH,CAA7BG,CAAoCD,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAApCC,CACAN,EAAAA,CAAMO,QAAA,CAAa,EAAb,CAnDmCb,CAmDnC,CAANM,CAAyB,EAnDzB,OAAO,EAAP,EAA+B,CAA/B,CAqDGL,IAAKa,CAAAA,GAAL,CAAS,CAACR,CAAV,CAAgBA,CAAhB,CArDH,CAqD0BL,IAAKa,CAAAA,GAAL,CAAS,GArDMd,CAqDN,CADxBM,CACwB,GArDMN,CAqDN,CADZM,CACY,EAAT,CArD1B,CAqD2CM,CArD3C,CADY,CAIP,CAAA,CAAA,CAAC,CAAA,CAAGrB,CAAQa,CAAAA,IAAZ,EAAkBL,CAAlB,CAgELO,EAAAA,CAAM,CAANA,EAhEuCN,CAgEvCM,CAhEuCN,CAgEvCM,CACAC,EAAAA,CAAOC,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAAPD,CAAiBD,CACjBG,EAAAA,CAAOH,CAGX,KAAKI,CAAL,CAAS,CAAT,CAAgB,CAAhB,CAAYA,CAAZ,CAAmBA,CAAnB,EAAwB,CAAxB,CACEH,CACA,EADQA,CACR,CADeC,CAAA,CAAE,CAAF,CAAA,CAAKE,CAAL,CACf,EAD0BJ,CAC1B,CAAAG,CAAA,EAAQA,CAAR,CAAeE,CAAA,CAAE,CAAF,CAAA,CAAKD,CAAL,CAAf,EAA0BJ,CAGxBM,EAAAA,CAASN,CAATM,EAAgBL,CAAhBK,CAAuBJ,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAAvBI,GAAmCH,CAAnCG,CAA0CD,CAAA,CAAE,CAAF,CAAA,CAAK,CAAL,CAA1CC,CACJA,EAAA,EAkBQG,iBAlBR,CAAkBH,CAAlB,EA3E2CZ,CA4E3CM,EAAA,CAAMO,QAAA,CAAa,EAAb,CA5EqCb,CA4ErC,CAAN,CAAyB,EA5EvB,OAAO,EAAP,EAA+B,CAA/B,CA8EKC,IAAKa,CAAAA,GAAL,CAAS,CAACR,CAAV,CAAgBA,CAAhB,CA9EL,CA8E4BL,IAAKa,CAAAA,GAAL,CAAS,GA9EId,CA8EJ,CADxBM,CACwB,GA9EIN,CA8EJ,CADZM,CACY,EAAT,CA9E5B,CA8E6CM,CA9E7C,CAfyB,CADR,CAkBnB,iBAAkBI,QAAoB,CAACC,CAAD,CAAI,CACxC,MAAO,CAAC,CAAA,CAAG3B,CAAY4B,CAAAA,OAAhB,EAAyBD,CAAzB,CAA4B,IAA5B,CADiC,CAlBvB,CAAd,CA3BgF,CAA1D,CAiI/BhC,EAAQI,CAAAA,SAAR,CAAoBA,CACpB,KAAIgB,EAAS,MAAb,CAaIG,EAAI,CAAC,CAAC,kBAAD,CAAyB,kBAAzB,CAAiD,gBAAjD,CAAyE,kBAAzE,CAAiG,kBAAjG,CAAD;AAA2H,CAAC,iBAAD,CAAyB,iBAAzB,CAAiD,iBAAjD,CAAyE,iBAAzE,CAAiG,gBAAjG,CAAyH,kBAAzH,CAAiJ,kBAAjJ,CAAyK,kBAAzK,CAAiM,qBAAjM,CAA3H,CAAqV,CAAC,kBAAD,CAAyB,kBAAzB,CAAiD,kBAAjD,CAAyE,mBAAzE,CAAiG,oBAAjG,CAAyH,mBAAzH,CAArV,CAbR,CAoBIG,EAAI,CAAC,CAAC,kBAAD,CAAyB,kBAAzB,CAAiD,kBAAjD,CAAyE,iBAAzE,CAAD,CAAmG,CAAC,kBAAD,CAAyB,iBAAzB,CAAiD,iBAAjD,CAAyE,kBAAzE,CAAiG,kBAAjG,CAAyH,iBAAzH,CAAiJ,kBAAjJ;AAAyK,kBAAzK,CAAnG,CAAqS,CAAC,iBAAD,CAAyB,kBAAzB,CAAiD,iBAAjD,CAAyE,kBAAzE,CAAiG,oBAAjG,CAArS,CApBR,CA2BIR,EAAUF,IAAKkB,CAAAA,GAAL,CAAS,CAAT,CAAY,EAAZ,CA9KgD;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/special/erf.js\"],\n\"sourcesContent\":[\"shadow$provide[152] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createErf = void 0;\\n\\nvar _collection = require(\\\"../../utils/collection.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\n/* eslint-disable no-loss-of-precision */\\nvar name = 'erf';\\nvar dependencies = ['typed'];\\nvar createErf = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed;\\n\\n  /**\\n   * Compute the erf function of a value using a rational Chebyshev\\n   * approximations for different intervals of x.\\n   *\\n   * This is a translation of W. J. Cody's Fortran implementation from 1987\\n   * ( https://www.netlib.org/specfun/erf ). See the AMS publication\\n   * \\\"Rational Chebyshev Approximations for the Error Function\\\" by W. J. Cody\\n   * for an explanation of this process.\\n   *\\n   * For matrices, the function is evaluated element wise.\\n   *\\n   * Syntax:\\n   *\\n   *    math.erf(x)\\n   *\\n   * Examples:\\n   *\\n   *    math.erf(0.2)    // returns 0.22270258921047847\\n   *    math.erf(-0.5)   // returns -0.5204998778130465\\n   *    math.erf(4)      // returns 0.9999999845827421\\n   *\\n   * @param {number | Array | Matrix} x   A real number\\n   * @return {number | Array | Matrix}    The erf of `x`\\n   */\\n  return typed('name', {\\n    number: function number(x) {\\n      var y = Math.abs(x);\\n\\n      if (y >= MAX_NUM) {\\n        return (0, _number.sign)(x);\\n      }\\n\\n      if (y <= THRESH) {\\n        return (0, _number.sign)(x) * erf1(y);\\n      }\\n\\n      if (y <= 4.0) {\\n        return (0, _number.sign)(x) * (1 - erfc2(y));\\n      }\\n\\n      return (0, _number.sign)(x) * (1 - erfc3(y));\\n    },\\n    'Array | Matrix': function ArrayMatrix(n) {\\n      return (0, _collection.deepMap)(n, this);\\n    } // TODO: For complex numbers, use the approximation for the Faddeeva function\\n    //  from \\\"More Efficient Computation of the Complex Error Function\\\" (AMS)\\n\\n  });\\n  /**\\n   * Approximates the error function erf() for x <= 0.46875 using this function:\\n   *               n\\n   * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))\\n   *              j=0\\n   */\\n\\n  function erf1(y) {\\n    var ysq = y * y;\\n    var xnum = P[0][4] * ysq;\\n    var xden = ysq;\\n    var i;\\n\\n    for (i = 0; i < 3; i += 1) {\\n      xnum = (xnum + P[0][i]) * ysq;\\n      xden = (xden + Q[0][i]) * ysq;\\n    }\\n\\n    return y * (xnum + P[0][3]) / (xden + Q[0][3]);\\n  }\\n  /**\\n   * Approximates the complement of the error function erfc() for\\n   * 0.46875 <= x <= 4.0 using this function:\\n   *                       n\\n   * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)\\n   *                      j=0\\n   */\\n\\n\\n  function erfc2(y) {\\n    var xnum = P[1][8] * y;\\n    var xden = y;\\n    var i;\\n\\n    for (i = 0; i < 7; i += 1) {\\n      xnum = (xnum + P[1][i]) * y;\\n      xden = (xden + Q[1][i]) * y;\\n    }\\n\\n    var result = (xnum + P[1][7]) / (xden + Q[1][7]);\\n    var ysq = parseInt(y * 16) / 16;\\n    var del = (y - ysq) * (y + ysq);\\n    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;\\n  }\\n  /**\\n   * Approximates the complement of the error function erfc() for x > 4.0 using\\n   * this function:\\n   *\\n   * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +\\n   *               n\\n   *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]\\n   *              j=0\\n   */\\n\\n\\n  function erfc3(y) {\\n    var ysq = 1 / (y * y);\\n    var xnum = P[2][5] * ysq;\\n    var xden = ysq;\\n    var i;\\n\\n    for (i = 0; i < 4; i += 1) {\\n      xnum = (xnum + P[2][i]) * ysq;\\n      xden = (xden + Q[2][i]) * ysq;\\n    }\\n\\n    var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);\\n    result = (SQRPI - result) / y;\\n    ysq = parseInt(y * 16) / 16;\\n    var del = (y - ysq) * (y + ysq);\\n    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;\\n  }\\n});\\n/**\\n * Upper bound for the first approximation interval, 0 <= x <= THRESH\\n * @constant\\n */\\n\\nexports.createErf = createErf;\\nvar THRESH = 0.46875;\\n/**\\n * Constant used by W. J. Cody's Fortran77 implementation to denote sqrt(pi)\\n * @constant\\n */\\n\\nvar SQRPI = 5.6418958354775628695e-1;\\n/**\\n * Coefficients for each term of the numerator sum (p_j) for each approximation\\n * interval (see W. J. Cody's paper for more details)\\n * @constant\\n */\\n\\nvar P = [[3.16112374387056560e00, 1.13864154151050156e02, 3.77485237685302021e02, 3.20937758913846947e03, 1.85777706184603153e-1], [5.64188496988670089e-1, 8.88314979438837594e00, 6.61191906371416295e01, 2.98635138197400131e02, 8.81952221241769090e02, 1.71204761263407058e03, 2.05107837782607147e03, 1.23033935479799725e03, 2.15311535474403846e-8], [3.05326634961232344e-1, 3.60344899949804439e-1, 1.25781726111229246e-1, 1.60837851487422766e-2, 6.58749161529837803e-4, 1.63153871373020978e-2]];\\n/**\\n * Coefficients for each term of the denominator sum (q_j) for each approximation\\n * interval (see W. J. Cody's paper for more details)\\n * @constant\\n */\\n\\nvar Q = [[2.36012909523441209e01, 2.44024637934444173e02, 1.28261652607737228e03, 2.84423683343917062e03], [1.57449261107098347e01, 1.17693950891312499e02, 5.37181101862009858e02, 1.62138957456669019e03, 3.29079923573345963e03, 4.36261909014324716e03, 3.43936767414372164e03, 1.23033935480374942e03], [2.56852019228982242e00, 1.87295284992346047e00, 5.27905102951428412e-1, 6.05183413124413191e-2, 2.33520497626869185e-3]];\\n/**\\n * Maximum/minimum safe numbers to input to erf() (in ES6+, this number is\\n * Number.[MAX|MIN]_SAFE_INTEGER). erf() for all numbers beyond this limit will\\n * return 1\\n */\\n\\nvar MAX_NUM = Math.pow(2, 53);\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createErf\",\"_collection\",\"_number\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"number\",\"x\",\"y\",\"Math\",\"abs\",\"MAX_NUM\",\"sign\",\"THRESH\",\"ysq\",\"xnum\",\"P\",\"xden\",\"i\",\"Q\",\"result\",\"parseInt\",\"exp\",\"SQRPI\",\"ArrayMatrix\",\"n\",\"deepMap\",\"pow\"]\n}\n"]