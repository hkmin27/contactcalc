["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/complex/Complex.js"],"~:js","shadow$provide[31]=function(c,b,y,a){function q(t){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(p){return typeof p}:function(p){return p&&\"function\"===typeof Symbol&&p.constructor===Symbol&&p!==Symbol.prototype?\"symbol\":typeof p};return q(t)}Object.defineProperty(a,\"__esModule\",{value:!0});a.createComplexClass=void 0;var f=function(t){return t&&t.__esModule?t:{\"default\":t}}(b(30)),u=b(19),k=b(14);c=b(25);c=(0,c.factory)(\"Complex\",[],function(){f[\"default\"].prototype.type=\n\"Complex\";f[\"default\"].prototype.isComplex=!0;f[\"default\"].prototype.toJSON=function(){return{mathjs:\"Complex\",re:this.re,im:this.im}};f[\"default\"].prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}};f[\"default\"].prototype.format=function(t){var p=this.im,g=this.re,d=(0,u.format)(this.re,t),l=(0,u.format)(this.im,t);t=(0,k.isNumber)(t)?t:t?t.precision:null;null!==t&&(t=Math.pow(10,-t),Math.abs(g/p)<t&&(g=0),Math.abs(p/g)<t&&(p=0));return 0===p?d:0===g?1===p?\"i\":-1===p?\"-i\":l+\"i\":0>p?\n-1===p?d+\" - i\":d+\" - \"+l.substring(1)+\"i\":1===p?d+\" + i\":d+\" + \"+l+\"i\"};f[\"default\"].fromPolar=function(t){switch(arguments.length){case 1:var p=arguments[0];if(\"object\"===q(p))return(0,f[\"default\"])(p);throw new TypeError(\"Input has to be an object with r and phi keys.\");case 2:p=arguments[0];var g=arguments[1];if((0,k.isNumber)(p)){(0,k.isUnit)(g)&&g.hasBase(\"ANGLE\")&&(g=g.toNumber(\"rad\"));if((0,k.isNumber)(g))return new f[\"default\"]({r:p,phi:g});throw new TypeError(\"Phi is not a number nor an angle unit.\");\n}throw new TypeError(\"Radius r is not a number.\");default:throw new SyntaxError(\"Wrong number of arguments in function fromPolar\");}};f[\"default\"].prototype.valueOf=f[\"default\"].prototype.toString;f[\"default\"].fromJSON=function(t){return new f[\"default\"](t)};f[\"default\"].compare=function(t,p){return t.re>p.re?1:t.re<p.re?-1:t.im>p.im?1:t.im<p.im?-1:0};return f[\"default\"]},{isClass:!0});a.createComplexClass=c}","~:source","shadow$provide[31] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexClass = void 0;\n\nvar _complex = _interopRequireDefault(require(\"complex.js\"));\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar name = 'Complex';\nvar dependencies = [];\nvar createComplexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function () {\n  /**\n   * Attach type information\n   */\n  _complex[\"default\"].prototype.type = 'Complex';\n  _complex[\"default\"].prototype.isComplex = true;\n  /**\n   * Get a JSON representation of the complex number\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\n   */\n\n  _complex[\"default\"].prototype.toJSON = function () {\n    return {\n      mathjs: 'Complex',\n      re: this.re,\n      im: this.im\n    };\n  };\n  /*\n   * Return the value of the complex number in polar notation\n   * The angle phi will be set in the interval of [-pi, pi].\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\n   */\n\n\n  _complex[\"default\"].prototype.toPolar = function () {\n    return {\n      r: this.abs(),\n      phi: this.arg()\n    };\n  };\n  /**\n   * Get a string representation of the complex number,\n   * with optional formatting options.\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @return {string} str\n   */\n\n\n  _complex[\"default\"].prototype.format = function (options) {\n    var str = '';\n    var im = this.im;\n    var re = this.re;\n    var strRe = (0, _number.format)(this.re, options);\n    var strIm = (0, _number.format)(this.im, options); // round either re or im when smaller than the configured precision\n\n    var precision = (0, _is.isNumber)(options) ? options : options ? options.precision : null;\n\n    if (precision !== null) {\n      var epsilon = Math.pow(10, -precision);\n\n      if (Math.abs(re / im) < epsilon) {\n        re = 0;\n      }\n\n      if (Math.abs(im / re) < epsilon) {\n        im = 0;\n      }\n    }\n\n    if (im === 0) {\n      // real value\n      str = strRe;\n    } else if (re === 0) {\n      // purely complex value\n      if (im === 1) {\n        str = 'i';\n      } else if (im === -1) {\n        str = '-i';\n      } else {\n        str = strIm + 'i';\n      }\n    } else {\n      // complex value\n      if (im < 0) {\n        if (im === -1) {\n          str = strRe + ' - i';\n        } else {\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\n        }\n      } else {\n        if (im === 1) {\n          str = strRe + ' + i';\n        } else {\n          str = strRe + ' + ' + strIm + 'i';\n        }\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Create a complex number from polar coordinates\n   *\n   * Usage:\n   *\n   *     Complex.fromPolar(r: number, phi: number) : Complex\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\n   *\n   * @param {*} args...\n   * @return {Complex}\n   */\n\n\n  _complex[\"default\"].fromPolar = function (args) {\n    switch (arguments.length) {\n      case 1:\n        {\n          var arg = arguments[0];\n\n          if (_typeof(arg) === 'object') {\n            return (0, _complex[\"default\"])(arg);\n          } else {\n            throw new TypeError('Input has to be an object with r and phi keys.');\n          }\n        }\n\n      case 2:\n        {\n          var r = arguments[0];\n          var phi = arguments[1];\n\n          if ((0, _is.isNumber)(r)) {\n            if ((0, _is.isUnit)(phi) && phi.hasBase('ANGLE')) {\n              // convert unit to a number in radians\n              phi = phi.toNumber('rad');\n            }\n\n            if ((0, _is.isNumber)(phi)) {\n              return new _complex[\"default\"]({\n                r: r,\n                phi: phi\n              });\n            }\n\n            throw new TypeError('Phi is not a number nor an angle unit.');\n          } else {\n            throw new TypeError('Radius r is not a number.');\n          }\n        }\n\n      default:\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\n    }\n  };\n\n  _complex[\"default\"].prototype.valueOf = _complex[\"default\"].prototype.toString;\n  /**\n   * Create a Complex number from a JSON object\n   * @param {Object} json  A JSON Object structured as\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\n   *                       All properties are optional, default values\n   *                       for `re` and `im` are 0.\n   * @return {Complex} Returns a new Complex number\n   */\n\n  _complex[\"default\"].fromJSON = function (json) {\n    return new _complex[\"default\"](json);\n  };\n  /**\n   * Compare two complex numbers, `a` and `b`:\n   *\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\n   * - Returns 1 when the real parts are equal\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\n   * - Returns -1 when the real parts are equal\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\n   * - Returns 0 when both real and imaginary parts are equal.\n   *\n   * @params {Complex} a\n   * @params {Complex} b\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  _complex[\"default\"].compare = function (a, b) {\n    if (a.re > b.re) {\n      return 1;\n    }\n\n    if (a.re < b.re) {\n      return -1;\n    }\n\n    if (a.im > b.im) {\n      return 1;\n    }\n\n    if (a.im < b.im) {\n      return -1;\n    }\n\n    return 0;\n  };\n\n  return _complex[\"default\"];\n}, {\n  isClass: true\n});\nexports.createComplexClass = createComplexClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$complex_DOT_js$complex","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["compare","im","valueOf","fromJSON","isClass","__esModule","fromPolar","value","mathjs","type","r","isComplex","createComplexClass","re","toPolar","phi","format","toJSON"]],"~:compiled-at",1619135723739,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$complex$Complex.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/complex/Complex.js\"],\n\"sourcesContent\":[\"shadow$provide[31] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createComplexClass = void 0;\\n\\nvar _complex = _interopRequireDefault(require(\\\"complex.js\\\"));\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nvar name = 'Complex';\\nvar dependencies = [];\\nvar createComplexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function () {\\n  /**\\n   * Attach type information\\n   */\\n  _complex[\\\"default\\\"].prototype.type = 'Complex';\\n  _complex[\\\"default\\\"].prototype.isComplex = true;\\n  /**\\n   * Get a JSON representation of the complex number\\n   * @returns {Object} Returns a JSON object structured as:\\n   *                   `{\\\"mathjs\\\": \\\"Complex\\\", \\\"re\\\": 2, \\\"im\\\": 3}`\\n   */\\n\\n  _complex[\\\"default\\\"].prototype.toJSON = function () {\\n    return {\\n      mathjs: 'Complex',\\n      re: this.re,\\n      im: this.im\\n    };\\n  };\\n  /*\\n   * Return the value of the complex number in polar notation\\n   * The angle phi will be set in the interval of [-pi, pi].\\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\\n   */\\n\\n\\n  _complex[\\\"default\\\"].prototype.toPolar = function () {\\n    return {\\n      r: this.abs(),\\n      phi: this.arg()\\n    };\\n  };\\n  /**\\n   * Get a string representation of the complex number,\\n   * with optional formatting options.\\n   * @param {Object | number | Function} [options]  Formatting options. See\\n   *                                                lib/utils/number:format for a\\n   *                                                description of the available\\n   *                                                options.\\n   * @return {string} str\\n   */\\n\\n\\n  _complex[\\\"default\\\"].prototype.format = function (options) {\\n    var str = '';\\n    var im = this.im;\\n    var re = this.re;\\n    var strRe = (0, _number.format)(this.re, options);\\n    var strIm = (0, _number.format)(this.im, options); // round either re or im when smaller than the configured precision\\n\\n    var precision = (0, _is.isNumber)(options) ? options : options ? options.precision : null;\\n\\n    if (precision !== null) {\\n      var epsilon = Math.pow(10, -precision);\\n\\n      if (Math.abs(re / im) < epsilon) {\\n        re = 0;\\n      }\\n\\n      if (Math.abs(im / re) < epsilon) {\\n        im = 0;\\n      }\\n    }\\n\\n    if (im === 0) {\\n      // real value\\n      str = strRe;\\n    } else if (re === 0) {\\n      // purely complex value\\n      if (im === 1) {\\n        str = 'i';\\n      } else if (im === -1) {\\n        str = '-i';\\n      } else {\\n        str = strIm + 'i';\\n      }\\n    } else {\\n      // complex value\\n      if (im < 0) {\\n        if (im === -1) {\\n          str = strRe + ' - i';\\n        } else {\\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\\n        }\\n      } else {\\n        if (im === 1) {\\n          str = strRe + ' + i';\\n        } else {\\n          str = strRe + ' + ' + strIm + 'i';\\n        }\\n      }\\n    }\\n\\n    return str;\\n  };\\n  /**\\n   * Create a complex number from polar coordinates\\n   *\\n   * Usage:\\n   *\\n   *     Complex.fromPolar(r: number, phi: number) : Complex\\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\\n   *\\n   * @param {*} args...\\n   * @return {Complex}\\n   */\\n\\n\\n  _complex[\\\"default\\\"].fromPolar = function (args) {\\n    switch (arguments.length) {\\n      case 1:\\n        {\\n          var arg = arguments[0];\\n\\n          if (_typeof(arg) === 'object') {\\n            return (0, _complex[\\\"default\\\"])(arg);\\n          } else {\\n            throw new TypeError('Input has to be an object with r and phi keys.');\\n          }\\n        }\\n\\n      case 2:\\n        {\\n          var r = arguments[0];\\n          var phi = arguments[1];\\n\\n          if ((0, _is.isNumber)(r)) {\\n            if ((0, _is.isUnit)(phi) && phi.hasBase('ANGLE')) {\\n              // convert unit to a number in radians\\n              phi = phi.toNumber('rad');\\n            }\\n\\n            if ((0, _is.isNumber)(phi)) {\\n              return new _complex[\\\"default\\\"]({\\n                r: r,\\n                phi: phi\\n              });\\n            }\\n\\n            throw new TypeError('Phi is not a number nor an angle unit.');\\n          } else {\\n            throw new TypeError('Radius r is not a number.');\\n          }\\n        }\\n\\n      default:\\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\\n    }\\n  };\\n\\n  _complex[\\\"default\\\"].prototype.valueOf = _complex[\\\"default\\\"].prototype.toString;\\n  /**\\n   * Create a Complex number from a JSON object\\n   * @param {Object} json  A JSON Object structured as\\n   *                       {\\\"mathjs\\\": \\\"Complex\\\", \\\"re\\\": 2, \\\"im\\\": 3}\\n   *                       All properties are optional, default values\\n   *                       for `re` and `im` are 0.\\n   * @return {Complex} Returns a new Complex number\\n   */\\n\\n  _complex[\\\"default\\\"].fromJSON = function (json) {\\n    return new _complex[\\\"default\\\"](json);\\n  };\\n  /**\\n   * Compare two complex numbers, `a` and `b`:\\n   *\\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\\n   * - Returns 1 when the real parts are equal\\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\\n   * - Returns -1 when the real parts are equal\\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\\n   * - Returns 0 when both real and imaginary parts are equal.\\n   *\\n   * @params {Complex} a\\n   * @params {Complex} b\\n   * @returns {number} Returns the comparison result: -1, 0, or 1\\n   */\\n\\n\\n  _complex[\\\"default\\\"].compare = function (a, b) {\\n    if (a.re > b.re) {\\n      return 1;\\n    }\\n\\n    if (a.re < b.re) {\\n      return -1;\\n    }\\n\\n    if (a.im > b.im) {\\n      return 1;\\n    }\\n\\n    if (a.im < b.im) {\\n      return -1;\\n    }\\n\\n    return 0;\\n  };\\n\\n  return _complex[\\\"default\\\"];\\n}, {\\n  isClass: true\\n});\\nexports.createComplexClass = createComplexClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"Object\",\"defineProperty\",\"value\",\"createComplexClass\",\"_complex\",\"_interopRequireDefault\",\"__esModule\",\"_number\",\"_is\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"type\",\"isComplex\",\"toJSON\",\"mathjs\",\"re\",\"im\",\"toPolar\",\"r\",\"abs\",\"phi\",\"arg\",\"format\",\"options\",\"strRe\",\"strIm\",\"precision\",\"isNumber\",\"epsilon\",\"Math\",\"pow\",\"str\",\"substring\",\"fromPolar\",\"args\",\"arguments\",\"length\",\"TypeError\",\"isUnit\",\"hasBase\",\"toNumber\",\"SyntaxError\",\"valueOf\",\"toString\",\"fromJSON\",\"json\",\"compare\",\"a\",\"b\",\"isClass\"]\n}\n"]