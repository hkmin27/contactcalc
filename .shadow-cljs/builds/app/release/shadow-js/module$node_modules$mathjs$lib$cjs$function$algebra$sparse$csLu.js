["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csLu.js"],"~:js","shadow$provide[294]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createCsLu=void 0;c=b(25);var q=b(293);b=(0,c.factory)(\"csLu\",\"abs divideScalar multiply subtract larger largerEq SparseMatrix\".split(\" \"),function(f){var u=f.abs,k=f.divideScalar,t=f.multiply,p=f.subtract,g=f.larger,d=f.largerEq,l=f.SparseMatrix,h=(0,q.createCsSpsolve)({divideScalar:k,multiply:t,subtract:p});return function(n,r,v){if(!n)return null;var C=n._size[1],z;if(r)var w=r.q;var B=[],x=[],D=[],F=new l({values:B,\nindex:x,ptr:D,size:[C,C]}),E=[],G=[],I=[],L=new l({values:E,index:G,ptr:I,size:[C,C]}),M=[],S,P,R=[],ba=[];for(S=0;S<C;S++)R[S]=0,M[S]=-1,D[S+1]=0;for(var Q=z=r=0;Q<C;Q++){D[Q]=r;I[Q]=z;var T=w?w[Q]:Q,Y=h(F,n,T,ba,R,M,1),ca=-1,ka=-1;for(P=Y;P<C;P++)if(S=ba[P],0>M[S]){var ha=u(R[S]);g(ha,ka)&&(ka=ha,ca=S)}else G[z]=M[S],E[z++]=R[S];if(-1===ca||0>=ka)return null;0>M[T]&&d(u(R[T]),t(ka,v))&&(ca=T);T=R[ca];G[z]=Q;E[z++]=T;M[ca]=Q;x[r]=ca;B[r++]=1;for(P=Y;P<C;P++)S=ba[P],0>M[S]&&(x[r]=S,B[r++]=k(R[S],\nT)),R[S]=0}D[C]=r;I[C]=z;for(P=0;P<r;P++)x[P]=M[x[P]];B.splice(r,B.length-r);x.splice(r,x.length-r);E.splice(z,E.length-z);G.splice(z,G.length-z);return{L:F,U:L,pinv:M}}});a.createCsLu=b}","~:source","shadow$provide[294] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsLu = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csSpsolve = require(\"./csSpsolve.js\");\n\nvar name = 'csLu';\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createCsLu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var abs = _ref.abs,\n      divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSpsolve = (0, _csSpsolve.createCsSpsolve)({\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract\n  });\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    } // m arrays\n\n\n    var size = m._size; // columns\n\n    var n = size[1]; // symbolic analysis result\n\n    var q;\n    var lnz = 100;\n    var unz = 100; // update symbolic analysis parameters\n\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    } // L arrays\n\n\n    var lvalues = []; // (lnz)\n\n    var lindex = []; // (lnz)\n\n    var lptr = []; // (n + 1)\n    // L\n\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    }); // U arrays\n\n    var uvalues = []; // (unz)\n\n    var uindex = []; // (unz)\n\n    var uptr = []; // (n + 1)\n    // U\n\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    }); // inverse of permutation vector\n\n    var pinv = []; // (n)\n    // vars\n\n    var i, p; // allocate arrays\n\n    var x = []; // (n)\n\n    var xi = []; // (2 * n)\n    // initialize variables\n\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0; // no rows pivotal yet\n\n      pinv[i] = -1; // no cols of L yet\n\n      lptr[i + 1] = 0;\n    } // reset number of nonzero elements in L and U\n\n\n    lnz = 0;\n    unz = 0; // compute L(:,k) and U(:,k)\n\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz; // apply column permutations if needed\n\n      var col = q ? q[k] : k; // solve triangular system, x = L\\A(:,col)\n\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\n\n      var ipiv = -1;\n      var a = -1; // loop xi[] from top -> n\n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p]; // check row i is not yet pivotal\n\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\n\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      } // validate we found a valid pivot\n\n\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      } // update actual pivot column, give preference to diagonal value\n\n\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      } // the chosen pivot\n\n\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\n\n      uindex[unz] = k;\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\n\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\n\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\n\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p]; // check x(i) is an entry in L(:,k)\n\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i; // scale pivot column\n\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        } // x[0..n-1] = 0 for next k\n\n\n        x[i] = 0;\n      }\n    } // update ptr\n\n\n    lptr[n] = lnz;\n    uptr[n] = unz; // fix row indices of L for final pinv\n\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    } // trim arrays\n\n\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz); // return LU factor\n\n    return {\n      L: L,\n      U: U,\n      pinv: pinv\n    };\n  };\n});\nexports.createCsLu = createCsLu;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSpsolve","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["values","index","multiply","L","__esModule","value","subtract","createCsLu","U","pinv","size","ptr","divideScalar"]],"~:compiled-at",1619135723980,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csLu.js\"],\n\"sourcesContent\":[\"shadow$provide[294] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCsLu = void 0;\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar _csSpsolve = require(\\\"./csSpsolve.js\\\");\\n\\nvar name = 'csLu';\\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\\nvar createCsLu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var abs = _ref.abs,\\n      divideScalar = _ref.divideScalar,\\n      multiply = _ref.multiply,\\n      subtract = _ref.subtract,\\n      larger = _ref.larger,\\n      largerEq = _ref.largerEq,\\n      SparseMatrix = _ref.SparseMatrix;\\n  var csSpsolve = (0, _csSpsolve.createCsSpsolve)({\\n    divideScalar: divideScalar,\\n    multiply: multiply,\\n    subtract: subtract\\n  });\\n  /**\\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\\n   * L * U = A(p, q), where p is the inverse of pinv.\\n   *\\n   * @param {Matrix}  m               The A Matrix to factorize\\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\\n   *                                  column ordering q\\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\\n   *\\n   * @return {Number}                 The numeric LU factorization of A or null\\n   *\\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n   */\\n\\n  return function csLu(m, s, tol) {\\n    // validate input\\n    if (!m) {\\n      return null;\\n    } // m arrays\\n\\n\\n    var size = m._size; // columns\\n\\n    var n = size[1]; // symbolic analysis result\\n\\n    var q;\\n    var lnz = 100;\\n    var unz = 100; // update symbolic analysis parameters\\n\\n    if (s) {\\n      q = s.q;\\n      lnz = s.lnz || lnz;\\n      unz = s.unz || unz;\\n    } // L arrays\\n\\n\\n    var lvalues = []; // (lnz)\\n\\n    var lindex = []; // (lnz)\\n\\n    var lptr = []; // (n + 1)\\n    // L\\n\\n    var L = new SparseMatrix({\\n      values: lvalues,\\n      index: lindex,\\n      ptr: lptr,\\n      size: [n, n]\\n    }); // U arrays\\n\\n    var uvalues = []; // (unz)\\n\\n    var uindex = []; // (unz)\\n\\n    var uptr = []; // (n + 1)\\n    // U\\n\\n    var U = new SparseMatrix({\\n      values: uvalues,\\n      index: uindex,\\n      ptr: uptr,\\n      size: [n, n]\\n    }); // inverse of permutation vector\\n\\n    var pinv = []; // (n)\\n    // vars\\n\\n    var i, p; // allocate arrays\\n\\n    var x = []; // (n)\\n\\n    var xi = []; // (2 * n)\\n    // initialize variables\\n\\n    for (i = 0; i < n; i++) {\\n      // clear workspace\\n      x[i] = 0; // no rows pivotal yet\\n\\n      pinv[i] = -1; // no cols of L yet\\n\\n      lptr[i + 1] = 0;\\n    } // reset number of nonzero elements in L and U\\n\\n\\n    lnz = 0;\\n    unz = 0; // compute L(:,k) and U(:,k)\\n\\n    for (var k = 0; k < n; k++) {\\n      // update ptr\\n      lptr[k] = lnz;\\n      uptr[k] = unz; // apply column permutations if needed\\n\\n      var col = q ? q[k] : k; // solve triangular system, x = L\\\\A(:,col)\\n\\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\\n\\n      var ipiv = -1;\\n      var a = -1; // loop xi[] from top -> n\\n\\n      for (p = top; p < n; p++) {\\n        // x[i] is nonzero\\n        i = xi[p]; // check row i is not yet pivotal\\n\\n        if (pinv[i] < 0) {\\n          // absolute value of x[i]\\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\\n\\n          if (larger(xabs, a)) {\\n            // largest pivot candidate so far\\n            a = xabs;\\n            ipiv = i;\\n          }\\n        } else {\\n          // x(i) is the entry U(pinv[i],k)\\n          uindex[unz] = pinv[i];\\n          uvalues[unz++] = x[i];\\n        }\\n      } // validate we found a valid pivot\\n\\n\\n      if (ipiv === -1 || a <= 0) {\\n        return null;\\n      } // update actual pivot column, give preference to diagonal value\\n\\n\\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\\n        ipiv = col;\\n      } // the chosen pivot\\n\\n\\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\\n\\n      uindex[unz] = k;\\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\\n\\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\\n\\n      lindex[lnz] = ipiv;\\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\\n\\n      for (p = top; p < n; p++) {\\n        // row\\n        i = xi[p]; // check x(i) is an entry in L(:,k)\\n\\n        if (pinv[i] < 0) {\\n          // save unpermuted row in L\\n          lindex[lnz] = i; // scale pivot column\\n\\n          lvalues[lnz++] = divideScalar(x[i], pivot);\\n        } // x[0..n-1] = 0 for next k\\n\\n\\n        x[i] = 0;\\n      }\\n    } // update ptr\\n\\n\\n    lptr[n] = lnz;\\n    uptr[n] = unz; // fix row indices of L for final pinv\\n\\n    for (p = 0; p < lnz; p++) {\\n      lindex[p] = pinv[lindex[p]];\\n    } // trim arrays\\n\\n\\n    lvalues.splice(lnz, lvalues.length - lnz);\\n    lindex.splice(lnz, lindex.length - lnz);\\n    uvalues.splice(unz, uvalues.length - unz);\\n    uindex.splice(unz, uindex.length - unz); // return LU factor\\n\\n    return {\\n      L: L,\\n      U: U,\\n      pinv: pinv\\n    };\\n  };\\n});\\nexports.createCsLu = createCsLu;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCsLu\",\"_factory\",\"_csSpsolve\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"abs\",\"divideScalar\",\"multiply\",\"subtract\",\"larger\",\"largerEq\",\"SparseMatrix\",\"csSpsolve\",\"createCsSpsolve\",\"csLu\",\"m\",\"s\",\"tol\",\"n\",\"_size\",\"unz\",\"q\",\"lvalues\",\"lindex\",\"lptr\",\"L\",\"values\",\"index\",\"ptr\",\"size\",\"uvalues\",\"uindex\",\"uptr\",\"U\",\"pinv\",\"i\",\"p\",\"x\",\"xi\",\"k\",\"lnz\",\"col\",\"top\",\"ipiv\",\"a\",\"xabs\",\"pivot\",\"splice\",\"length\"]\n}\n"]