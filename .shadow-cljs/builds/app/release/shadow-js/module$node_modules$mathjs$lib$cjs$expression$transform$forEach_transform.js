["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/transform/forEach.transform.js"],"~:js","shadow$provide[578]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createForEachTransform=void 0;var q=b(14),f=b(127),u=b(24);c=b(25);var k=b(576);b=(0,c.factory)(\"forEach\",[\"typed\"],function(t){function p(d,l,h){var n,r;d[0]&&(n=d[0].compile().evaluate(h));d[1]&&(r=(0,q.isSymbolNode)(d[1])||(0,q.isFunctionAssignmentNode)(d[1])?d[1].compile().evaluate(h):(0,k.compileInlineExpression)(d[1],l,h));return g(n,r)}t=t.typed;p.rawArgs=!0;var g=t(\"forEach\",{\"Array | Matrix, function\":function(d,\nl){var h=(0,f.maxArgumentCount)(l);(function C(r,v){Array.isArray(r)?(0,u.forEach)(r,function(z,w){C(z,v.concat(w+1))}):1===h?l(r):2===h?l(r,v):l(r,v,d)})(d.valueOf(),[])}});return p},{isTransformFunction:!0});a.createForEachTransform=b}","~:source","shadow$provide[578] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createForEachTransform = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _function = require(\"../../utils/function.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _compileInlineExpression = require(\"./utils/compileInlineExpression.js\");\n\nvar name = 'forEach';\nvar dependencies = ['typed'];\nvar createForEachTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Attach a transform function to math.forEach\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  function forEachTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().evaluate(scope);\n    }\n\n    if (args[1]) {\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\n        // a function pointer, like forEach([3, -2, 5], myTestFunction)\n        callback = args[1].compile().evaluate(scope);\n      } else {\n        // an expression like forEach([3, -2, 5], x > 0 ? callback1(x) : callback2(x) )\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\n      }\n    }\n\n    return _forEach(x, callback);\n  }\n\n  forEachTransform.rawArgs = true; // one-based version of forEach\n\n  var _forEach = typed('forEach', {\n    'Array | Matrix, function': function ArrayMatrixFunction(array, callback) {\n      // figure out what number of arguments the callback function expects\n      var args = (0, _function.maxArgumentCount)(callback);\n\n      var recurse = function recurse(value, index) {\n        if (Array.isArray(value)) {\n          (0, _array.forEach)(value, function (child, i) {\n            // we create a copy of the index array and append the new index value\n            recurse(child, index.concat(i + 1)); // one based index, hence i+1\n          });\n        } else {\n          // invoke the callback function with the right number of arguments\n          if (args === 1) {\n            callback(value);\n          } else if (args === 2) {\n            callback(value, index);\n          } else {\n            // 3 or -1\n            callback(value, index, array);\n          }\n        }\n      };\n\n      recurse(array.valueOf(), []); // pass Array\n    }\n  });\n\n  return forEachTransform;\n}, {\n  isTransformFunction: true\n});\nexports.createForEachTransform = createForEachTransform;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory","~$module$node_modules$mathjs$lib$cjs$expression$transform$utils$compileInlineExpression","~$module$node_modules$mathjs$lib$cjs$utils$function"]],"~:properties",["^5",["rawArgs","__esModule","isTransformFunction","value","createForEachTransform"]],"~:compiled-at",1619135724042,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$transform$forEach_transform.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,sBAAR,CAAiC,IAAK,EAEtC,KAAIC,EAAMP,CAAA,CAAQ,EAAR,CAAV,CAEIQ,EAAYR,CAAA,CAAQ,GAAR,CAFhB,CAIIS,EAAST,CAAA,CAAQ,EAAR,CAETU,EAAAA,CAAWV,CAAA,CAAQ,EAAR,CAEf,KAAIW,EAA2BX,CAAA,CAAQ,GAAR,CAI3BM,EAAAA,CAAwC,CAAC,CAAA,CAAGI,CAASE,CAAAA,OAAb,EAFjCC,SAEiC,CADzBC,CAAC,OAADA,CACyB,CAA0C,QAAS,CAACC,CAAD,CAAO,CASpGC,QAASA,EAAgB,CAACC,CAAD,CAAOC,CAAP,CAAaC,CAAb,CAAoB,CAAA,IACvCC,CADuC,CACpCC,CAEHJ,EAAA,CAAK,CAAL,CAAJ,GACEG,CADF,CACMH,CAAA,CAAK,CAAL,CAAQK,CAAAA,OAAR,EAAkBC,CAAAA,QAAlB,CAA2BJ,CAA3B,CADN,CAIIF,EAAA,CAAK,CAAL,CAAJ,GAGII,CAHJ,CACM,CAAC,CAAA,CAAGd,CAAIiB,CAAAA,YAAR,EAAsBP,CAAA,CAAK,CAAL,CAAtB,CAAJ,EAAsC,CAAC,CAAA,CAAGV,CAAIkB,CAAAA,wBAAR,EAAkCR,CAAA,CAAK,CAAL,CAAlC,CAAtC,CAEaA,CAAA,CAAK,CAAL,CAAQK,CAAAA,OAAR,EAAkBC,CAAAA,QAAlB,CAA2BJ,CAA3B,CAFb,CAKa,CAAC,CAAA,CAAGR,CAAyBe,CAAAA,uBAA7B,EAAsDT,CAAA,CAAK,CAAL,CAAtD,CAA+DC,CAA/D,CAAqEC,CAArE,CANf,CAUA,OAAOQ,EAAA,CAASP,CAAT,CAAYC,CAAZ,CAjBoC,CARzCO,CAAAA,CAAQb,CAAKa,CAAAA,KA4BjBZ,EAAiBa,CAAAA,OAAjB,CAA2B,CAAA,CAE3B,KAAIF,EAAWC,CAAA,CAAM,SAAN,CAAiB,CAC9B,2BAA4BE,QAA4B,CAACC,CAAD;AAAQV,CAAR,CAAkB,CAExE,IAAIJ,EAAO,CAAC,CAAA,CAAGT,CAAUwB,CAAAA,gBAAd,EAAgCX,CAAhC,CAEGY,UAASA,EAAO,CAAC5B,CAAD,CAAQ6B,CAAR,CAAe,CACvCC,KAAMC,CAAAA,OAAN,CAAc/B,CAAd,CAAJ,CACE,CAAC,CAAA,CAAGI,CAAO4B,CAAAA,OAAX,EAAoBhC,CAApB,CAA2B,QAAS,CAACiC,CAAD,CAAQC,CAAR,CAAW,CAE7CN,CAAA,CAAQK,CAAR,CAAeJ,CAAMM,CAAAA,MAAN,CAAaD,CAAb,CAAiB,CAAjB,CAAf,CAF6C,CAA/C,CADF,CAOe,CAAb,GAAItB,CAAJ,CACEI,CAAA,CAAShB,CAAT,CADF,CAEoB,CAAb,GAAIY,CAAJ,CACLI,CAAA,CAAShB,CAAT,CAAgB6B,CAAhB,CADK,CAILb,CAAA,CAAShB,CAAT,CAAgB6B,CAAhB,CAAuBH,CAAvB,CAduC,CAA/BE,CAmBd,CAAQF,CAAMU,CAAAA,OAAN,EAAR,CAAyB,EAAzB,CAvBwE,CAD5C,CAAjB,CA4Bf,OAAOzB,EA3D6F,CAA1D,CA4DzC,CACD0B,oBAAqB,CAAA,CADpB,CA5DyC,CA+D5CxC,EAAQI,CAAAA,sBAAR,CAAiCA,CAnF6B;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/transform/forEach.transform.js\"],\n\"sourcesContent\":[\"shadow$provide[578] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createForEachTransform = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _function = require(\\\"../../utils/function.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _compileInlineExpression = require(\\\"./utils/compileInlineExpression.js\\\");\\n\\nvar name = 'forEach';\\nvar dependencies = ['typed'];\\nvar createForEachTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed;\\n\\n  /**\\n   * Attach a transform function to math.forEach\\n   * Adds a property transform containing the transform function.\\n   *\\n   * This transform creates a one-based index instead of a zero-based index\\n   */\\n  function forEachTransform(args, math, scope) {\\n    var x, callback;\\n\\n    if (args[0]) {\\n      x = args[0].compile().evaluate(scope);\\n    }\\n\\n    if (args[1]) {\\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\\n        // a function pointer, like forEach([3, -2, 5], myTestFunction)\\n        callback = args[1].compile().evaluate(scope);\\n      } else {\\n        // an expression like forEach([3, -2, 5], x > 0 ? callback1(x) : callback2(x) )\\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\\n      }\\n    }\\n\\n    return _forEach(x, callback);\\n  }\\n\\n  forEachTransform.rawArgs = true; // one-based version of forEach\\n\\n  var _forEach = typed('forEach', {\\n    'Array | Matrix, function': function ArrayMatrixFunction(array, callback) {\\n      // figure out what number of arguments the callback function expects\\n      var args = (0, _function.maxArgumentCount)(callback);\\n\\n      var recurse = function recurse(value, index) {\\n        if (Array.isArray(value)) {\\n          (0, _array.forEach)(value, function (child, i) {\\n            // we create a copy of the index array and append the new index value\\n            recurse(child, index.concat(i + 1)); // one based index, hence i+1\\n          });\\n        } else {\\n          // invoke the callback function with the right number of arguments\\n          if (args === 1) {\\n            callback(value);\\n          } else if (args === 2) {\\n            callback(value, index);\\n          } else {\\n            // 3 or -1\\n            callback(value, index, array);\\n          }\\n        }\\n      };\\n\\n      recurse(array.valueOf(), []); // pass Array\\n    }\\n  });\\n\\n  return forEachTransform;\\n}, {\\n  isTransformFunction: true\\n});\\nexports.createForEachTransform = createForEachTransform;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createForEachTransform\",\"_is\",\"_function\",\"_array\",\"_factory\",\"_compileInlineExpression\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"forEachTransform\",\"args\",\"math\",\"scope\",\"x\",\"callback\",\"compile\",\"evaluate\",\"isSymbolNode\",\"isFunctionAssignmentNode\",\"compileInlineExpression\",\"_forEach\",\"typed\",\"rawArgs\",\"ArrayMatrixFunction\",\"array\",\"maxArgumentCount\",\"recurse\",\"index\",\"Array\",\"isArray\",\"forEach\",\"child\",\"i\",\"concat\",\"valueOf\",\"isTransformFunction\"]\n}\n"]