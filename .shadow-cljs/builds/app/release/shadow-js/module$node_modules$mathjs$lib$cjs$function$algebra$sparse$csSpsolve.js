["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csSpsolve.js"],"~:js","shadow$provide[293]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createCsSpsolve=void 0;var q=b(292);c=b(25);c=(0,c.factory)(\"csSpsolve\",[\"divideScalar\",\"multiply\",\"subtract\"],function(f){var u=f.divideScalar,k=f.multiply,t=f.subtract;return function(p,g,d,l,h,n,r){var v=p._values,C=p._index,z=p._ptr,w=p._size[1],B=g._values,x=g._index,D=g._ptr;for(g=p=(0,q.csReach)(p,g,d,l,n);g<w;g++)h[l[g]]=0;g=D[d];for(d=D[d+1];g<d;g++)h[x[g]]=B[g];for(B=p;B<w;B++)if(x=l[B],d=n?n[x]:x,!(0>\nd))for(g=z[d],d=z[d+1],h[x]=u(h[x],v[r?g:d-1]),g=r?g+1:g,d=r?d:d-1;g<d;g++)D=C[g],h[D]=t(h[D],k(v[g],h[x]));return p}});a.createCsSpsolve=c}","~:source","shadow$provide[293] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSpsolve = void 0;\n\nvar _csReach = require(\"./csReach.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nvar createCsSpsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract;\n\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = (0, _csReach.csReach)(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});\nexports.createCsSpsolve = createCsSpsolve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csReach","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","createCsSpsolve","value"]],"~:compiled-at",1619135723980,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSpsolve.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csSpsolve.js\"],\n\"sourcesContent\":[\"shadow$provide[293] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCsSpsolve = void 0;\\n\\nvar _csReach = require(\\\"./csReach.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar name = 'csSpsolve';\\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\\nvar createCsSpsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var divideScalar = _ref.divideScalar,\\n      multiply = _ref.multiply,\\n      subtract = _ref.subtract;\\n\\n  /**\\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\\n   * is upper triangular with the diagonal entry as the last entry in each column.\\n   *\\n   * @param {Matrix}  g               The G matrix\\n   * @param {Matrix}  b               The B matrix\\n   * @param {Number}  k               The kth column in B\\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\\n   * @param {Array}   x               The soluton to the linear system G * x = b\\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\\n   *\\n   * @return {Number}                 The index for the nonzero pattern\\n   *\\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n   */\\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\\n    // g arrays\\n    var gvalues = g._values;\\n    var gindex = g._index;\\n    var gptr = g._ptr;\\n    var gsize = g._size; // columns\\n\\n    var n = gsize[1]; // b arrays\\n\\n    var bvalues = b._values;\\n    var bindex = b._index;\\n    var bptr = b._ptr; // vars\\n\\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\\n\\n    var top = (0, _csReach.csReach)(g, b, k, xi, pinv); // clear x\\n\\n    for (p = top; p < n; p++) {\\n      x[xi[p]] = 0;\\n    } // scatter b\\n\\n\\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\\n      x[bindex[p]] = bvalues[p];\\n    } // loop columns\\n\\n\\n    for (var px = top; px < n; px++) {\\n      // x array index for px\\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\\n\\n      var J = pinv ? pinv[j] : j; // check column J is empty\\n\\n      if (J < 0) {\\n        continue;\\n      } // column value indeces in G, p0 <= p < p1\\n\\n\\n      p0 = gptr[J];\\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\\n\\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\\n\\n      p = lo ? p0 + 1 : p0;\\n      q = lo ? p1 : p1 - 1; // loop\\n\\n      for (; p < q; p++) {\\n        // row\\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\\n\\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\\n      }\\n    } // return top of stack\\n\\n\\n    return top;\\n  };\\n});\\nexports.createCsSpsolve = createCsSpsolve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCsSpsolve\",\"_csReach\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"divideScalar\",\"multiply\",\"subtract\",\"csSpsolve\",\"g\",\"b\",\"k\",\"xi\",\"x\",\"pinv\",\"lo\",\"gvalues\",\"_values\",\"gindex\",\"_index\",\"gptr\",\"_ptr\",\"n\",\"_size\",\"bvalues\",\"bindex\",\"bptr\",\"p\",\"top\",\"csReach\",\"p0\",\"p1\",\"px\",\"j\",\"J\",\"q\",\"i\"]\n}\n"]