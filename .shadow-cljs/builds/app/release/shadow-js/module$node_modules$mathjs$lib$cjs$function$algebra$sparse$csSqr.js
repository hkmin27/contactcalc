["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js"],"~:js","shadow$provide[287]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createCsSqr=void 0;var q=b(278),f=b(280),u=b(281),k=b(284),t=b(286);c=b(25);c=(0,c.factory)(\"csSqr\",[\"add\",\"multiply\",\"transpose\"],function(p){var g=p.add,d=p.multiply;p=p.transpose;var l=(0,k.createCsAmd)({add:g,multiply:d,transpose:p}),h=(0,t.createCsCounts)({transpose:p});return function(n,r,v){var C=r._ptr,z=r._size[1],w={};w.q=l(n,r);if(n&&!w.q)return null;if(v){v=n?(0,q.csPermute)(r,null,w.q,0):r;w.parent=\n(0,u.csEtree)(v,1);n=(0,f.csPost)(w.parent,z);w.cp=h(v,w.parent,n,1);if(n=v&&w.parent&&w.cp){n=v._ptr;r=v._index;C=v._size;v=C[0];C=C[1];w.pinv=[];w.leftmost=[];var B=w.parent,x=w.pinv,D=w.leftmost,F=[],E=v+C,G=v+2*C,I,L;for(L=0;L<C;L++)F[v+L]=-1,F[E+L]=-1,F[G+L]=0;for(I=0;I<v;I++)D[I]=-1;for(L=C-1;0<=L;L--){var M=n[L];for(I=n[L+1];M<I;M++)D[r[M]]=L}for(I=v-1;0<=I;I--)x[I]=-1,L=D[I],-1!==L&&(0===F[G+L]++&&(F[E+L]=I),F[0+I]=F[v+L],F[v+L]=I);w.lnz=0;w.m2=v;for(L=0;L<C;L++)I=F[v+L],w.lnz++,0>I&&(I=w.m2++),\nx[I]=L,0>=--G[L]||(w.lnz+=F[G+L],n=B[L],-1!==n&&(0===F[G+n]&&(F[E+n]=F[E+L]),F[0+F[E+L]]=F[v+n],F[v+n]=F[0+I],F[G+n]+=F[G+L]));for(I=0;I<v;I++)0>x[I]&&(x[I]=L++);n=!0}if(n)for(n=w.unz=0;n<z;n++)w.unz+=w.cp[n]}else w.unz=4*C[z]+z,w.lnz=w.unz;return w}});a.createCsSqr=c}","~:source","shadow$provide[287] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSqr = void 0;\n\nvar _csPermute = require(\"./csPermute.js\");\n\nvar _csPost = require(\"./csPost.js\");\n\nvar _csEtree = require(\"./csEtree.js\");\n\nvar _csAmd = require(\"./csAmd.js\");\n\nvar _csCounts = require(\"./csCounts.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose;\n  var csAmd = (0, _csAmd.createCsAmd)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = (0, _csCounts.createCsCounts)({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\n\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});\nexports.createCsSqr = createCsSqr;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPost","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csEtree","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csAmd","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPermute","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["leftmost","multiply","cp","q","parent","__esModule","lnz","value","unz","pinv","m2","createCsSqr","add","transpose"]],"~:compiled-at",1619135723978,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js\"],\n\"sourcesContent\":[\"shadow$provide[287] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCsSqr = void 0;\\n\\nvar _csPermute = require(\\\"./csPermute.js\\\");\\n\\nvar _csPost = require(\\\"./csPost.js\\\");\\n\\nvar _csEtree = require(\\\"./csEtree.js\\\");\\n\\nvar _csAmd = require(\\\"./csAmd.js\\\");\\n\\nvar _csCounts = require(\\\"./csCounts.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar name = 'csSqr';\\nvar dependencies = ['add', 'multiply', 'transpose'];\\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var add = _ref.add,\\n      multiply = _ref.multiply,\\n      transpose = _ref.transpose;\\n  var csAmd = (0, _csAmd.createCsAmd)({\\n    add: add,\\n    multiply: multiply,\\n    transpose: transpose\\n  });\\n  var csCounts = (0, _csCounts.createCsCounts)({\\n    transpose: transpose\\n  });\\n  /**\\n   * Symbolic ordering and analysis for QR and LU decompositions.\\n   *\\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\\n   * @param {Matrix}  a               The A matrix\\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\\n   *                                  symbolic ordering and analysis for LU decomposition (false)\\n   *\\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\\n   *\\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n   */\\n\\n  return function csSqr(order, a, qr) {\\n    // a arrays\\n    var aptr = a._ptr;\\n    var asize = a._size; // columns\\n\\n    var n = asize[1]; // vars\\n\\n    var k; // symbolic analysis result\\n\\n    var s = {}; // fill-reducing ordering\\n\\n    s.q = csAmd(order, a); // validate results\\n\\n    if (order && !s.q) {\\n      return null;\\n    } // QR symbolic analysis\\n\\n\\n    if (qr) {\\n      // apply permutations if needed\\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\\n\\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\\n\\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\\n\\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\\n\\n      if (c && s.parent && s.cp && _vcount(c, s)) {\\n        // calculate number of nonzero elements\\n        for (s.unz = 0, k = 0; k < n; k++) {\\n          s.unz += s.cp[k];\\n        }\\n      }\\n    } else {\\n      // for LU factorization only, guess nnz(L) and nnz(U)\\n      s.unz = 4 * aptr[n] + n;\\n      s.lnz = s.unz;\\n    } // return result S\\n\\n\\n    return s;\\n  };\\n  /**\\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\\n   */\\n\\n  function _vcount(a, s) {\\n    // a arrays\\n    var aptr = a._ptr;\\n    var aindex = a._index;\\n    var asize = a._size; // rows & columns\\n\\n    var m = asize[0];\\n    var n = asize[1]; // initialize s arrays\\n\\n    s.pinv = []; // (m + n)\\n\\n    s.leftmost = []; // (m)\\n    // vars\\n\\n    var parent = s.parent;\\n    var pinv = s.pinv;\\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\\n\\n    var w = []; // (m + 3 * n)\\n\\n    var next = 0;\\n    var head = m;\\n    var tail = m + n;\\n    var nque = m + 2 * n; // vars\\n\\n    var i, k, p, p0, p1; // initialize w\\n\\n    for (k = 0; k < n; k++) {\\n      // queue k is empty\\n      w[head + k] = -1;\\n      w[tail + k] = -1;\\n      w[nque + k] = 0;\\n    } // initialize row arrays\\n\\n\\n    for (i = 0; i < m; i++) {\\n      leftmost[i] = -1;\\n    } // loop columns backwards\\n\\n\\n    for (k = n - 1; k >= 0; k--) {\\n      // values & index for column k\\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\\n        // leftmost[i] = min(find(A(i,:)))\\n        leftmost[aindex[p]] = k;\\n      }\\n    } // scan rows in reverse order\\n\\n\\n    for (i = m - 1; i >= 0; i--) {\\n      // row i is not yet ordered\\n      pinv[i] = -1;\\n      k = leftmost[i]; // check row i is empty\\n\\n      if (k === -1) {\\n        continue;\\n      } // first row in queue k\\n\\n\\n      if (w[nque + k]++ === 0) {\\n        w[tail + k] = i;\\n      } // put i at head of queue k\\n\\n\\n      w[next + i] = w[head + k];\\n      w[head + k] = i;\\n    }\\n\\n    s.lnz = 0;\\n    s.m2 = m; // find row permutation and nnz(V)\\n\\n    for (k = 0; k < n; k++) {\\n      // remove row i from queue k\\n      i = w[head + k]; // count V(k,k) as nonzero\\n\\n      s.lnz++; // add a fictitious row\\n\\n      if (i < 0) {\\n        i = s.m2++;\\n      } // associate row i with V(:,k)\\n\\n\\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\\n\\n      if (--nque[k] <= 0) {\\n        continue;\\n      } // nque[k] is nnz (V(k+1:m,k))\\n\\n\\n      s.lnz += w[nque + k]; // move all rows to parent of k\\n\\n      var pa = parent[k];\\n\\n      if (pa !== -1) {\\n        if (w[nque + pa] === 0) {\\n          w[tail + pa] = w[tail + k];\\n        }\\n\\n        w[next + w[tail + k]] = w[head + pa];\\n        w[head + pa] = w[next + i];\\n        w[nque + pa] += w[nque + k];\\n      }\\n    }\\n\\n    for (i = 0; i < m; i++) {\\n      if (pinv[i] < 0) {\\n        pinv[i] = k++;\\n      }\\n    }\\n\\n    return true;\\n  }\\n});\\nexports.createCsSqr = createCsSqr;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCsSqr\",\"_csPermute\",\"_csPost\",\"_csEtree\",\"_csAmd\",\"_csCounts\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"add\",\"multiply\",\"transpose\",\"csAmd\",\"createCsAmd\",\"csCounts\",\"createCsCounts\",\"csSqr\",\"order\",\"a\",\"qr\",\"aptr\",\"_ptr\",\"n\",\"_size\",\"s\",\"q\",\"c\",\"csPermute\",\"parent\",\"csEtree\",\"post\",\"csPost\",\"cp\",\"aindex\",\"_index\",\"asize\",\"m\",\"pinv\",\"leftmost\",\"w\",\"tail\",\"nque\",\"i\",\"k\",\"p0\",\"p1\",\"p\",\"next\",\"lnz\",\"m2\",\"pa\",\"unz\"]\n}\n"]