["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/core/function/typed.js"],"~:js","shadow$provide[26]=function(c,b,y,a){function q(d){throw Error(\"Cannot convert value \".concat(d,\" into a BigNumber: no class 'BigNumber' provided\"));}function f(d){throw Error(\"Cannot convert value \".concat(d,\" into a Complex number: no class 'Complex' provided\"));}function u(d){throw Error(\"Cannot convert value \".concat(d,\" into a Fraction, no class 'Fraction' provided.\"));}Object.defineProperty(a,\"__esModule\",{value:!0});a.createTyped=void 0;var k=b(14),t=function(d){return d&&d.__esModule?d:{\"default\":d}}(b(18)),\np=b(19);c=b(25);var g=function(){g=t[\"default\"].create;return t[\"default\"]};c=(0,c.factory)(\"typed\",[\"?BigNumber\",\"?Complex\",\"?DenseMatrix\",\"?Fraction\"],function(d){var l=d.BigNumber,h=d.Complex,n=d.DenseMatrix,r=d.Fraction;d=g();d.types=[{name:\"number\",test:k.isNumber},{name:\"Complex\",test:k.isComplex},{name:\"BigNumber\",test:k.isBigNumber},{name:\"Fraction\",test:k.isFraction},{name:\"Unit\",test:k.isUnit},{name:\"string\",test:k.isString},{name:\"Chain\",test:k.isChain},{name:\"Array\",test:k.isArray},{name:\"Matrix\",\ntest:k.isMatrix},{name:\"DenseMatrix\",test:k.isDenseMatrix},{name:\"SparseMatrix\",test:k.isSparseMatrix},{name:\"Range\",test:k.isRange},{name:\"Index\",test:k.isIndex},{name:\"boolean\",test:k.isBoolean},{name:\"ResultSet\",test:k.isResultSet},{name:\"Help\",test:k.isHelp},{name:\"function\",test:k.isFunction},{name:\"Date\",test:k.isDate},{name:\"RegExp\",test:k.isRegExp},{name:\"null\",test:k.isNull},{name:\"undefined\",test:k.isUndefined},{name:\"AccessorNode\",test:k.isAccessorNode},{name:\"ArrayNode\",test:k.isArrayNode},\n{name:\"AssignmentNode\",test:k.isAssignmentNode},{name:\"BlockNode\",test:k.isBlockNode},{name:\"ConditionalNode\",test:k.isConditionalNode},{name:\"ConstantNode\",test:k.isConstantNode},{name:\"FunctionNode\",test:k.isFunctionNode},{name:\"FunctionAssignmentNode\",test:k.isFunctionAssignmentNode},{name:\"IndexNode\",test:k.isIndexNode},{name:\"Node\",test:k.isNode},{name:\"ObjectNode\",test:k.isObjectNode},{name:\"OperatorNode\",test:k.isOperatorNode},{name:\"ParenthesisNode\",test:k.isParenthesisNode},{name:\"RangeNode\",\ntest:k.isRangeNode},{name:\"SymbolNode\",test:k.isSymbolNode},{name:\"Object\",test:k.isObject}];d.conversions=[{from:\"number\",to:\"BigNumber\",convert:function(v){l||q(v);if(15<(0,p.digits)(v))throw new TypeError(\"Cannot implicitly convert a number with \\x3e15 significant digits to BigNumber (value: \"+v+\"). Use function bignumber(x) to convert to BigNumber.\");return new l(v)}},{from:\"number\",to:\"Complex\",convert:function(v){h||f(v);return new h(v,0)}},{from:\"number\",to:\"string\",convert:function(v){return v+\n\"\"}},{from:\"BigNumber\",to:\"Complex\",convert:function(v){h||f(v);return new h(v.toNumber(),0)}},{from:\"Fraction\",to:\"BigNumber\",convert:function(v){throw new TypeError(\"Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.\");}},{from:\"Fraction\",to:\"Complex\",convert:function(v){h||f(v);return new h(v.valueOf(),0)}},{from:\"number\",to:\"Fraction\",convert:function(v){r||u(v);var C=new r(v);if(C.valueOf()!==\nv)throw new TypeError(\"Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: \"+v+\"). Use function fraction(x) to convert to Fraction.\");return C}},{from:\"string\",to:\"number\",convert:function(v){var C=Number(v);if(isNaN(C))throw Error('Cannot convert \"'+v+'\" to a number');return C}},{from:\"string\",to:\"BigNumber\",convert:function(v){l||q(v);try{return new l(v)}catch(C){throw Error('Cannot convert \"'+v+'\" to BigNumber');}}},{from:\"string\",to:\"Fraction\",convert:function(v){r||\nu(v);try{return new r(v)}catch(C){throw Error('Cannot convert \"'+v+'\" to Fraction');}}},{from:\"string\",to:\"Complex\",convert:function(v){h||f(v);try{return new h(v)}catch(C){throw Error('Cannot convert \"'+v+'\" to Complex');}}},{from:\"boolean\",to:\"number\",convert:function(v){return+v}},{from:\"boolean\",to:\"BigNumber\",convert:function(v){l||q(v);return new l(+v)}},{from:\"boolean\",to:\"Fraction\",convert:function(v){r||u(v);return new r(+v)}},{from:\"boolean\",to:\"string\",convert:function(v){return String(v)}},\n{from:\"Array\",to:\"Matrix\",convert:function(v){if(!n)throw Error(\"Cannot convert array into a Matrix: no class 'DenseMatrix' provided\");return new n(v)}},{from:\"Matrix\",to:\"Array\",convert:function(v){return v.valueOf()}}];return d});a.createTyped=c}","~:source","shadow$provide[26] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTyped = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _typedFunction = _interopRequireDefault(require(\"typed-function\"));\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\n// returns a new instance of typed-function\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = _typedFunction[\"default\"].create;\n  return _typedFunction[\"default\"];\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nvar createTyped = /* #__PURE__ */(0, _factory.factory)('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: _is.isNumber\n  }, {\n    name: 'Complex',\n    test: _is.isComplex\n  }, {\n    name: 'BigNumber',\n    test: _is.isBigNumber\n  }, {\n    name: 'Fraction',\n    test: _is.isFraction\n  }, {\n    name: 'Unit',\n    test: _is.isUnit\n  }, {\n    name: 'string',\n    test: _is.isString\n  }, {\n    name: 'Chain',\n    test: _is.isChain\n  }, {\n    name: 'Array',\n    test: _is.isArray\n  }, {\n    name: 'Matrix',\n    test: _is.isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: _is.isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: _is.isSparseMatrix\n  }, {\n    name: 'Range',\n    test: _is.isRange\n  }, {\n    name: 'Index',\n    test: _is.isIndex\n  }, {\n    name: 'boolean',\n    test: _is.isBoolean\n  }, {\n    name: 'ResultSet',\n    test: _is.isResultSet\n  }, {\n    name: 'Help',\n    test: _is.isHelp\n  }, {\n    name: 'function',\n    test: _is.isFunction\n  }, {\n    name: 'Date',\n    test: _is.isDate\n  }, {\n    name: 'RegExp',\n    test: _is.isRegExp\n  }, {\n    name: 'null',\n    test: _is.isNull\n  }, {\n    name: 'undefined',\n    test: _is.isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: _is.isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: _is.isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: _is.isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: _is.isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: _is.isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: _is.isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: _is.isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: _is.isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: _is.isIndexNode\n  }, {\n    name: 'Node',\n    test: _is.isNode\n  }, {\n    name: 'ObjectNode',\n    test: _is.isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: _is.isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: _is.isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: _is.isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: _is.isSymbolNode\n  }, {\n    name: 'Object',\n    test: _is.isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if ((0, _number.digits)(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\nexports.createTyped = createTyped;\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$typed_function$typed_function","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createTyped","__esModule","convert","conversions","types","name","value","from","to","test"]],"~:compiled-at",1619135723716,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$core$function$typed.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/core/function/typed.js\"],\n\"sourcesContent\":[\"shadow$provide[26] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createTyped = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _typedFunction = _interopRequireDefault(require(\\\"typed-function\\\"));\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\n/**\\n * Create a typed-function which checks the types of the arguments and\\n * can match them against multiple provided signatures. The typed-function\\n * automatically converts inputs in order to find a matching signature.\\n * Typed functions throw informative errors in case of wrong input arguments.\\n *\\n * See the library [typed-function](https://github.com/josdejong/typed-function)\\n * for detailed documentation.\\n *\\n * Syntax:\\n *\\n *     math.typed(name, signatures) : function\\n *     math.typed(signatures) : function\\n *\\n * Examples:\\n *\\n *     // create a typed function with multiple types per argument (type union)\\n *     const fn2 = typed({\\n *       'number | boolean': function (b) {\\n *         return 'b is a number or boolean'\\n *       },\\n *       'string, number | boolean': function (a, b) {\\n *         return 'a is a string, b is a number or boolean'\\n *       }\\n *     })\\n *\\n *     // create a typed function with an any type argument\\n *     const log = typed({\\n *       'string, any': function (event, data) {\\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\\n *       }\\n *     })\\n *\\n * @param {string} [name]                          Optional name for the typed-function\\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\\n * @returns {function} The created typed-function.\\n */\\n// returns a new instance of typed-function\\nvar _createTyped2 = function _createTyped() {\\n  // initially, return the original instance of typed-function\\n  // consecutively, return a new instance from typed.create.\\n  _createTyped2 = _typedFunction[\\\"default\\\"].create;\\n  return _typedFunction[\\\"default\\\"];\\n};\\n\\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\\n/**\\n * Factory function for creating a new typed instance\\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\\n * @returns {Function}\\n */\\n\\nvar createTyped = /* #__PURE__ */(0, _factory.factory)('typed', dependencies, function createTyped(_ref) {\\n  var BigNumber = _ref.BigNumber,\\n      Complex = _ref.Complex,\\n      DenseMatrix = _ref.DenseMatrix,\\n      Fraction = _ref.Fraction;\\n\\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\\n  // get a new instance of typed-function\\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\\n  // arguments are type-checked (so for performance it's important to put the\\n  // most used types first).\\n\\n\\n  typed.types = [{\\n    name: 'number',\\n    test: _is.isNumber\\n  }, {\\n    name: 'Complex',\\n    test: _is.isComplex\\n  }, {\\n    name: 'BigNumber',\\n    test: _is.isBigNumber\\n  }, {\\n    name: 'Fraction',\\n    test: _is.isFraction\\n  }, {\\n    name: 'Unit',\\n    test: _is.isUnit\\n  }, {\\n    name: 'string',\\n    test: _is.isString\\n  }, {\\n    name: 'Chain',\\n    test: _is.isChain\\n  }, {\\n    name: 'Array',\\n    test: _is.isArray\\n  }, {\\n    name: 'Matrix',\\n    test: _is.isMatrix\\n  }, {\\n    name: 'DenseMatrix',\\n    test: _is.isDenseMatrix\\n  }, {\\n    name: 'SparseMatrix',\\n    test: _is.isSparseMatrix\\n  }, {\\n    name: 'Range',\\n    test: _is.isRange\\n  }, {\\n    name: 'Index',\\n    test: _is.isIndex\\n  }, {\\n    name: 'boolean',\\n    test: _is.isBoolean\\n  }, {\\n    name: 'ResultSet',\\n    test: _is.isResultSet\\n  }, {\\n    name: 'Help',\\n    test: _is.isHelp\\n  }, {\\n    name: 'function',\\n    test: _is.isFunction\\n  }, {\\n    name: 'Date',\\n    test: _is.isDate\\n  }, {\\n    name: 'RegExp',\\n    test: _is.isRegExp\\n  }, {\\n    name: 'null',\\n    test: _is.isNull\\n  }, {\\n    name: 'undefined',\\n    test: _is.isUndefined\\n  }, {\\n    name: 'AccessorNode',\\n    test: _is.isAccessorNode\\n  }, {\\n    name: 'ArrayNode',\\n    test: _is.isArrayNode\\n  }, {\\n    name: 'AssignmentNode',\\n    test: _is.isAssignmentNode\\n  }, {\\n    name: 'BlockNode',\\n    test: _is.isBlockNode\\n  }, {\\n    name: 'ConditionalNode',\\n    test: _is.isConditionalNode\\n  }, {\\n    name: 'ConstantNode',\\n    test: _is.isConstantNode\\n  }, {\\n    name: 'FunctionNode',\\n    test: _is.isFunctionNode\\n  }, {\\n    name: 'FunctionAssignmentNode',\\n    test: _is.isFunctionAssignmentNode\\n  }, {\\n    name: 'IndexNode',\\n    test: _is.isIndexNode\\n  }, {\\n    name: 'Node',\\n    test: _is.isNode\\n  }, {\\n    name: 'ObjectNode',\\n    test: _is.isObjectNode\\n  }, {\\n    name: 'OperatorNode',\\n    test: _is.isOperatorNode\\n  }, {\\n    name: 'ParenthesisNode',\\n    test: _is.isParenthesisNode\\n  }, {\\n    name: 'RangeNode',\\n    test: _is.isRangeNode\\n  }, {\\n    name: 'SymbolNode',\\n    test: _is.isSymbolNode\\n  }, {\\n    name: 'Object',\\n    test: _is.isObject\\n  } // order 'Object' last, it matches on other classes too\\n  ];\\n  typed.conversions = [{\\n    from: 'number',\\n    to: 'BigNumber',\\n    convert: function convert(x) {\\n      if (!BigNumber) {\\n        throwNoBignumber(x);\\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\\n\\n\\n      if ((0, _number.digits)(x) > 15) {\\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\\n      }\\n\\n      return new BigNumber(x);\\n    }\\n  }, {\\n    from: 'number',\\n    to: 'Complex',\\n    convert: function convert(x) {\\n      if (!Complex) {\\n        throwNoComplex(x);\\n      }\\n\\n      return new Complex(x, 0);\\n    }\\n  }, {\\n    from: 'number',\\n    to: 'string',\\n    convert: function convert(x) {\\n      return x + '';\\n    }\\n  }, {\\n    from: 'BigNumber',\\n    to: 'Complex',\\n    convert: function convert(x) {\\n      if (!Complex) {\\n        throwNoComplex(x);\\n      }\\n\\n      return new Complex(x.toNumber(), 0);\\n    }\\n  }, {\\n    from: 'Fraction',\\n    to: 'BigNumber',\\n    convert: function convert(x) {\\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\\n    }\\n  }, {\\n    from: 'Fraction',\\n    to: 'Complex',\\n    convert: function convert(x) {\\n      if (!Complex) {\\n        throwNoComplex(x);\\n      }\\n\\n      return new Complex(x.valueOf(), 0);\\n    }\\n  }, {\\n    from: 'number',\\n    to: 'Fraction',\\n    convert: function convert(x) {\\n      if (!Fraction) {\\n        throwNoFraction(x);\\n      }\\n\\n      var f = new Fraction(x);\\n\\n      if (f.valueOf() !== x) {\\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\\n      }\\n\\n      return f;\\n    }\\n  }, {\\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\\n    //  from: 'Fraction',\\n    //  to: 'number',\\n    //  convert: function (x) {\\n    //    return x.valueOf()\\n    //  }\\n    // }, {\\n    from: 'string',\\n    to: 'number',\\n    convert: function convert(x) {\\n      var n = Number(x);\\n\\n      if (isNaN(n)) {\\n        throw new Error('Cannot convert \\\"' + x + '\\\" to a number');\\n      }\\n\\n      return n;\\n    }\\n  }, {\\n    from: 'string',\\n    to: 'BigNumber',\\n    convert: function convert(x) {\\n      if (!BigNumber) {\\n        throwNoBignumber(x);\\n      }\\n\\n      try {\\n        return new BigNumber(x);\\n      } catch (err) {\\n        throw new Error('Cannot convert \\\"' + x + '\\\" to BigNumber');\\n      }\\n    }\\n  }, {\\n    from: 'string',\\n    to: 'Fraction',\\n    convert: function convert(x) {\\n      if (!Fraction) {\\n        throwNoFraction(x);\\n      }\\n\\n      try {\\n        return new Fraction(x);\\n      } catch (err) {\\n        throw new Error('Cannot convert \\\"' + x + '\\\" to Fraction');\\n      }\\n    }\\n  }, {\\n    from: 'string',\\n    to: 'Complex',\\n    convert: function convert(x) {\\n      if (!Complex) {\\n        throwNoComplex(x);\\n      }\\n\\n      try {\\n        return new Complex(x);\\n      } catch (err) {\\n        throw new Error('Cannot convert \\\"' + x + '\\\" to Complex');\\n      }\\n    }\\n  }, {\\n    from: 'boolean',\\n    to: 'number',\\n    convert: function convert(x) {\\n      return +x;\\n    }\\n  }, {\\n    from: 'boolean',\\n    to: 'BigNumber',\\n    convert: function convert(x) {\\n      if (!BigNumber) {\\n        throwNoBignumber(x);\\n      }\\n\\n      return new BigNumber(+x);\\n    }\\n  }, {\\n    from: 'boolean',\\n    to: 'Fraction',\\n    convert: function convert(x) {\\n      if (!Fraction) {\\n        throwNoFraction(x);\\n      }\\n\\n      return new Fraction(+x);\\n    }\\n  }, {\\n    from: 'boolean',\\n    to: 'string',\\n    convert: function convert(x) {\\n      return String(x);\\n    }\\n  }, {\\n    from: 'Array',\\n    to: 'Matrix',\\n    convert: function convert(array) {\\n      if (!DenseMatrix) {\\n        throwNoMatrix();\\n      }\\n\\n      return new DenseMatrix(array);\\n    }\\n  }, {\\n    from: 'Matrix',\\n    to: 'Array',\\n    convert: function convert(matrix) {\\n      return matrix.valueOf();\\n    }\\n  }];\\n  return typed;\\n});\\nexports.createTyped = createTyped;\\n\\nfunction throwNoBignumber(x) {\\n  throw new Error(\\\"Cannot convert value \\\".concat(x, \\\" into a BigNumber: no class 'BigNumber' provided\\\"));\\n}\\n\\nfunction throwNoComplex(x) {\\n  throw new Error(\\\"Cannot convert value \\\".concat(x, \\\" into a Complex number: no class 'Complex' provided\\\"));\\n}\\n\\nfunction throwNoMatrix() {\\n  throw new Error('Cannot convert array into a Matrix: no class \\\\'DenseMatrix\\\\' provided');\\n}\\n\\nfunction throwNoFraction(x) {\\n  throw new Error(\\\"Cannot convert value \\\".concat(x, \\\" into a Fraction, no class 'Fraction' provided.\\\"));\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"throwNoBignumber\",\"x\",\"Error\",\"concat\",\"throwNoComplex\",\"throwNoFraction\",\"Object\",\"defineProperty\",\"value\",\"createTyped\",\"_is\",\"_typedFunction\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"_number\",\"_factory\",\"_createTyped2\",\"create\",\"factory\",\"dependencies\",\"_ref\",\"BigNumber\",\"Complex\",\"DenseMatrix\",\"Fraction\",\"typed\",\"types\",\"name\",\"test\",\"isNumber\",\"isComplex\",\"isBigNumber\",\"isFraction\",\"isUnit\",\"isString\",\"isChain\",\"isArray\",\"isMatrix\",\"isDenseMatrix\",\"isSparseMatrix\",\"isRange\",\"isIndex\",\"isBoolean\",\"isResultSet\",\"isHelp\",\"isFunction\",\"isDate\",\"isRegExp\",\"isNull\",\"isUndefined\",\"isAccessorNode\",\"isArrayNode\",\"isAssignmentNode\",\"isBlockNode\",\"isConditionalNode\",\"isConstantNode\",\"isFunctionNode\",\"isFunctionAssignmentNode\",\"isIndexNode\",\"isNode\",\"isObjectNode\",\"isOperatorNode\",\"isParenthesisNode\",\"isRangeNode\",\"isSymbolNode\",\"isObject\",\"conversions\",\"from\",\"to\",\"convert\",\"digits\",\"TypeError\",\"toNumber\",\"valueOf\",\"f\",\"n\",\"Number\",\"isNaN\",\"err\",\"String\",\"array\",\"matrix\"]\n}\n"]