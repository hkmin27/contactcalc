["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/parse.js"],"~:js","shadow$provide[271]=function(c,b,y,a){function q(){q=Object.assign||function(t){for(var p=1;p<arguments.length;p++){var g=arguments[p],d;for(d in g)Object.prototype.hasOwnProperty.call(g,d)&&(t[d]=g[d])}return t};return q.apply(this,arguments)}Object.defineProperty(a,\"__esModule\",{value:!0});a.createParse=void 0;c=b(25);var f=b(14),u=b(38),k=b(15);b=(0,c.factory)(\"parse\",\"typed numeric config AccessorNode ArrayNode AssignmentNode BlockNode ConditionalNode ConstantNode FunctionAssignmentNode FunctionNode IndexNode ObjectNode OperatorNode ParenthesisNode RangeNode RelationalNode SymbolNode\".split(\" \"),\nfunction(t){function p(O){var ma=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},Ja=void 0!==ma.nodes?ma.nodes:{};return(0,u.deepMap)(O,function(Ta){if(\"string\"!==typeof Ta)throw new TypeError(\"String expected\");return C(Ta,Ja)})}function g(O){return O.expression.substr(O.index,1)}function d(O){O.index++}function l(O){return O.expression.charAt(O.index+1)}function h(O){O.tokenType=Ea.NULL;O.token=\"\";for(O.comment=\"\";Da.isWhitespace(g(O),O.nestingLevel);)d(O);if(\"#\"===g(O))for(;\"\\n\"!==g(O)&&\n\"\"!==g(O);)O.comment+=g(O),d(O);if(\"\"===g(O))O.tokenType=Ea.DELIMITER;else if(\"\\n\"!==g(O)||O.nestingLevel){var ma=g(O),Ja=O.expression.substr(O.index,2),Ta=O.expression.substr(O.index,3);if(3===Ta.length&&ab[Ta])O.tokenType=Ea.DELIMITER,O.token=Ta,d(O),d(O),d(O);else if(2===Ja.length&&ab[Ja])O.tokenType=Ea.DELIMITER,O.token=Ja,d(O),d(O);else if(ab[ma])O.tokenType=Ea.DELIMITER,O.token=ma,d(O);else if(Da.isDigitDot(ma))if(O.tokenType=Ea.NUMBER,ma=O.expression.substr(O.index,2),\"0b\"===ma||\"0o\"===ma||\n\"0x\"===ma){O.token+=g(O);d(O);O.token+=g(O);for(d(O);Da.isHexDigit(g(O));)O.token+=g(O),d(O);if(\".\"===g(O))for(O.token+=\".\",d(O);Da.isHexDigit(g(O));)O.token+=g(O),d(O);else if(\"i\"===g(O))for(O.token+=\"i\",d(O);Da.isDigit(g(O));)O.token+=g(O),d(O)}else{if(\".\"===g(O))O.token+=g(O),d(O),Da.isDigit(g(O))||(O.tokenType=Ea.DELIMITER);else{for(;Da.isDigit(g(O));)O.token+=g(O),d(O);Da.isDecimalMark(g(O),l(O))&&(O.token+=g(O),d(O))}for(;Da.isDigit(g(O));)O.token+=g(O),d(O);if(\"E\"===g(O)||\"e\"===g(O))if(Da.isDigit(l(O))||\n\"-\"===l(O)||\"+\"===l(O)){O.token+=g(O);d(O);if(\"+\"===g(O)||\"-\"===g(O))O.token+=g(O),d(O);if(!Da.isDigit(g(O)))throw ha(O,'Digit expected, got \"'+g(O)+'\"');for(;Da.isDigit(g(O));)O.token+=g(O),d(O);if(Da.isDecimalMark(g(O),l(O)))throw ha(O,'Digit expected, got \"'+g(O)+'\"');}else if(\".\"===l(O))throw d(O),ha(O,'Digit expected, got \"'+g(O)+'\"');}else if(Da.isAlpha(g(O),O.expression.charAt(O.index-1),l(O))){for(;Da.isAlpha(g(O),O.expression.charAt(O.index-1),l(O))||Da.isDigit(g(O));)O.token+=g(O),d(O);\n(0,k.hasOwnProperty)(fb,O.token)?O.tokenType=Ea.DELIMITER:O.tokenType=Ea.SYMBOL}else{for(O.tokenType=Ea.UNKNOWN;\"\"!==g(O);)O.token+=g(O),d(O);throw ha(O,'Syntax error in part \"'+O.token+'\"');}}else O.tokenType=Ea.DELIMITER,O.token=g(O),d(O)}function n(O){do h(O);while(\"\\n\"===O.token)}function r(O){O.nestingLevel++}function v(O){O.nestingLevel--}function C(O,ma){var Ja={extraNodes:{},expression:\"\",comment:\"\",index:0,token:\"\",tokenType:Ea.NULL,nestingLevel:0,conditionalLevel:null};q(Ja,{expression:O,\nextraNodes:ma});h(Ja);O=[];if(\"\"!==Ja.token&&\"\\n\"!==Ja.token&&\";\"!==Ja.token){var Ta=z(Ja);Ta.comment=Ja.comment}for(;\"\\n\"===Ja.token||\";\"===Ja.token;)0===O.length&&Ta&&(ma=\";\"!==Ja.token,O.push({node:Ta,visible:ma})),h(Ja),\"\\n\"!==Ja.token&&\";\"!==Ja.token&&\"\"!==Ja.token&&(Ta=z(Ja),Ta.comment=Ja.comment,ma=\";\"!==Ja.token,O.push({node:Ta,visible:ma}));0<O.length?Ta=new da(O):Ta||(Ta=new na(void 0),Ta.comment=Ja.comment);if(\"\"!==Ja.token){if(Ja.tokenType===Ea.DELIMITER)throw wa(Ja,\"Unexpected operator \"+\nJa.token);throw ha(Ja,'Unexpected part \"'+Ja.token+'\"');}return Ta}function z(O){var ma=w(O);if(\"\\x3d\"===O.token){if((0,f.isSymbolNode)(ma)){var Ja=ma.name;n(O);O=z(O);return new va(new ya(Ja),O)}if((0,f.isAccessorNode)(ma))return n(O),O=z(O),new va(ma.object,ma.index,O);if((0,f.isFunctionNode)(ma)&&(0,f.isSymbolNode)(ma.fn)){var Ta=!0;var lb=[];Ja=ma.name;ma.args.forEach(function(Ub,Ib){(0,f.isSymbolNode)(Ub)?lb[Ib]=Ub.name:Ta=!1});if(Ta)return n(O),O=z(O),new la(Ja,lb,O)}throw ha(O,\"Invalid left hand side of assignment operator \\x3d\");\n}return ma}function w(O){for(var ma,Ja=B(O);\"or\"===O.token;)n(O),Ja=new Qa(\"or\",\"or\",[Ja,B(O)]);for(ma=Ja;\"?\"===O.token;){Ja=O.conditionalLevel;O.conditionalLevel=O.nestingLevel;n(O);var Ta=z(O);if(\":\"!==O.token)throw ha(O,\"False part of conditional expression expected\");O.conditionalLevel=null;n(O);var lb=z(O);ma=new ja(ma,Ta,lb);O.conditionalLevel=Ja}return ma}function B(O){for(var ma=x(O);\"xor\"===O.token;)n(O),ma=new Qa(\"xor\",\"xor\",[ma,x(O)]);return ma}function x(O){for(var ma=D(O);\"and\"===O.token;)n(O),\nma=new Qa(\"and\",\"and\",[ma,D(O)]);return ma}function D(O){for(var ma=F(O);\"|\"===O.token;)n(O),ma=new Qa(\"|\",\"bitOr\",[ma,F(O)]);return ma}function F(O){for(var ma=E(O);\"^|\"===O.token;)n(O),ma=new Qa(\"^|\",\"bitXor\",[ma,E(O)]);return ma}function E(O){for(var ma=G(O);\"\\x26\"===O.token;)n(O),ma=new Qa(\"\\x26\",\"bitAnd\",[ma,G(O)]);return ma}function G(O){for(var ma=[I(O)],Ja=[],Ta={\"\\x3d\\x3d\":\"equal\",\"!\\x3d\":\"unequal\",\"\\x3c\":\"smaller\",\"\\x3e\":\"larger\",\"\\x3c\\x3d\":\"smallerEq\",\"\\x3e\\x3d\":\"largerEq\"};(0,k.hasOwnProperty)(Ta,\nO.token);)Ja.push({name:O.token,fn:Ta[O.token]}),n(O),ma.push(I(O));return 1===ma.length?ma[0]:2===ma.length?new Qa(Ja[0].name,Ja[0].fn,ma):new qa(Ja.map(function(lb){return lb.fn}),ma)}function I(O){var ma=L(O);for(var Ja={\"\\x3c\\x3c\":\"leftShift\",\"\\x3e\\x3e\":\"rightArithShift\",\"\\x3e\\x3e\\x3e\":\"rightLogShift\"};(0,k.hasOwnProperty)(Ja,O.token);){var Ta=O.token;var lb=Ja[Ta];n(O);ma=[ma,L(O)];ma=new Qa(Ta,lb,ma)}return ma}function L(O){var ma=M(O);for(var Ja={to:\"to\",\"in\":\"to\"};(0,k.hasOwnProperty)(Ja,\nO.token);){var Ta=O.token;var lb=Ja[Ta];n(O);\"in\"===Ta&&\"\"===O.token?ma=new Qa(\"*\",\"multiply\",[ma,new ya(\"in\")],!0):(ma=[ma,M(O)],ma=new Qa(Ta,lb,ma))}return ma}function M(O){var ma=[];var Ja=\":\"===O.token?new na(1):S(O);if(\":\"===O.token&&O.conditionalLevel!==O.nestingLevel){for(ma.push(Ja);\":\"===O.token&&3>ma.length;)n(O),\")\"===O.token||\"]\"===O.token||\",\"===O.token||\"\"===O.token?ma.push(new ya(\"end\")):ma.push(S(O));Ja=3===ma.length?new ea(ma[0],ma[2],ma[1]):new ea(ma[0],ma[1])}return Ja}function S(O){var ma=\nP(O);for(var Ja={\"+\":\"add\",\"-\":\"subtract\"};(0,k.hasOwnProperty)(Ja,O.token);){var Ta=O.token;var lb=Ja[Ta];n(O);ma=[ma,P(O)];ma=new Qa(Ta,lb,ma)}return ma}function P(O){var ma=R(O);for(var Ja={\"*\":\"multiply\",\".*\":\"dotMultiply\",\"/\":\"divide\",\"./\":\"dotDivide\",\"%\":\"mod\",mod:\"mod\"};;)if((0,k.hasOwnProperty)(Ja,O.token)){var Ta=O.token;var lb=Ja[Ta];n(O);var Ub=R(O);ma=new Qa(Ta,lb,[ma,Ub])}else break;return ma}function R(O){var ma,Ja;for(Ja=ma=ba(O);;)if(O.tokenType===Ea.SYMBOL||\"in\"===O.token&&(0,f.isConstantNode)(ma)||\n!(O.tokenType!==Ea.NUMBER||(0,f.isConstantNode)(Ja)||(0,f.isOperatorNode)(Ja)&&\"!\"!==Ja.op)||\"(\"===O.token)Ja=ba(O),ma=new Qa(\"*\",\"multiply\",[ma,Ja],!0);else break;return ma}function ba(O){for(var ma=Q(O),Ja=ma,Ta=[];;)if(\"/\"===O.token&&(0,f.isConstantNode)(Ja))if(Ta.push(q({},O)),n(O),O.tokenType===Ea.NUMBER)if(Ta.push(q({},O)),n(O),O.tokenType===Ea.SYMBOL||\"(\"===O.token)q(O,Ta.pop()),Ta.pop(),Ja=Q(O),ma=new Qa(\"/\",\"divide\",[ma,Ja]);else{Ta.pop();q(O,Ta.pop());break}else{q(O,Ta.pop());break}else break;\nreturn ma}function Q(O){var ma={\"-\":\"unaryMinus\",\"+\":\"unaryPlus\",\"~\":\"bitNot\",not:\"not\"};if((0,k.hasOwnProperty)(ma,O.token)){var Ja=ma[O.token];ma=O.token;n(O);O=[Q(O)];return new Qa(ma,Ja,O)}ma=[];if(O.tokenType===Ea.SYMBOL&&(0,k.hasOwnProperty)(O.extraNodes,O.token)){Ja=O.extraNodes[O.token];h(O);if(\"(\"===O.token){ma=[];r(O);h(O);if(\")\"!==O.token)for(ma.push(z(O));\",\"===O.token;)h(O),ma.push(z(O));if(\")\"!==O.token)throw ha(O,\"Parenthesis ) expected\");v(O);h(O)}var Ta=new Ja(ma)}else if(O.tokenType===\nEa.SYMBOL||O.tokenType===Ea.DELIMITER&&O.token in fb)ma=O.token,h(O),ma=(0,k.hasOwnProperty)(hb,ma)?new na(hb[ma]):-1!==gb.indexOf(ma)?new na(Ha(ma,\"number\")):new ya(ma),Ta=ma=T(O,ma);else{if('\"'===O.token)ma=Y(O),ma=new na(ma),ma=T(O,ma);else if(\"'\"===O.token)ma=ca(O),ma=new na(ma),ma=T(O,ma);else if(\"[\"===O.token){r(O);h(O);if(\"]\"!==O.token)if(Ja=ka(O),\";\"===O.token){ma=1;for(Ja=[Ja];\";\"===O.token;)h(O),Ja[ma]=ka(O),ma++;if(\"]\"!==O.token)throw ha(O,\"End of matrix ] expected\");v(O);h(O);var lb=Ja[0].items.length;\nfor(Ta=1;Ta<ma;Ta++)if(Ja[Ta].items.length!==lb)throw wa(O,\"Column dimensions mismatch (\"+Ja[Ta].items.length+\" !\\x3d\\x3d \"+lb+\")\");ma=new fa(Ja)}else{if(\"]\"!==O.token)throw ha(O,\"End of matrix ] expected\");v(O);h(O);ma=Ja}else v(O),h(O),ma=new fa([]);ma=T(O,ma)}else if(\"{\"===O.token){r(O);Ja={};do if(h(O),\"}\"!==O.token){if('\"'===O.token)ma=Y(O);else if(\"'\"===O.token)ma=ca(O);else if(O.tokenType===Ea.SYMBOL||O.tokenType===Ea.DELIMITER&&O.token in fb)ma=O.token,h(O);else throw ha(O,\"Symbol or string expected as object key\");\nif(\":\"!==O.token)throw ha(O,\"Colon : expected after object key\");h(O);Ja[ma]=z(O)}while(\",\"===O.token);if(\"}\"!==O.token)throw ha(O,\"Comma , or bracket } expected after object value\");v(O);h(O);ma=new Sa(Ja);ma=T(O,ma)}else if(O.tokenType===Ea.NUMBER)ma=O.token,h(O),ma=new na(Ha(ma,oa.number));else if(\"(\"===O.token){r(O);h(O);ma=z(O);if(\")\"!==O.token)throw ha(O,\"Parenthesis ) expected\");v(O);h(O);ma=new Ua(ma);ma=T(O,ma)}else{if(\"\"===O.token)throw ha(O,\"Unexpected end of expression\");throw ha(O,\"Value expected\");\n}Ta=ma}for(lb={\"!\":\"factorial\",\"'\":\"ctranspose\"};(0,k.hasOwnProperty)(lb,O.token);)ma=O.token,Ja=lb[ma],h(O),Ta=[Ta],Ta=new Qa(ma,Ja,Ta),Ta=T(O,Ta);lb=Ta;if(\"^\"===O.token||\".^\"===O.token)ma=O.token,Ja=\"^\"===ma?\"pow\":\"dotPow\",n(O),O=[lb,Q(O)],lb=new Qa(ma,Ja,O);return lb}function T(O,ma,Ja){for(var Ta;!(\"(\"!==O.token&&\"[\"!==O.token&&\".\"!==O.token||Ja&&-1===Ja.indexOf(O.token));)if(Ta=[],\"(\"===O.token)if((0,f.isSymbolNode)(ma)||(0,f.isAccessorNode)(ma)){r(O);h(O);if(\")\"!==O.token)for(Ta.push(z(O));\",\"===\nO.token;)h(O),Ta.push(z(O));if(\")\"!==O.token)throw ha(O,\"Parenthesis ) expected\");v(O);h(O);ma=new ta(ma,Ta)}else break;else if(\"[\"===O.token){r(O);h(O);if(\"]\"!==O.token)for(Ta.push(z(O));\",\"===O.token;)h(O),Ta.push(z(O));if(\"]\"!==O.token)throw ha(O,\"Parenthesis ] expected\");v(O);h(O);ma=new Ka(ma,new Fa(Ta))}else{h(O);if(O.tokenType!==Ea.SYMBOL)throw ha(O,\"Property name expected after dot\");Ta.push(new na(O.token));h(O);ma=new Ka(ma,new Fa(Ta,!0))}return ma}function Y(O){for(var ma=\"\";\"\"!==g(O)&&\n'\"'!==g(O);)\"\\\\\"===g(O)&&(ma+=g(O),d(O)),ma+=g(O),d(O);h(O);if('\"'!==O.token)throw ha(O,'End of string \" expected');h(O);return JSON.parse('\"'+ma+'\"')}function ca(O){for(var ma=\"\";\"\"!==g(O)&&\"'\"!==g(O);)\"\\\\\"===g(O)&&(ma+=g(O),d(O)),ma+=g(O),d(O);h(O);if(\"'\"!==O.token)throw ha(O,\"End of string ' expected\");h(O);return JSON.parse('\"'+ma+'\"')}function ka(O){for(var ma=[z(O)],Ja=1;\",\"===O.token;)h(O),ma[Ja]=z(O),Ja++;return new fa(ma)}function ha(O,ma){O=O.index-O.token.length+1;ma=new SyntaxError(ma+\n\" (char \"+O+\")\");ma[\"char\"]=O;return ma}function wa(O,ma){O=O.index-O.token.length+1;ma=new SyntaxError(ma+\" (char \"+O+\")\");ma[\"char\"]=O;return ma}var Ia=t.typed,Ha=t.numeric,oa=t.config,Ka=t.AccessorNode,fa=t.ArrayNode,va=t.AssignmentNode,da=t.BlockNode,ja=t.ConditionalNode,na=t.ConstantNode,la=t.FunctionAssignmentNode,ta=t.FunctionNode,Fa=t.IndexNode,Sa=t.ObjectNode,Qa=t.OperatorNode,Ua=t.ParenthesisNode,ea=t.RangeNode,qa=t.RelationalNode,ya=t.SymbolNode,Da=Ia(\"parse\",{string:function(O){return C(O,\n{})},\"Array | Matrix\":function(O){return p(O,{})},\"string, Object\":function(O,ma){return C(O,void 0!==ma.nodes?ma.nodes:{})},\"Array | Matrix, Object\":p}),Ea={NULL:0,DELIMITER:1,NUMBER:2,SYMBOL:3,UNKNOWN:4},ab={\",\":!0,\"(\":!0,\")\":!0,\"[\":!0,\"]\":!0,\"{\":!0,\"}\":!0,'\"':!0,\"'\":!0,\";\":!0,\"+\":!0,\"-\":!0,\"*\":!0,\".*\":!0,\"/\":!0,\"./\":!0,\"%\":!0,\"^\":!0,\".^\":!0,\"~\":!0,\"!\":!0,\"\\x26\":!0,\"|\":!0,\"^|\":!0,\"\\x3d\":!0,\":\":!0,\"?\":!0,\"\\x3d\\x3d\":!0,\"!\\x3d\":!0,\"\\x3c\":!0,\"\\x3e\":!0,\"\\x3c\\x3d\":!0,\"\\x3e\\x3d\":!0,\"\\x3c\\x3c\":!0,\"\\x3e\\x3e\":!0,\n\"\\x3e\\x3e\\x3e\":!0},fb={mod:!0,to:!0,\"in\":!0,and:!0,xor:!0,or:!0,not:!0},hb={\"true\":!0,\"false\":!1,\"null\":null,undefined:void 0},gb=[\"NaN\",\"Infinity\"];Da.isAlpha=function(O,ma,Ja){return Da.isValidLatinOrGreek(O)||Da.isValidMathSymbol(O,Ja)||Da.isValidMathSymbol(ma,O)};Da.isValidLatinOrGreek=function(O){return/^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(O)};Da.isValidMathSymbol=function(O,ma){return/^[\\uD835]$/.test(O)&&/^[\\uDC00-\\uDFFF]$/.test(ma)&&/^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(ma)};\nDa.isWhitespace=function(O,ma){return\" \"===O||\"\\t\"===O||\"\\n\"===O&&0<ma};Da.isDecimalMark=function(O,ma){return\".\"===O&&\"/\"!==ma&&\"*\"!==ma&&\"^\"!==ma};Da.isDigitDot=function(O){return\"0\"<=O&&\"9\">=O||\".\"===O};Da.isDigit=function(O){return\"0\"<=O&&\"9\">=O};Da.isHexDigit=function(O){return\"0\"<=O&&\"9\">=O||\"a\"<=O&&\"f\">=O||\"A\"<=O&&\"F\">=O};return Da});a.createParse=b}","~:source","shadow$provide[271] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParse = void 0;\n\nvar _factory = require(\"../utils/factory.js\");\n\nvar _is = require(\"../utils/is.js\");\n\nvar _collection = require(\"../utils/collection.js\");\n\nvar _object = require(\"../utils/object.js\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nvar createParse = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      numeric = _ref.numeric,\n      config = _ref.config,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      AssignmentNode = _ref.AssignmentNode,\n      BlockNode = _ref.BlockNode,\n      ConditionalNode = _ref.ConditionalNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      RangeNode = _ref.RangeNode,\n      RelationalNode = _ref.RelationalNode,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return (0, _collection.deepMap)(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    \"in\": true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    \"true\": true,\n    \"false\": false,\n    \"null\": null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state); // get the digits after the radix\n\n          while (parse.isHexDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state); // get the word size\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if ((0, _object.hasOwnProperty)(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if ((0, _is.isSymbolNode)(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if ((0, _is.isAccessorNode)(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if ((0, _is.isFunctionNode)(node) && (0, _is.isSymbolNode)(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if ((0, _is.isSymbolNode)(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      \"in\": 'to' // alias of 'to'\n\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if ((0, _object.hasOwnProperty)(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && (0, _is.isConstantNode)(node) || state.tokenType === TOKENTYPE.NUMBER && !(0, _is.isConstantNode)(last) && (!(0, _is.isOperatorNode)(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && (0, _is.isConstantNode)(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if ((0, _object.hasOwnProperty)(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && (0, _object.hasOwnProperty)(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if ((0, _object.hasOwnProperty)(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if ((0, _is.isSymbolNode)(node) || (0, _is.isAccessorNode)(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n\n  return parse;\n});\nexports.createParse = createParse;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$collection","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["NULL","UNKNOWN","nestingLevel","token","string","index","not","NUMBER","isHexDigit","__esModule","tokenType","conditionalLevel","fn","expression","DELIMITER","isValidMathSymbol","name","value","visible","or","isAlpha","createParse","isDigitDot","and","mod","extraNodes","undefined","SYMBOL","isDigit","comment","isWhitespace","to","xor","isDecimalMark","isValidLatinOrGreek","node"]],"~:compiled-at",1619135723973,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$parse.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/parse.js\"],\n\"sourcesContent\":[\"shadow$provide[271] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createParse = void 0;\\n\\nvar _factory = require(\\\"../utils/factory.js\\\");\\n\\nvar _is = require(\\\"../utils/is.js\\\");\\n\\nvar _collection = require(\\\"../utils/collection.js\\\");\\n\\nvar _object = require(\\\"../utils/object.js\\\");\\n\\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\\n\\nvar name = 'parse';\\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\\nvar createParse = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      numeric = _ref.numeric,\\n      config = _ref.config,\\n      AccessorNode = _ref.AccessorNode,\\n      ArrayNode = _ref.ArrayNode,\\n      AssignmentNode = _ref.AssignmentNode,\\n      BlockNode = _ref.BlockNode,\\n      ConditionalNode = _ref.ConditionalNode,\\n      ConstantNode = _ref.ConstantNode,\\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\\n      FunctionNode = _ref.FunctionNode,\\n      IndexNode = _ref.IndexNode,\\n      ObjectNode = _ref.ObjectNode,\\n      OperatorNode = _ref.OperatorNode,\\n      ParenthesisNode = _ref.ParenthesisNode,\\n      RangeNode = _ref.RangeNode,\\n      RelationalNode = _ref.RelationalNode,\\n      SymbolNode = _ref.SymbolNode;\\n\\n  /**\\n   * Parse an expression. Returns a node tree, which can be evaluated by\\n   * invoking node.evaluate().\\n   *\\n   * Note the evaluating arbitrary expressions may involve security risks,\\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\\n   *\\n   * Syntax:\\n   *\\n   *     math.parse(expr)\\n   *     math.parse(expr, options)\\n   *     math.parse([expr1, expr2, expr3, ...])\\n   *     math.parse([expr1, expr2, expr3, ...], options)\\n   *\\n   * Example:\\n   *\\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\\n   *     node1.compile().evaluate() // 5\\n   *\\n   *     let scope = {a:3, b:4}\\n   *     const node2 = math.parse('a * b') // 12\\n   *     const code2 = node2.compile()\\n   *     code2.evaluate(scope) // 12\\n   *     scope.a = 5\\n   *     code2.evaluate(scope) // 20\\n   *\\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\\n   *     nodes[2].compile().evaluate() // 12\\n   *\\n   * See also:\\n   *\\n   *     evaluate, compile\\n   *\\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\\n   *                                                   - `nodes` a set of custom nodes\\n   * @return {Node | Node[]} node\\n   * @throws {Error}\\n   */\\n  var parse = typed(name, {\\n    string: function string(expression) {\\n      return parseStart(expression, {});\\n    },\\n    'Array | Matrix': function ArrayMatrix(expressions) {\\n      return parseMultiple(expressions, {});\\n    },\\n    'string, Object': function stringObject(expression, options) {\\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\\n      return parseStart(expression, extraNodes);\\n    },\\n    'Array | Matrix, Object': parseMultiple\\n  });\\n\\n  function parseMultiple(expressions) {\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\\n\\n    return (0, _collection.deepMap)(expressions, function (elem) {\\n      if (typeof elem !== 'string') throw new TypeError('String expected');\\n      return parseStart(elem, extraNodes);\\n    });\\n  } // token types enumeration\\n\\n\\n  var TOKENTYPE = {\\n    NULL: 0,\\n    DELIMITER: 1,\\n    NUMBER: 2,\\n    SYMBOL: 3,\\n    UNKNOWN: 4\\n  }; // map with all delimiters\\n\\n  var DELIMITERS = {\\n    ',': true,\\n    '(': true,\\n    ')': true,\\n    '[': true,\\n    ']': true,\\n    '{': true,\\n    '}': true,\\n    '\\\"': true,\\n    '\\\\'': true,\\n    ';': true,\\n    '+': true,\\n    '-': true,\\n    '*': true,\\n    '.*': true,\\n    '/': true,\\n    './': true,\\n    '%': true,\\n    '^': true,\\n    '.^': true,\\n    '~': true,\\n    '!': true,\\n    '&': true,\\n    '|': true,\\n    '^|': true,\\n    '=': true,\\n    ':': true,\\n    '?': true,\\n    '==': true,\\n    '!=': true,\\n    '<': true,\\n    '>': true,\\n    '<=': true,\\n    '>=': true,\\n    '<<': true,\\n    '>>': true,\\n    '>>>': true\\n  }; // map with all named delimiters\\n\\n  var NAMED_DELIMITERS = {\\n    mod: true,\\n    to: true,\\n    \\\"in\\\": true,\\n    and: true,\\n    xor: true,\\n    or: true,\\n    not: true\\n  };\\n  var CONSTANTS = {\\n    \\\"true\\\": true,\\n    \\\"false\\\": false,\\n    \\\"null\\\": null,\\n    undefined: undefined\\n  };\\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\\n\\n  function initialState() {\\n    return {\\n      extraNodes: {},\\n      // current extra nodes, must be careful not to mutate\\n      expression: '',\\n      // current expression\\n      comment: '',\\n      // last parsed comment\\n      index: 0,\\n      // current index in expr\\n      token: '',\\n      // current token\\n      tokenType: TOKENTYPE.NULL,\\n      // type of the token\\n      nestingLevel: 0,\\n      // level of nesting inside parameters, used to ignore newline characters\\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\\n\\n    };\\n  }\\n  /**\\n   * View upto `length` characters of the expression starting at the current character.\\n   *\\n   * @param {Object} state\\n   * @param {number} [length=1] Number of characters to view\\n   * @returns {string}\\n   * @private\\n   */\\n\\n\\n  function currentString(state, length) {\\n    return state.expression.substr(state.index, length);\\n  }\\n  /**\\n   * View the current character. Returns '' if end of expression is reached.\\n   *\\n   * @param {Object} state\\n   * @returns {string}\\n   * @private\\n   */\\n\\n\\n  function currentCharacter(state) {\\n    return currentString(state, 1);\\n  }\\n  /**\\n   * Get the next character from the expression.\\n   * The character is stored into the char c. If the end of the expression is\\n   * reached, the function puts an empty string in c.\\n   * @private\\n   */\\n\\n\\n  function next(state) {\\n    state.index++;\\n  }\\n  /**\\n   * Preview the previous character from the expression.\\n   * @return {string} cNext\\n   * @private\\n   */\\n\\n\\n  function prevCharacter(state) {\\n    return state.expression.charAt(state.index - 1);\\n  }\\n  /**\\n   * Preview the next character from the expression.\\n   * @return {string} cNext\\n   * @private\\n   */\\n\\n\\n  function nextCharacter(state) {\\n    return state.expression.charAt(state.index + 1);\\n  }\\n  /**\\n   * Get next token in the current string expr.\\n   * The token and token type are available as token and tokenType\\n   * @private\\n   */\\n\\n\\n  function getToken(state) {\\n    state.tokenType = TOKENTYPE.NULL;\\n    state.token = '';\\n    state.comment = ''; // skip over whitespaces\\n    // space, tab, and newline when inside parameters\\n\\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\\n      next(state);\\n    } // skip comment\\n\\n\\n    if (currentCharacter(state) === '#') {\\n      while (currentCharacter(state) !== '\\\\n' && currentCharacter(state) !== '') {\\n        state.comment += currentCharacter(state);\\n        next(state);\\n      }\\n    } // check for end of expression\\n\\n\\n    if (currentCharacter(state) === '') {\\n      // token is still empty\\n      state.tokenType = TOKENTYPE.DELIMITER;\\n      return;\\n    } // check for new line character\\n\\n\\n    if (currentCharacter(state) === '\\\\n' && !state.nestingLevel) {\\n      state.tokenType = TOKENTYPE.DELIMITER;\\n      state.token = currentCharacter(state);\\n      next(state);\\n      return;\\n    }\\n\\n    var c1 = currentCharacter(state);\\n    var c2 = currentString(state, 2);\\n    var c3 = currentString(state, 3);\\n\\n    if (c3.length === 3 && DELIMITERS[c3]) {\\n      state.tokenType = TOKENTYPE.DELIMITER;\\n      state.token = c3;\\n      next(state);\\n      next(state);\\n      next(state);\\n      return;\\n    } // check for delimiters consisting of 2 characters\\n\\n\\n    if (c2.length === 2 && DELIMITERS[c2]) {\\n      state.tokenType = TOKENTYPE.DELIMITER;\\n      state.token = c2;\\n      next(state);\\n      next(state);\\n      return;\\n    } // check for delimiters consisting of 1 character\\n\\n\\n    if (DELIMITERS[c1]) {\\n      state.tokenType = TOKENTYPE.DELIMITER;\\n      state.token = c1;\\n      next(state);\\n      return;\\n    } // check for a number\\n\\n\\n    if (parse.isDigitDot(c1)) {\\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\\n\\n      var _c = currentString(state, 2);\\n\\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\\n        state.token += currentCharacter(state);\\n        next(state);\\n        state.token += currentCharacter(state);\\n        next(state);\\n\\n        while (parse.isHexDigit(currentCharacter(state))) {\\n          state.token += currentCharacter(state);\\n          next(state);\\n        }\\n\\n        if (currentCharacter(state) === '.') {\\n          // this number has a radix point\\n          state.token += '.';\\n          next(state); // get the digits after the radix\\n\\n          while (parse.isHexDigit(currentCharacter(state))) {\\n            state.token += currentCharacter(state);\\n            next(state);\\n          }\\n        } else if (currentCharacter(state) === 'i') {\\n          // this number has a word size suffix\\n          state.token += 'i';\\n          next(state); // get the word size\\n\\n          while (parse.isDigit(currentCharacter(state))) {\\n            state.token += currentCharacter(state);\\n            next(state);\\n          }\\n        }\\n\\n        return;\\n      } // get number, can have a single dot\\n\\n\\n      if (currentCharacter(state) === '.') {\\n        state.token += currentCharacter(state);\\n        next(state);\\n\\n        if (!parse.isDigit(currentCharacter(state))) {\\n          // this is no number, it is just a dot (can be dot notation)\\n          state.tokenType = TOKENTYPE.DELIMITER;\\n        }\\n      } else {\\n        while (parse.isDigit(currentCharacter(state))) {\\n          state.token += currentCharacter(state);\\n          next(state);\\n        }\\n\\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\\n          state.token += currentCharacter(state);\\n          next(state);\\n        }\\n      }\\n\\n      while (parse.isDigit(currentCharacter(state))) {\\n        state.token += currentCharacter(state);\\n        next(state);\\n      } // check for exponential notation like \\\"2.3e-4\\\", \\\"1.23e50\\\" or \\\"2e+4\\\"\\n\\n\\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\\n          state.token += currentCharacter(state);\\n          next(state);\\n\\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\\n            state.token += currentCharacter(state);\\n            next(state);\\n          } // Scientific notation MUST be followed by an exponent\\n\\n\\n          if (!parse.isDigit(currentCharacter(state))) {\\n            throw createSyntaxError(state, 'Digit expected, got \\\"' + currentCharacter(state) + '\\\"');\\n          }\\n\\n          while (parse.isDigit(currentCharacter(state))) {\\n            state.token += currentCharacter(state);\\n            next(state);\\n          }\\n\\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\\n            throw createSyntaxError(state, 'Digit expected, got \\\"' + currentCharacter(state) + '\\\"');\\n          }\\n        } else if (nextCharacter(state) === '.') {\\n          next(state);\\n          throw createSyntaxError(state, 'Digit expected, got \\\"' + currentCharacter(state) + '\\\"');\\n        }\\n      }\\n\\n      return;\\n    } // check for variables, functions, named operators\\n\\n\\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\\n        state.token += currentCharacter(state);\\n        next(state);\\n      }\\n\\n      if ((0, _object.hasOwnProperty)(NAMED_DELIMITERS, state.token)) {\\n        state.tokenType = TOKENTYPE.DELIMITER;\\n      } else {\\n        state.tokenType = TOKENTYPE.SYMBOL;\\n      }\\n\\n      return;\\n    } // something unknown is found, wrong characters -> a syntax error\\n\\n\\n    state.tokenType = TOKENTYPE.UNKNOWN;\\n\\n    while (currentCharacter(state) !== '') {\\n      state.token += currentCharacter(state);\\n      next(state);\\n    }\\n\\n    throw createSyntaxError(state, 'Syntax error in part \\\"' + state.token + '\\\"');\\n  }\\n  /**\\n   * Get next token and skip newline tokens\\n   */\\n\\n\\n  function getTokenSkipNewline(state) {\\n    do {\\n      getToken(state);\\n    } while (state.token === '\\\\n'); // eslint-disable-line no-unmodified-loop-condition\\n\\n  }\\n  /**\\n   * Open parameters.\\n   * New line characters will be ignored until closeParams(state) is called\\n   */\\n\\n\\n  function openParams(state) {\\n    state.nestingLevel++;\\n  }\\n  /**\\n   * Close parameters.\\n   * New line characters will no longer be ignored\\n   */\\n\\n\\n  function closeParams(state) {\\n    state.nestingLevel--;\\n  }\\n  /**\\n   * Checks whether the current character `c` is a valid alpha character:\\n   *\\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\\n   * - An underscore                        Ascii: _\\n   * - A dollar sign                        Ascii: $\\n   * - A latin letter with accents          Unicode: \\\\u00C0 - \\\\u02AF\\n   * - A greek letter                       Unicode: \\\\u0370 - \\\\u03FF\\n   * - A mathematical alphanumeric symbol   Unicode: \\\\u{1D400} - \\\\u{1D7FF} excluding invalid code points\\n   *\\n   * The previous and next characters are needed to determine whether\\n   * this character is part of a unicode surrogate pair.\\n   *\\n   * @param {string} c      Current character in the expression\\n   * @param {string} cPrev  Previous character\\n   * @param {string} cNext  Next character\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\\n  };\\n  /**\\n   * Test whether a character is a valid latin, greek, or letter-like character\\n   * @param {string} c\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\\n    return /^[a-zA-Z_$\\\\u00C0-\\\\u02AF\\\\u0370-\\\\u03FF\\\\u2100-\\\\u214F]$/.test(c);\\n  };\\n  /**\\n   * Test whether two given 16 bit characters form a surrogate pair of a\\n   * unicode math symbol.\\n   *\\n   * https://unicode-table.com/en/\\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\\n   *\\n   * Note: In ES6 will be unicode aware:\\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\\n   * https://mathiasbynens.be/notes/es6-unicode-regex\\n   *\\n   * @param {string} high\\n   * @param {string} low\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\\n    return /^[\\\\uD835]$/.test(high) && /^[\\\\uDC00-\\\\uDFFF]$/.test(low) && /^[^\\\\uDC55\\\\uDC9D\\\\uDCA0\\\\uDCA1\\\\uDCA3\\\\uDCA4\\\\uDCA7\\\\uDCA8\\\\uDCAD\\\\uDCBA\\\\uDCBC\\\\uDCC4\\\\uDD06\\\\uDD0B\\\\uDD0C\\\\uDD15\\\\uDD1D\\\\uDD3A\\\\uDD3F\\\\uDD45\\\\uDD47-\\\\uDD49\\\\uDD51\\\\uDEA6\\\\uDEA7\\\\uDFCC\\\\uDFCD]$/.test(low);\\n  };\\n  /**\\n   * Check whether given character c is a white space character: space, tab, or enter\\n   * @param {string} c\\n   * @param {number} nestingLevel\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\\n    // TODO: also take '\\\\r' carriage return as newline? Or does that give problems on mac?\\n    return c === ' ' || c === '\\\\t' || c === '\\\\n' && nestingLevel > 0;\\n  };\\n  /**\\n   * Test whether the character c is a decimal mark (dot).\\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\\n   * @param {string} c\\n   * @param {string} cNext\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\\n  };\\n  /**\\n   * checks if the given char c is a digit or dot\\n   * @param {string} c   a string with one character\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isDigitDot = function isDigitDot(c) {\\n    return c >= '0' && c <= '9' || c === '.';\\n  };\\n  /**\\n   * checks if the given char c is a digit\\n   * @param {string} c   a string with one character\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isDigit = function isDigit(c) {\\n    return c >= '0' && c <= '9';\\n  };\\n  /**\\n   * checks if the given char c is a hex digit\\n   * @param {string} c   a string with one character\\n   * @return {boolean}\\n   */\\n\\n\\n  parse.isHexDigit = function isHexDigit(c) {\\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\\n  };\\n  /**\\n   * Start of the parse levels below, in order of precedence\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseStart(expression, extraNodes) {\\n    var state = initialState();\\n\\n    _extends(state, {\\n      expression: expression,\\n      extraNodes: extraNodes\\n    });\\n\\n    getToken(state);\\n    var node = parseBlock(state); // check for garbage at the end of the expression\\n    // an expression ends with a empty character '' and tokenType DELIMITER\\n\\n    if (state.token !== '') {\\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\\n        // user entered a not existing operator like \\\"//\\\"\\n        // TODO: give hints for aliases, for example with \\\"<>\\\" give as hint \\\" did you mean !== ?\\\"\\n        throw createError(state, 'Unexpected operator ' + state.token);\\n      } else {\\n        throw createSyntaxError(state, 'Unexpected part \\\"' + state.token + '\\\"');\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Parse a block with expressions. Expressions can be separated by a newline\\n   * character '\\\\n', or by a semicolon ';'. In case of a semicolon, no output\\n   * of the preceding line is returned.\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseBlock(state) {\\n    var node;\\n    var blocks = [];\\n    var visible;\\n\\n    if (state.token !== '' && state.token !== '\\\\n' && state.token !== ';') {\\n      node = parseAssignment(state);\\n      node.comment = state.comment;\\n    } // TODO: simplify this loop\\n\\n\\n    while (state.token === '\\\\n' || state.token === ';') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      if (blocks.length === 0 && node) {\\n        visible = state.token !== ';';\\n        blocks.push({\\n          node: node,\\n          visible: visible\\n        });\\n      }\\n\\n      getToken(state);\\n\\n      if (state.token !== '\\\\n' && state.token !== ';' && state.token !== '') {\\n        node = parseAssignment(state);\\n        node.comment = state.comment;\\n        visible = state.token !== ';';\\n        blocks.push({\\n          node: node,\\n          visible: visible\\n        });\\n      }\\n    }\\n\\n    if (blocks.length > 0) {\\n      return new BlockNode(blocks);\\n    } else {\\n      if (!node) {\\n        node = new ConstantNode(undefined);\\n        node.comment = state.comment;\\n      }\\n\\n      return node;\\n    }\\n  }\\n  /**\\n   * Assignment of a function or variable,\\n   * - can be a variable like 'a=2.3'\\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\\n   * - defining a function like 'f(x) = x^2'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseAssignment(state) {\\n    var name, args, value, valid;\\n    var node = parseConditional(state);\\n\\n    if (state.token === '=') {\\n      if ((0, _is.isSymbolNode)(node)) {\\n        // parse a variable assignment like 'a = 2/3'\\n        name = node.name;\\n        getTokenSkipNewline(state);\\n        value = parseAssignment(state);\\n        return new AssignmentNode(new SymbolNode(name), value);\\n      } else if ((0, _is.isAccessorNode)(node)) {\\n        // parse a matrix subset assignment like 'A[1,2] = 4'\\n        getTokenSkipNewline(state);\\n        value = parseAssignment(state);\\n        return new AssignmentNode(node.object, node.index, value);\\n      } else if ((0, _is.isFunctionNode)(node) && (0, _is.isSymbolNode)(node.fn)) {\\n        // parse function assignment like 'f(x) = x^2'\\n        valid = true;\\n        args = [];\\n        name = node.name;\\n        node.args.forEach(function (arg, index) {\\n          if ((0, _is.isSymbolNode)(arg)) {\\n            args[index] = arg.name;\\n          } else {\\n            valid = false;\\n          }\\n        });\\n\\n        if (valid) {\\n          getTokenSkipNewline(state);\\n          value = parseAssignment(state);\\n          return new FunctionAssignmentNode(name, args, value);\\n        }\\n      }\\n\\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * conditional operation\\n   *\\n   *     condition ? truePart : falsePart\\n   *\\n   * Note: conditional operator is right-associative\\n   *\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseConditional(state) {\\n    var node = parseLogicalOr(state);\\n\\n    while (state.token === '?') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      // set a conditional level, the range operator will be ignored as long\\n      // as conditionalLevel === state.nestingLevel.\\n      var prev = state.conditionalLevel;\\n      state.conditionalLevel = state.nestingLevel;\\n      getTokenSkipNewline(state);\\n      var condition = node;\\n      var trueExpr = parseAssignment(state);\\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\\n      state.conditionalLevel = null;\\n      getTokenSkipNewline(state);\\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\\n\\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\\n\\n      state.conditionalLevel = prev;\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * logical or, 'x or y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseLogicalOr(state) {\\n    var node = parseLogicalXor(state);\\n\\n    while (state.token === 'or') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * logical exclusive or, 'x xor y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseLogicalXor(state) {\\n    var node = parseLogicalAnd(state);\\n\\n    while (state.token === 'xor') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * logical and, 'x and y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseLogicalAnd(state) {\\n    var node = parseBitwiseOr(state);\\n\\n    while (state.token === 'and') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * bitwise or, 'x | y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseBitwiseOr(state) {\\n    var node = parseBitwiseXor(state);\\n\\n    while (state.token === '|') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * bitwise exclusive or (xor), 'x ^| y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseBitwiseXor(state) {\\n    var node = parseBitwiseAnd(state);\\n\\n    while (state.token === '^|') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * bitwise and, 'x & y'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseBitwiseAnd(state) {\\n    var node = parseRelational(state);\\n\\n    while (state.token === '&') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getTokenSkipNewline(state);\\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Parse a chained conditional, like 'a > b >= c'\\n   * @return {Node} node\\n   */\\n\\n\\n  function parseRelational(state) {\\n    var params = [parseShift(state)];\\n    var conditionals = [];\\n    var operators = {\\n      '==': 'equal',\\n      '!=': 'unequal',\\n      '<': 'smaller',\\n      '>': 'larger',\\n      '<=': 'smallerEq',\\n      '>=': 'largerEq'\\n    };\\n\\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      var cond = {\\n        name: state.token,\\n        fn: operators[state.token]\\n      };\\n      conditionals.push(cond);\\n      getTokenSkipNewline(state);\\n      params.push(parseShift(state));\\n    }\\n\\n    if (params.length === 1) {\\n      return params[0];\\n    } else if (params.length === 2) {\\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\\n    } else {\\n      return new RelationalNode(conditionals.map(function (c) {\\n        return c.fn;\\n      }), params);\\n    }\\n  }\\n  /**\\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseShift(state) {\\n    var node, name, fn, params;\\n    node = parseConversion(state);\\n    var operators = {\\n      '<<': 'leftShift',\\n      '>>': 'rightArithShift',\\n      '>>>': 'rightLogShift'\\n    };\\n\\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      name = state.token;\\n      fn = operators[name];\\n      getTokenSkipNewline(state);\\n      params = [node, parseConversion(state)];\\n      node = new OperatorNode(name, fn, params);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * conversion operators 'to' and 'in'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseConversion(state) {\\n    var node, name, fn, params;\\n    node = parseRange(state);\\n    var operators = {\\n      to: 'to',\\n      \\\"in\\\": 'to' // alias of 'to'\\n\\n    };\\n\\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      name = state.token;\\n      fn = operators[name];\\n      getTokenSkipNewline(state);\\n\\n      if (name === 'in' && state.token === '') {\\n        // end of expression -> this is the unit 'in' ('inch')\\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\\n      } else {\\n        // operator 'a to b' or 'a in b'\\n        params = [node, parseRange(state)];\\n        node = new OperatorNode(name, fn, params);\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * parse range, \\\"start:end\\\", \\\"start:step:end\\\", \\\":\\\", \\\"start:\\\", \\\":end\\\", etc\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseRange(state) {\\n    var node;\\n    var params = [];\\n\\n    if (state.token === ':') {\\n      // implicit start=1 (one-based)\\n      node = new ConstantNode(1);\\n    } else {\\n      // explicit start\\n      node = parseAddSubtract(state);\\n    }\\n\\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\\n      // we ignore the range operator when a conditional operator is being processed on the same level\\n      params.push(node); // parse step and end\\n\\n      while (state.token === ':' && params.length < 3) {\\n        // eslint-disable-line no-unmodified-loop-condition\\n        getTokenSkipNewline(state);\\n\\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\\n          // implicit end\\n          params.push(new SymbolNode('end'));\\n        } else {\\n          // explicit end\\n          params.push(parseAddSubtract(state));\\n        }\\n      }\\n\\n      if (params.length === 3) {\\n        // params = [start, step, end]\\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\\n      } else {\\n        // length === 2\\n        // params = [start, end]\\n        node = new RangeNode(params[0], params[1]); // start, end\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * add or subtract\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseAddSubtract(state) {\\n    var node, name, fn, params;\\n    node = parseMultiplyDivide(state);\\n    var operators = {\\n      '+': 'add',\\n      '-': 'subtract'\\n    };\\n\\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      name = state.token;\\n      fn = operators[name];\\n      getTokenSkipNewline(state);\\n      params = [node, parseMultiplyDivide(state)];\\n      node = new OperatorNode(name, fn, params);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * multiply, divide, modulus\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseMultiplyDivide(state) {\\n    var node, last, name, fn;\\n    node = parseImplicitMultiplication(state);\\n    last = node;\\n    var operators = {\\n      '*': 'multiply',\\n      '.*': 'dotMultiply',\\n      '/': 'divide',\\n      './': 'dotDivide',\\n      '%': 'mod',\\n      mod: 'mod'\\n    };\\n\\n    while (true) {\\n      if ((0, _object.hasOwnProperty)(operators, state.token)) {\\n        // explicit operators\\n        name = state.token;\\n        fn = operators[name];\\n        getTokenSkipNewline(state);\\n        last = parseImplicitMultiplication(state);\\n        node = new OperatorNode(name, fn, [node, last]);\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * implicit multiplication\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseImplicitMultiplication(state) {\\n    var node, last;\\n    node = parseRule2(state);\\n    last = node;\\n\\n    while (true) {\\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && (0, _is.isConstantNode)(node) || state.tokenType === TOKENTYPE.NUMBER && !(0, _is.isConstantNode)(last) && (!(0, _is.isOperatorNode)(last) || last.op === '!') || state.token === '(') {\\n        // parse implicit multiplication\\n        //\\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\\n        // number:      implicit multiplication like '(2+3)2'\\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\\n        last = parseRule2(state);\\n        node = new OperatorNode('*', 'multiply', [node, last], true\\n        /* implicit */\\n        );\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Infamous \\\"rule 2\\\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\\n   * Explicit division gets higher precedence than implicit multiplication\\n   * when the division matches this pattern: [number] / [number] [symbol]\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseRule2(state) {\\n    var node = parseUnary(state);\\n    var last = node;\\n    var tokenStates = [];\\n\\n    while (true) {\\n      // Match the \\\"number /\\\" part of the pattern \\\"number / number symbol\\\"\\n      if (state.token === '/' && (0, _is.isConstantNode)(last)) {\\n        // Look ahead to see if the next token is a number\\n        tokenStates.push(_extends({}, state));\\n        getTokenSkipNewline(state); // Match the \\\"number / number\\\" part of the pattern\\n\\n        if (state.tokenType === TOKENTYPE.NUMBER) {\\n          // Look ahead again\\n          tokenStates.push(_extends({}, state));\\n          getTokenSkipNewline(state); // Match the \\\"symbol\\\" part of the pattern, or a left parenthesis\\n\\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\\n            // We've matched the pattern \\\"number / number symbol\\\".\\n            // Rewind once and build the \\\"number / number\\\" node; the symbol will be consumed later\\n            _extends(state, tokenStates.pop());\\n\\n            tokenStates.pop();\\n            last = parseUnary(state);\\n            node = new OperatorNode('/', 'divide', [node, last]);\\n          } else {\\n            // Not a match, so rewind\\n            tokenStates.pop();\\n\\n            _extends(state, tokenStates.pop());\\n\\n            break;\\n          }\\n        } else {\\n          // Not a match, so rewind\\n          _extends(state, tokenStates.pop());\\n\\n          break;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Unary plus and minus, and logical and bitwise not\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseUnary(state) {\\n    var name, params, fn;\\n    var operators = {\\n      '-': 'unaryMinus',\\n      '+': 'unaryPlus',\\n      '~': 'bitNot',\\n      not: 'not'\\n    };\\n\\n    if ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      fn = operators[state.token];\\n      name = state.token;\\n      getTokenSkipNewline(state);\\n      params = [parseUnary(state)];\\n      return new OperatorNode(name, fn, params);\\n    }\\n\\n    return parsePow(state);\\n  }\\n  /**\\n   * power\\n   * Note: power operator is right associative\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parsePow(state) {\\n    var node, name, fn, params;\\n    node = parseLeftHandOperators(state);\\n\\n    if (state.token === '^' || state.token === '.^') {\\n      name = state.token;\\n      fn = name === '^' ? 'pow' : 'dotPow';\\n      getTokenSkipNewline(state);\\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\\n\\n      node = new OperatorNode(name, fn, params);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Left hand operators: factorial x!, ctranspose x'\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseLeftHandOperators(state) {\\n    var node, name, fn, params;\\n    node = parseCustomNodes(state);\\n    var operators = {\\n      '!': 'factorial',\\n      '\\\\'': 'ctranspose'\\n    };\\n\\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\\n      name = state.token;\\n      fn = operators[name];\\n      getToken(state);\\n      params = [node];\\n      node = new OperatorNode(name, fn, params);\\n      node = parseAccessors(state, node);\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Parse a custom node handler. A node handler can be used to process\\n   * nodes in a custom way, for example for handling a plot.\\n   *\\n   * A handler must be passed as second argument of the parse function.\\n   * - must extend math.Node\\n   * - must contain a function _compile(defs: Object) : string\\n   * - must contain a function find(filter: Object) : Node[]\\n   * - must contain a function toString() : string\\n   * - the constructor is called with a single argument containing all parameters\\n   *\\n   * For example:\\n   *\\n   *     nodes = {\\n   *       'plot': PlotHandler\\n   *     }\\n   *\\n   * The constructor of the handler is called as:\\n   *\\n   *     node = new PlotHandler(params)\\n   *\\n   * The handler will be invoked when evaluating an expression like:\\n   *\\n   *     node = math.parse('plot(sin(x), x)', nodes)\\n   *\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseCustomNodes(state) {\\n    var params = [];\\n\\n    if (state.tokenType === TOKENTYPE.SYMBOL && (0, _object.hasOwnProperty)(state.extraNodes, state.token)) {\\n      var CustomNode = state.extraNodes[state.token];\\n      getToken(state); // parse parameters\\n\\n      if (state.token === '(') {\\n        params = [];\\n        openParams(state);\\n        getToken(state);\\n\\n        if (state.token !== ')') {\\n          params.push(parseAssignment(state)); // parse a list with parameters\\n\\n          while (state.token === ',') {\\n            // eslint-disable-line no-unmodified-loop-condition\\n            getToken(state);\\n            params.push(parseAssignment(state));\\n          }\\n        }\\n\\n        if (state.token !== ')') {\\n          throw createSyntaxError(state, 'Parenthesis ) expected');\\n        }\\n\\n        closeParams(state);\\n        getToken(state);\\n      } // create a new custom node\\n      // noinspection JSValidateTypes\\n\\n\\n      return new CustomNode(params);\\n    }\\n\\n    return parseSymbol(state);\\n  }\\n  /**\\n   * parse symbols: functions, variables, constants, units\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseSymbol(state) {\\n    var node, name;\\n\\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\\n      name = state.token;\\n      getToken(state);\\n\\n      if ((0, _object.hasOwnProperty)(CONSTANTS, name)) {\\n        // true, false, null, ...\\n        node = new ConstantNode(CONSTANTS[name]);\\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\\n        // NaN, Infinity\\n        node = new ConstantNode(numeric(name, 'number'));\\n      } else {\\n        node = new SymbolNode(name);\\n      } // parse function parameters and matrix index\\n\\n\\n      node = parseAccessors(state, node);\\n      return node;\\n    }\\n\\n    return parseDoubleQuotesString(state);\\n  }\\n  /**\\n   * parse accessors:\\n   * - function invocation in round brackets (...), for example sqrt(2)\\n   * - index enclosed in square brackets [...], for example A[2,3]\\n   * - dot notation for properties, like foo.bar\\n   * @param {Object} state\\n   * @param {Node} node    Node on which to apply the parameters. If there\\n   *                       are no parameters in the expression, the node\\n   *                       itself is returned\\n   * @param {string[]} [types]  Filter the types of notations\\n   *                            can be ['(', '[', '.']\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseAccessors(state, node, types) {\\n    var params;\\n\\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      params = [];\\n\\n      if (state.token === '(') {\\n        if ((0, _is.isSymbolNode)(node) || (0, _is.isAccessorNode)(node)) {\\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\\n          openParams(state);\\n          getToken(state);\\n\\n          if (state.token !== ')') {\\n            params.push(parseAssignment(state)); // parse a list with parameters\\n\\n            while (state.token === ',') {\\n              // eslint-disable-line no-unmodified-loop-condition\\n              getToken(state);\\n              params.push(parseAssignment(state));\\n            }\\n          }\\n\\n          if (state.token !== ')') {\\n            throw createSyntaxError(state, 'Parenthesis ) expected');\\n          }\\n\\n          closeParams(state);\\n          getToken(state);\\n          node = new FunctionNode(node, params);\\n        } else {\\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\\n          // don't parse it here but let it be handled by parseImplicitMultiplication\\n          // with correct precedence\\n          return node;\\n        }\\n      } else if (state.token === '[') {\\n        // index notation like variable[2, 3]\\n        openParams(state);\\n        getToken(state);\\n\\n        if (state.token !== ']') {\\n          params.push(parseAssignment(state)); // parse a list with parameters\\n\\n          while (state.token === ',') {\\n            // eslint-disable-line no-unmodified-loop-condition\\n            getToken(state);\\n            params.push(parseAssignment(state));\\n          }\\n        }\\n\\n        if (state.token !== ']') {\\n          throw createSyntaxError(state, 'Parenthesis ] expected');\\n        }\\n\\n        closeParams(state);\\n        getToken(state);\\n        node = new AccessorNode(node, new IndexNode(params));\\n      } else {\\n        // dot notation like variable.prop\\n        getToken(state);\\n\\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\\n          throw createSyntaxError(state, 'Property name expected after dot');\\n        }\\n\\n        params.push(new ConstantNode(state.token));\\n        getToken(state);\\n        var dotNotation = true;\\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\\n      }\\n    }\\n\\n    return node;\\n  }\\n  /**\\n   * Parse a double quotes string.\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseDoubleQuotesString(state) {\\n    var node, str;\\n\\n    if (state.token === '\\\"') {\\n      str = parseDoubleQuotesStringToken(state); // create constant\\n\\n      node = new ConstantNode(str); // parse index parameters\\n\\n      node = parseAccessors(state, node);\\n      return node;\\n    }\\n\\n    return parseSingleQuotesString(state);\\n  }\\n  /**\\n   * Parse a string surrounded by double quotes \\\"...\\\"\\n   * @return {string}\\n   */\\n\\n\\n  function parseDoubleQuotesStringToken(state) {\\n    var str = '';\\n\\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\\"') {\\n      if (currentCharacter(state) === '\\\\\\\\') {\\n        // escape character, immediately process the next\\n        // character to prevent stopping at a next '\\\\\\\"'\\n        str += currentCharacter(state);\\n        next(state);\\n      }\\n\\n      str += currentCharacter(state);\\n      next(state);\\n    }\\n\\n    getToken(state);\\n\\n    if (state.token !== '\\\"') {\\n      throw createSyntaxError(state, 'End of string \\\" expected');\\n    }\\n\\n    getToken(state);\\n    return JSON.parse('\\\"' + str + '\\\"'); // unescape escaped characters\\n  }\\n  /**\\n   * Parse a single quotes string.\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseSingleQuotesString(state) {\\n    var node, str;\\n\\n    if (state.token === '\\\\'') {\\n      str = parseSingleQuotesStringToken(state); // create constant\\n\\n      node = new ConstantNode(str); // parse index parameters\\n\\n      node = parseAccessors(state, node);\\n      return node;\\n    }\\n\\n    return parseMatrix(state);\\n  }\\n  /**\\n   * Parse a string surrounded by single quotes '...'\\n   * @return {string}\\n   */\\n\\n\\n  function parseSingleQuotesStringToken(state) {\\n    var str = '';\\n\\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\\\'') {\\n      if (currentCharacter(state) === '\\\\\\\\') {\\n        // escape character, immediately process the next\\n        // character to prevent stopping at a next '\\\\''\\n        str += currentCharacter(state);\\n        next(state);\\n      }\\n\\n      str += currentCharacter(state);\\n      next(state);\\n    }\\n\\n    getToken(state);\\n\\n    if (state.token !== '\\\\'') {\\n      throw createSyntaxError(state, 'End of string \\\\' expected');\\n    }\\n\\n    getToken(state);\\n    return JSON.parse('\\\"' + str + '\\\"'); // unescape escaped characters\\n  }\\n  /**\\n   * parse the matrix\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseMatrix(state) {\\n    var array, params, rows, cols;\\n\\n    if (state.token === '[') {\\n      // matrix [...]\\n      openParams(state);\\n      getToken(state);\\n\\n      if (state.token !== ']') {\\n        // this is a non-empty matrix\\n        var row = parseRow(state);\\n\\n        if (state.token === ';') {\\n          // 2 dimensional array\\n          rows = 1;\\n          params = [row]; // the rows of the matrix are separated by dot-comma's\\n\\n          while (state.token === ';') {\\n            // eslint-disable-line no-unmodified-loop-condition\\n            getToken(state);\\n            params[rows] = parseRow(state);\\n            rows++;\\n          }\\n\\n          if (state.token !== ']') {\\n            throw createSyntaxError(state, 'End of matrix ] expected');\\n          }\\n\\n          closeParams(state);\\n          getToken(state); // check if the number of columns matches in all rows\\n\\n          cols = params[0].items.length;\\n\\n          for (var r = 1; r < rows; r++) {\\n            if (params[r].items.length !== cols) {\\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\\n            }\\n          }\\n\\n          array = new ArrayNode(params);\\n        } else {\\n          // 1 dimensional vector\\n          if (state.token !== ']') {\\n            throw createSyntaxError(state, 'End of matrix ] expected');\\n          }\\n\\n          closeParams(state);\\n          getToken(state);\\n          array = row;\\n        }\\n      } else {\\n        // this is an empty matrix \\\"[ ]\\\"\\n        closeParams(state);\\n        getToken(state);\\n        array = new ArrayNode([]);\\n      }\\n\\n      return parseAccessors(state, array);\\n    }\\n\\n    return parseObject(state);\\n  }\\n  /**\\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\\n   * @return {ArrayNode} node\\n   */\\n\\n\\n  function parseRow(state) {\\n    var params = [parseAssignment(state)];\\n    var len = 1;\\n\\n    while (state.token === ',') {\\n      // eslint-disable-line no-unmodified-loop-condition\\n      getToken(state); // parse expression\\n\\n      params[len] = parseAssignment(state);\\n      len++;\\n    }\\n\\n    return new ArrayNode(params);\\n  }\\n  /**\\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseObject(state) {\\n    if (state.token === '{') {\\n      openParams(state);\\n      var key;\\n      var properties = {};\\n\\n      do {\\n        getToken(state);\\n\\n        if (state.token !== '}') {\\n          // parse key\\n          if (state.token === '\\\"') {\\n            key = parseDoubleQuotesStringToken(state);\\n          } else if (state.token === '\\\\'') {\\n            key = parseSingleQuotesStringToken(state);\\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\\n            key = state.token;\\n            getToken(state);\\n          } else {\\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\\n          } // parse key/value separator\\n\\n\\n          if (state.token !== ':') {\\n            throw createSyntaxError(state, 'Colon : expected after object key');\\n          }\\n\\n          getToken(state); // parse key\\n\\n          properties[key] = parseAssignment(state);\\n        }\\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\\n\\n\\n      if (state.token !== '}') {\\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\\n      }\\n\\n      closeParams(state);\\n      getToken(state);\\n      var node = new ObjectNode(properties); // parse index parameters\\n\\n      node = parseAccessors(state, node);\\n      return node;\\n    }\\n\\n    return parseNumber(state);\\n  }\\n  /**\\n   * parse a number\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseNumber(state) {\\n    var numberStr;\\n\\n    if (state.tokenType === TOKENTYPE.NUMBER) {\\n      // this is a number\\n      numberStr = state.token;\\n      getToken(state);\\n      return new ConstantNode(numeric(numberStr, config.number));\\n    }\\n\\n    return parseParentheses(state);\\n  }\\n  /**\\n   * parentheses\\n   * @return {Node} node\\n   * @private\\n   */\\n\\n\\n  function parseParentheses(state) {\\n    var node; // check if it is a parenthesized expression\\n\\n    if (state.token === '(') {\\n      // parentheses (...)\\n      openParams(state);\\n      getToken(state);\\n      node = parseAssignment(state); // start again\\n\\n      if (state.token !== ')') {\\n        throw createSyntaxError(state, 'Parenthesis ) expected');\\n      }\\n\\n      closeParams(state);\\n      getToken(state);\\n      node = new ParenthesisNode(node);\\n      node = parseAccessors(state, node);\\n      return node;\\n    }\\n\\n    return parseEnd(state);\\n  }\\n  /**\\n   * Evaluated when the expression is not yet ended but expected to end\\n   * @return {Node} res\\n   * @private\\n   */\\n\\n\\n  function parseEnd(state) {\\n    if (state.token === '') {\\n      // syntax error or unexpected end of expression\\n      throw createSyntaxError(state, 'Unexpected end of expression');\\n    } else {\\n      throw createSyntaxError(state, 'Value expected');\\n    }\\n  }\\n  /**\\n   * Shortcut for getting the current row value (one based)\\n   * Returns the line of the currently handled expression\\n   * @private\\n   */\\n\\n  /* TODO: implement keeping track on the row number\\n  function row () {\\n    return null\\n  }\\n  */\\n\\n  /**\\n   * Shortcut for getting the current col value (one based)\\n   * Returns the column (position) where the last state.token starts\\n   * @private\\n   */\\n\\n\\n  function col(state) {\\n    return state.index - state.token.length + 1;\\n  }\\n  /**\\n   * Create an error\\n   * @param {Object} state\\n   * @param {string} message\\n   * @return {SyntaxError} instantiated error\\n   * @private\\n   */\\n\\n\\n  function createSyntaxError(state, message) {\\n    var c = col(state);\\n    var error = new SyntaxError(message + ' (char ' + c + ')');\\n    error[\\\"char\\\"] = c;\\n    return error;\\n  }\\n  /**\\n   * Create an error\\n   * @param {Object} state\\n   * @param {string} message\\n   * @return {Error} instantiated error\\n   * @private\\n   */\\n\\n\\n  function createError(state, message) {\\n    var c = col(state);\\n    var error = new SyntaxError(message + ' (char ' + c + ')');\\n    error[\\\"char\\\"] = c;\\n    return error;\\n  }\\n\\n  return parse;\\n});\\nexports.createParse = createParse;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_extends\",\"Object\",\"assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"apply\",\"defineProperty\",\"value\",\"createParse\",\"_factory\",\"_is\",\"_collection\",\"_object\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"parseMultiple\",\"expressions\",\"options\",\"undefined\",\"extraNodes\",\"nodes\",\"deepMap\",\"elem\",\"TypeError\",\"parseStart\",\"currentCharacter\",\"state\",\"expression\",\"substr\",\"index\",\"next\",\"nextCharacter\",\"charAt\",\"getToken\",\"tokenType\",\"TOKENTYPE\",\"NULL\",\"token\",\"comment\",\"parse\",\"isWhitespace\",\"nestingLevel\",\"DELIMITER\",\"c1\",\"c2\",\"c3\",\"DELIMITERS\",\"isDigitDot\",\"NUMBER\",\"_c\",\"isHexDigit\",\"isDigit\",\"isDecimalMark\",\"createSyntaxError\",\"isAlpha\",\"NAMED_DELIMITERS\",\"SYMBOL\",\"UNKNOWN\",\"getTokenSkipNewline\",\"openParams\",\"closeParams\",\"conditionalLevel\",\"blocks\",\"node\",\"parseAssignment\",\"visible\",\"push\",\"BlockNode\",\"ConstantNode\",\"createError\",\"parseConditional\",\"isSymbolNode\",\"AssignmentNode\",\"SymbolNode\",\"isAccessorNode\",\"object\",\"isFunctionNode\",\"fn\",\"valid\",\"args\",\"forEach\",\"arg\",\"FunctionAssignmentNode\",\"parseLogicalXor\",\"OperatorNode\",\"prev\",\"trueExpr\",\"falseExpr\",\"ConditionalNode\",\"condition\",\"parseLogicalAnd\",\"parseBitwiseOr\",\"parseBitwiseXor\",\"parseBitwiseAnd\",\"parseRelational\",\"params\",\"parseShift\",\"conditionals\",\"operators\",\"cond\",\"RelationalNode\",\"map\",\"c\",\"parseConversion\",\"parseRange\",\"to\",\"parseAddSubtract\",\"RangeNode\",\"parseMultiplyDivide\",\"parseImplicitMultiplication\",\"mod\",\"last\",\"parseRule2\",\"isConstantNode\",\"isOperatorNode\",\"op\",\"parseUnary\",\"tokenStates\",\"pop\",\"not\",\"CustomNode\",\"CONSTANTS\",\"NUMERIC_CONSTANTS\",\"indexOf\",\"numeric\",\"parseAccessors\",\"str\",\"parseDoubleQuotesStringToken\",\"parseSingleQuotesStringToken\",\"row\",\"parseRow\",\"rows\",\"cols\",\"items\",\"r\",\"array\",\"ArrayNode\",\"properties\",\"ObjectNode\",\"numberStr\",\"config\",\"number\",\"ParenthesisNode\",\"types\",\"FunctionNode\",\"AccessorNode\",\"IndexNode\",\"dotNotation\",\"JSON\",\"len\",\"message\",\"error\",\"SyntaxError\",\"typed\",\"string\",\"ArrayMatrix\",\"stringObject\",\"and\",\"xor\",\"or\",\"parse.isAlpha\",\"cPrev\",\"cNext\",\"isValidLatinOrGreek\",\"isValidMathSymbol\",\"parse.isValidLatinOrGreek\",\"test\",\"parse.isValidMathSymbol\",\"high\",\"low\",\"parse.isWhitespace\",\"parse.isDecimalMark\",\"parse.isDigitDot\",\"parse.isDigit\",\"parse.isHexDigit\"]\n}\n"]