["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/ParenthesisNode.js"],"~:js","shadow$provide[266]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createParenthesisNode=void 0;var q=b(14);c=b(25);c=(0,c.factory)(\"ParenthesisNode\",[\"Node\"],function(f){function u(k){if(!(this instanceof u))throw new SyntaxError(\"Constructor must be called with the new operator\");if(!(0,q.isNode)(k))throw new TypeError('Node expected for parameter \"content\"');this.content=k}u.prototype=new f.Node;u.prototype.type=\"ParenthesisNode\";u.prototype.isParenthesisNode=!0;u.prototype._compile=\nfunction(k,t){return this.content._compile(k,t)};u.prototype.getContent=function(){return this.content.getContent()};u.prototype.forEach=function(k){k(this.content,\"content\",this)};u.prototype.map=function(k){k=k(this.content,\"content\",this);return new u(k)};u.prototype.clone=function(){return new u(this.content)};u.prototype._toString=function(k){return!k||k&&!k.parenthesis||k&&\"keep\"===k.parenthesis?\"(\"+this.content.toString(k)+\")\":this.content.toString(k)};u.prototype.toJSON=function(){return{mathjs:\"ParenthesisNode\",\ncontent:this.content}};u.fromJSON=function(k){return new u(k.content)};u.prototype.toHTML=function(k){return!k||k&&!k.parenthesis||k&&\"keep\"===k.parenthesis?'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e(\\x3c/span\\x3e'+this.content.toHTML(k)+'\\x3cspan class\\x3d\"math-parenthesis math-round-parenthesis\"\\x3e)\\x3c/span\\x3e':this.content.toHTML(k)};u.prototype._toTex=function(k){return!k||k&&!k.parenthesis||k&&\"keep\"===k.parenthesis?\"\\\\left(\".concat(this.content.toTex(k),\"\\\\right)\"):\nthis.content.toTex(k)};return u},{isClass:!0,isNode:!0});a.createParenthesisNode=c}","~:source","shadow$provide[266] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParenthesisNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'ParenthesisNode';\nvar dependencies = ['Node'];\nvar createParenthesisNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ParenthesisNode\n   * @extends {Node}\n   * A parenthesis node describes manual parenthesis from the user input\n   * @param {Node} content\n   * @extends {Node}\n   */\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (!(0, _is.isNode)(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n\n    this.content = content;\n  }\n\n  ParenthesisNode.prototype = new Node();\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n  ParenthesisNode.prototype.isParenthesisNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ParenthesisNode.prototype._compile = function (math, argNames) {\n    return this.content._compile(math, argNames);\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} content\n   * @override\n   **/\n\n\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n  /**\n   * Create a new ParenthesisNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ParenthesisNode} Returns a clone of the node\n   */\n\n\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.prototype.clone = function () {\n    return new ParenthesisNode(this.content);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toString = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '(' + this.content.toString(options) + ')';\n    }\n\n    return this.content.toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ParenthesisNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ParenthesisNode',\n      content: this.content\n    };\n  };\n  /**\n   * Instantiate an ParenthesisNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.fromJSON = function (json) {\n    return new ParenthesisNode(json.content);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype.toHTML = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return this.content.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toTex = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\n    }\n\n    return this.content.toTex(options);\n  };\n\n  return ParenthesisNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createParenthesisNode = createParenthesisNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","forEach","fromJSON","isClass","toHTML","prototype","_toString","isNode","_toTex","isParenthesisNode","__esModule","createParenthesisNode","value","content","mathjs","type","clone","_compile","getContent","toJSON"]],"~:compiled-at",1619135723968,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$ParenthesisNode.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/ParenthesisNode.js\"],\n\"sourcesContent\":[\"shadow$provide[266] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createParenthesisNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'ParenthesisNode';\\nvar dependencies = ['Node'];\\nvar createParenthesisNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Node = _ref.Node;\\n\\n  /**\\n   * @constructor ParenthesisNode\\n   * @extends {Node}\\n   * A parenthesis node describes manual parenthesis from the user input\\n   * @param {Node} content\\n   * @extends {Node}\\n   */\\n  function ParenthesisNode(content) {\\n    if (!(this instanceof ParenthesisNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    } // validate input\\n\\n\\n    if (!(0, _is.isNode)(content)) {\\n      throw new TypeError('Node expected for parameter \\\"content\\\"');\\n    }\\n\\n    this.content = content;\\n  }\\n\\n  ParenthesisNode.prototype = new Node();\\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\\n  ParenthesisNode.prototype.isParenthesisNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  ParenthesisNode.prototype._compile = function (math, argNames) {\\n    return this.content._compile(math, argNames);\\n  };\\n  /**\\n   * Get the content of the current Node.\\n   * @return {Node} content\\n   * @override\\n   **/\\n\\n\\n  ParenthesisNode.prototype.getContent = function () {\\n    return this.content.getContent();\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  ParenthesisNode.prototype.forEach = function (callback) {\\n    callback(this.content, 'content', this);\\n  };\\n  /**\\n   * Create a new ParenthesisNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\\n   * @returns {ParenthesisNode} Returns a clone of the node\\n   */\\n\\n\\n  ParenthesisNode.prototype.map = function (callback) {\\n    var content = callback(this.content, 'content', this);\\n    return new ParenthesisNode(content);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {ParenthesisNode}\\n   */\\n\\n\\n  ParenthesisNode.prototype.clone = function () {\\n    return new ParenthesisNode(this.content);\\n  };\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  ParenthesisNode.prototype._toString = function (options) {\\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\\n      return '(' + this.content.toString(options) + ')';\\n    }\\n\\n    return this.content.toString(options);\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  ParenthesisNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'ParenthesisNode',\\n      content: this.content\\n    };\\n  };\\n  /**\\n   * Instantiate an ParenthesisNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"ParenthesisNode\\\", \\\"content\\\": ...}`,\\n   *                       where mathjs is optional\\n   * @returns {ParenthesisNode}\\n   */\\n\\n\\n  ParenthesisNode.fromJSON = function (json) {\\n    return new ParenthesisNode(json.content);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  ParenthesisNode.prototype.toHTML = function (options) {\\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\\n      return '<span class=\\\"math-parenthesis math-round-parenthesis\\\">(</span>' + this.content.toHTML(options) + '<span class=\\\"math-parenthesis math-round-parenthesis\\\">)</span>';\\n    }\\n\\n    return this.content.toHTML(options);\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   * @override\\n   */\\n\\n\\n  ParenthesisNode.prototype._toTex = function (options) {\\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\\n      return \\\"\\\\\\\\left(\\\".concat(this.content.toTex(options), \\\"\\\\\\\\right)\\\");\\n    }\\n\\n    return this.content.toTex(options);\\n  };\\n\\n  return ParenthesisNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createParenthesisNode = createParenthesisNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createParenthesisNode\",\"_is\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"ParenthesisNode\",\"content\",\"SyntaxError\",\"isNode\",\"TypeError\",\"prototype\",\"Node\",\"type\",\"isParenthesisNode\",\"_compile\",\"ParenthesisNode.prototype._compile\",\"math\",\"argNames\",\"getContent\",\"ParenthesisNode.prototype.getContent\",\"forEach\",\"ParenthesisNode.prototype.forEach\",\"callback\",\"map\",\"ParenthesisNode.prototype.map\",\"clone\",\"ParenthesisNode.prototype.clone\",\"_toString\",\"ParenthesisNode.prototype._toString\",\"options\",\"parenthesis\",\"toString\",\"toJSON\",\"ParenthesisNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"ParenthesisNode.fromJSON\",\"json\",\"toHTML\",\"ParenthesisNode.prototype.toHTML\",\"_toTex\",\"ParenthesisNode.prototype._toTex\",\"concat\",\"toTex\",\"isClass\"]\n}\n"]