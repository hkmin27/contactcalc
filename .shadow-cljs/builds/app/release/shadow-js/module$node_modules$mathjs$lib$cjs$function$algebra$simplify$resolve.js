["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/simplify/resolve.js"],"~:js","shadow$provide[565]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createResolve=void 0;var q=b(14);c=b(25);c=(0,c.factory)(\"resolve\",[\"parse\",\"FunctionNode\",\"OperatorNode\",\"ParenthesisNode\"],function(f){function u(d,l){if(!l)return d;if((0,q.isSymbolNode)(d)){var h=l[d.name];if((0,q.isNode)(h))return u(h,l);if(\"number\"===typeof h)return k(String(h))}else{if((0,q.isOperatorNode)(d))return h=d.args.map(function(n){return u(n,l)}),new p(d.op,d.fn,h,d.implicit);if((0,q.isParenthesisNode)(d))return new g(u(d.content,\nl));if((0,q.isFunctionNode)(d))return h=d.args.map(function(n){return u(n,l)}),new t(d.name,h)}return d}var k=f.parse,t=f.FunctionNode,p=f.OperatorNode,g=f.ParenthesisNode;return u});a.createResolve=c}","~:source","shadow$provide[565] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolve = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'resolve';\nvar dependencies = ['parse', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     simplify.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // \"6\"\n   *\n   * @param {Node} node\n   *     The expression tree to be simplified\n   * @param {Object} scope with variables to be resolved\n   */\n  function resolve(node, scope) {\n    if (!scope) {\n      return node;\n    }\n\n    if ((0, _is.isSymbolNode)(node)) {\n      var value = scope[node.name];\n\n      if ((0, _is.isNode)(value)) {\n        return resolve(value, scope);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      }\n    } else if ((0, _is.isOperatorNode)(node)) {\n      var args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      return new ParenthesisNode(resolve(node.content, scope));\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var _args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n\n      return new FunctionNode(node.name, _args);\n    }\n\n    return node;\n  }\n\n  return resolve;\n});\nexports.createResolve = createResolve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createResolve","__esModule","value"]],"~:compiled-at",1619135724034,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$resolve.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,aAAR,CAAwB,IAAK,EAE7B,KAAIC,EAAMP,CAAA,CAAQ,EAAR,CAENQ,EAAAA,CAAWR,CAAA,CAAQ,EAAR,CAIXM,EAAAA,CAA+B,CAAC,CAAA,CAAGE,CAASC,CAAAA,OAAb,EAFxBC,SAEwB,CADhBC,CAAC,OAADA,CAAU,cAAVA,CAA0B,cAA1BA,CAA0C,iBAA1CA,CACgB,CAA0C,QAAS,CAACC,CAAD,CAAO,CAuB3FC,QAASA,EAAO,CAACC,CAAD,CAAOC,CAAP,CAAc,CAC5B,GAAI,CAACA,CAAL,CACE,MAAOD,EAGT,IAAI,CAAC,CAAA,CAAGP,CAAIS,CAAAA,YAAR,EAAsBF,CAAtB,CAAJ,CAAiC,CAC/B,IAAIT,EAAQU,CAAA,CAAMD,CAAKJ,CAAAA,IAAX,CAEZ,IAAI,CAAC,CAAA,CAAGH,CAAIU,CAAAA,MAAR,EAAgBZ,CAAhB,CAAJ,CACE,MAAOQ,EAAA,CAAQR,CAAR,CAAeU,CAAf,CACF,IAAqB,QAArB,GAAI,MAAOV,EAAX,CACL,MAAOa,EAAA,CAAMC,MAAA,CAAOd,CAAP,CAAN,CANsB,CAAjC,IAQO,CAAA,GAAI,CAAC,CAAA,CAAGE,CAAIa,CAAAA,cAAR,EAAwBN,CAAxB,CAAJ,CAIL,MAHIO,EAGG,CAHIP,CAAKO,CAAAA,IAAKC,CAAAA,GAAV,CAAc,QAAS,CAACC,CAAD,CAAM,CACtC,MAAOV,EAAA,CAAQU,CAAR,CAAaR,CAAb,CAD+B,CAA7B,CAGJ,CAAA,IAAIS,CAAJ,CAAiBV,CAAKW,CAAAA,EAAtB,CAA0BX,CAAKY,CAAAA,EAA/B,CAAmCL,CAAnC,CAAyCP,CAAKa,CAAAA,QAA9C,CACF,IAAI,CAAC,CAAA,CAAGpB,CAAIqB,CAAAA,iBAAR,EAA2Bd,CAA3B,CAAJ,CACL,MAAO,KAAIe,CAAJ,CAAoBhB,CAAA,CAAQC,CAAKgB,CAAAA,OAAb;AAAsBf,CAAtB,CAApB,CACF,IAAI,CAAC,CAAA,CAAGR,CAAIwB,CAAAA,cAAR,EAAwBjB,CAAxB,CAAJ,CAKL,MAJIkB,EAIG,CAJKlB,CAAKO,CAAAA,IAAKC,CAAAA,GAAV,CAAc,QAAS,CAACC,CAAD,CAAM,CACvC,MAAOV,EAAA,CAAQU,CAAR,CAAaR,CAAb,CADgC,CAA7B,CAIL,CAAA,IAAIkB,CAAJ,CAAiBnB,CAAKJ,CAAAA,IAAtB,CAA4BsB,CAA5B,CAZF,CAeP,MAAOlB,EA5BqB,CAvB6D,IACvFI,EAAQN,CAAKM,CAAAA,KAD0E,CAEvFe,EAAerB,CAAKqB,CAAAA,YAFmE,CAGvFT,EAAeZ,CAAKY,CAAAA,YAHmE,CAIvFK,EAAkBjB,CAAKiB,CAAAA,eAkD3B,OAAOhB,EAtDoF,CAA1D,CAwDnCX,EAAQI,CAAAA,aAAR,CAAwBA,CAtEsC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/simplify/resolve.js\"],\n\"sourcesContent\":[\"shadow$provide[565] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createResolve = void 0;\\n\\nvar _is = require(\\\"../../../utils/is.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar name = 'resolve';\\nvar dependencies = ['parse', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var parse = _ref.parse,\\n      FunctionNode = _ref.FunctionNode,\\n      OperatorNode = _ref.OperatorNode,\\n      ParenthesisNode = _ref.ParenthesisNode;\\n\\n  /**\\n   * resolve(expr, scope) replaces variable nodes with their scoped values\\n   *\\n   * Syntax:\\n   *\\n   *     simplify.resolve(expr, scope)\\n   *\\n   * Examples:\\n   *\\n   *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}\\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // \\\"6\\\"\\n   *\\n   * @param {Node} node\\n   *     The expression tree to be simplified\\n   * @param {Object} scope with variables to be resolved\\n   */\\n  function resolve(node, scope) {\\n    if (!scope) {\\n      return node;\\n    }\\n\\n    if ((0, _is.isSymbolNode)(node)) {\\n      var value = scope[node.name];\\n\\n      if ((0, _is.isNode)(value)) {\\n        return resolve(value, scope);\\n      } else if (typeof value === 'number') {\\n        return parse(String(value));\\n      }\\n    } else if ((0, _is.isOperatorNode)(node)) {\\n      var args = node.args.map(function (arg) {\\n        return resolve(arg, scope);\\n      });\\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\\n    } else if ((0, _is.isParenthesisNode)(node)) {\\n      return new ParenthesisNode(resolve(node.content, scope));\\n    } else if ((0, _is.isFunctionNode)(node)) {\\n      var _args = node.args.map(function (arg) {\\n        return resolve(arg, scope);\\n      });\\n\\n      return new FunctionNode(node.name, _args);\\n    }\\n\\n    return node;\\n  }\\n\\n  return resolve;\\n});\\nexports.createResolve = createResolve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createResolve\",\"_is\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"resolve\",\"node\",\"scope\",\"isSymbolNode\",\"isNode\",\"parse\",\"String\",\"isOperatorNode\",\"args\",\"map\",\"arg\",\"OperatorNode\",\"op\",\"fn\",\"implicit\",\"isParenthesisNode\",\"ParenthesisNode\",\"content\",\"isFunctionNode\",\"_args\",\"FunctionNode\"]\n}\n"]