["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/type/matrix/DenseMatrix.js"],"~:js","shadow$provide[36]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createDenseMatrixClass=void 0;var q=b(14),f=b(24),u=b(21),k=b(19),t=b(15),p=b(22);c=b(25);c=(0,c.factory)(\"DenseMatrix\",[\"Matrix\"],function(g){function d(z,w){if(!(this instanceof d))throw new SyntaxError(\"Constructor must be called with the new operator\");if(w&&!(0,q.isString)(w))throw Error(\"Invalid datatype: \"+w);if((0,q.isMatrix)(z))\"DenseMatrix\"===z.type?(this._data=(0,t.clone)(z._data),this._size=(0,t.clone)(z._size)):\n(this._data=z.toArray(),this._size=z.size()),this._datatype=w||z._datatype;else if(z&&(0,q.isArray)(z.data)&&(0,q.isArray)(z.size))this._data=z.data,this._size=z.size,(0,f.validate)(this._data,this._size),this._datatype=w||z.datatype;else{if((0,q.isArray)(z))this._data=C(z),this._size=(0,f.arraySize)(this._data),(0,f.validate)(this._data,this._size);else{if(z)throw new TypeError(\"Unsupported type of data (\"+(0,q.typeOf)(z)+\")\");this._data=[];this._size=[0]}this._datatype=w}}function l(z,w,B,x){var D=\nx===B-1,F=w.dimension(x);return D?F.map(function(E){(0,f.validateIndex)(E,z.length);return z[E]}).valueOf():F.map(function(E){(0,f.validateIndex)(E,z.length);return l(z[E],w,B,x+1)}).valueOf()}function h(z,w,B,x){if(!w||!0!==w.isIndex)throw new TypeError(\"Invalid index\");var D=w.size(),F=w.isScalar();if((0,q.isMatrix)(B)){var E=B.size();B=B.valueOf()}else E=(0,f.arraySize)(B);if(F){if(0!==E.length)throw new TypeError(\"Scalar expected\");z.set(w.min(),B,x)}else{if(D.length<z._size.length)throw new p.DimensionError(D.length,\nz._size.length,\"\\x3c\");if(E.length<D.length){for(var G=F=0;1===D[F]&&1===E[F];)F++;for(;1===D[F];)G++,F++;B=(0,f.unsqueeze)(B,D.length,G,E)}if(!(0,t.deepStrictEqual)(D,E))throw new p.DimensionError(D,E,\"\\x3e\");E=w.max().map(function(I){return I+1});v(z,E,x);n(z._data,w,B,D.length,0)}return z}function n(z,w,B,x,D){var F=D===x-1,E=w.dimension(D);F?E.forEach(function(G,I){(0,f.validateIndex)(G);z[G]=B[I[0]]}):E.forEach(function(G,I){(0,f.validateIndex)(G);n(z[G],w,B[I[0]],x,D+1)})}function r(z,w,B){if(0===\nw.length){for(z=z._data;(0,q.isArray)(z);)z=z[0];return z}z._size=w.slice(0);z._data=(0,f.resize)(z._data,z._size,B);return z}function v(z,w,B){for(var x=z._size.slice(0),D=!1;x.length<w.length;)x.push(0),D=!0;for(var F=0,E=w.length;F<E;F++)w[F]>x[F]&&(x[F]=w[F],D=!0);D&&r(z,x,B)}function C(z){for(var w=0,B=z.length;w<B;w++){var x=z[w];(0,q.isArray)(x)?z[w]=C(x):x&&!0===x.isMatrix&&(z[w]=C(x.valueOf()))}return z}d.prototype=new g.Matrix;d.prototype.createDenseMatrix=function(z,w){return new d(z,w)};\nd.prototype.type=\"DenseMatrix\";d.prototype.isDenseMatrix=!0;d.prototype.getDataType=function(){return(0,f.getArrayDataType)(this._data,q.typeOf)};d.prototype.storage=function(){return\"dense\"};d.prototype.datatype=function(){return this._datatype};d.prototype.create=function(z,w){return new d(z,w)};d.prototype.subset=function(z,w,B){switch(arguments.length){case 1:if(!(0,q.isIndex)(z))throw new TypeError(\"Invalid index\");if(z.isScalar())var x=this.get(z.min());else{x=z.size();if(x.length!==this._size.length)throw new p.DimensionError(x.length,\nthis._size.length);for(var D=z.min(),F=z.max(),E=0,G=this._size.length;E<G;E++)(0,f.validateIndex)(D[E],this._size[E]),(0,f.validateIndex)(F[E],this._size[E]);x=new d(l(this._data,z,x.length,0),this._datatype)}return x;case 2:case 3:return h(this,z,w,B);default:throw new SyntaxError(\"Wrong number of arguments\");}};d.prototype.get=function(z){if(!(0,q.isArray)(z))throw new TypeError(\"Array expected\");if(z.length!==this._size.length)throw new p.DimensionError(z.length,this._size.length);for(var w=0;w<\nz.length;w++)(0,f.validateIndex)(z[w],this._size[w]);w=this._data;for(var B=0,x=z.length;B<x;B++){var D=z[B];(0,f.validateIndex)(D,w.length);w=w[D]}return w};d.prototype.set=function(z,w,B){if(!(0,q.isArray)(z))throw new TypeError(\"Array expected\");if(z.length<this._size.length)throw new p.DimensionError(z.length,this._size.length,\"\\x3c\");var x=z.map(function(E){return E+1});v(this,x,B);var D=this._data;B=0;for(x=z.length-1;B<x;B++){var F=z[B];(0,f.validateIndex)(F,D.length);D=D[F]}F=z[z.length-1];\n(0,f.validateIndex)(F,D.length);D[F]=w;return this};d.prototype.resize=function(z,w,B){if(!(0,q.isCollection)(z))throw new TypeError(\"Array or Matrix expected\");z=z.valueOf().map(function(x){return Array.isArray(x)&&1===x.length?x[0]:x});B=B?this.clone():this;return r(B,z,w)};d.prototype.reshape=function(z,w){w=w?this.clone():this;w._data=(0,f.reshape)(w._data,z);var B=w._size.reduce(function(x,D){return x*D});w._size=(0,f.processSizesWildcard)(z,B);return w};d.prototype.clone=function(){return new d({data:(0,\nt.clone)(this._data),size:(0,t.clone)(this._size),datatype:this._datatype})};d.prototype.size=function(){return this._size.slice(0)};d.prototype.map=function(z){var w=this,B=function G(F,E){return(0,q.isArray)(F)?F.map(function(I,L){return G(I,E.concat(L))}):z(F,E,w)}(this._data,[]),x=void 0!==this._datatype?(0,f.getArrayDataType)(B,q.typeOf):void 0;return new d(B,x)};d.prototype.forEach=function(z){var w=this;(function F(x,D){(0,q.isArray)(x)?x.forEach(function(E,G){F(E,D.concat(G))}):z(x,D,w)})(this._data,\n[])};d.prototype.toArray=function(){return(0,t.clone)(this._data)};d.prototype.valueOf=function(){return this._data};d.prototype.format=function(z){return(0,u.format)(this._data,z)};d.prototype.toString=function(){return(0,u.format)(this._data)};d.prototype.toJSON=function(){return{mathjs:\"DenseMatrix\",data:this._data,size:this._size,datatype:this._datatype}};d.prototype.diagonal=function(z){if(z){if((0,q.isBigNumber)(z)&&(z=z.toNumber()),!(0,q.isNumber)(z)||!(0,k.isInteger)(z))throw new TypeError(\"The parameter k must be an integer number\");\n}else z=0;var w=0<z?z:0;z=0>z?-z:0;for(var B=Math.min(this._size[0]-z,this._size[1]-w),x=[],D=0;D<B;D++)x[D]=this._data[D+z][D+w];return new d({data:x,size:[B],datatype:this._datatype})};d.diagonal=function(z,w,B,x){if(!(0,q.isArray)(z))throw new TypeError(\"Array expected, size parameter\");if(2!==z.length)throw Error(\"Only two dimensions matrix are supported\");z=z.map(function(M){(0,q.isBigNumber)(M)&&(M=M.toNumber());if(!(0,q.isNumber)(M)||!(0,k.isInteger)(M)||1>M)throw Error(\"Size values must be positive integers\");\nreturn M});if(B){if((0,q.isBigNumber)(B)&&(B=B.toNumber()),!(0,q.isNumber)(B)||!(0,k.isInteger)(B))throw new TypeError(\"The parameter k must be an integer number\");}else B=0;var D=0<B?B:0;B=0>B?-B:0;var F=z[0],E=z[1],G=Math.min(F-B,E-D);if((0,q.isArray)(w)){if(w.length!==G)throw Error(\"Invalid value array length\");var I=function(M){return w[M]}}else if((0,q.isMatrix)(w)){I=w.size();if(1!==I.length||I[0]!==G)throw Error(\"Invalid matrix length\");I=function(M){return w.get([M])}}else I=function(){return w};\nx||(x=(0,q.isBigNumber)(I(0))?I(0).mul(0):0);var L=[];if(0<z.length)for(L=(0,f.resize)(L,z,x),z=0;z<G;z++)L[z+B][z+D]=I(z);return new d({data:L,size:[F,E]})};d.fromJSON=function(z){return new d(z)};d.prototype.swapRows=function(z,w){if(!((0,q.isNumber)(z)&&(0,k.isInteger)(z)&&(0,q.isNumber)(w)&&(0,k.isInteger)(w)))throw Error(\"Row index must be positive integers\");if(2!==this._size.length)throw Error(\"Only two dimensional matrix is supported\");(0,f.validateIndex)(z,this._size[0]);(0,f.validateIndex)(w,\nthis._size[0]);d._swapRows(z,w,this._data);return this};d._swapRows=function(z,w,B){var x=B[z];B[z]=B[w];B[w]=x};return d},{isClass:!0});a.createDenseMatrixClass=c}","~:source","shadow$provide[36] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDenseMatrixClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _DimensionError = require(\"../../error/DimensionError.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nvar createDenseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if ((0, _is.isMatrix)(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = (0, _object.clone)(data._data);\n        this._size = (0, _object.clone)(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      (0, _array.validate)(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = (0, _array.arraySize)(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      (0, _array.validate)(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Create a new DenseMatrix\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._data, _is.typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      (0, _array.validateIndex)(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    (0, _array.validateIndex)(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n\n  function _get(matrix, index) {\n    if (!(0, _is.isIndex)(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        (0, _array.validateIndex)(min[i], matrix._size[i]);\n        (0, _array.validateIndex)(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if ((0, _is.isMatrix)(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = (0, _array.arraySize)(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[] || Matrix} size The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while ((0, _is.isArray)(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = (0, _array.resize)(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = (0, _array.reshape)(m._data, size);\n\n    var currentLength = m._size.reduce(function (length, size) {\n      return length * size;\n    });\n\n    m._size = (0, _array.processSizesWildcard)(size, currentLength);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: (0, _object.clone)(this._data),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? (0, _array.getArrayDataType)(data, _is.typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return (0, _object.clone)(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return (0, _string.format)(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = (0, _is.isBigNumber)(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = (0, _array.resize)(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if ((0, _is.isArray)(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  }\n\n  return DenseMatrix;\n}, {\n  isClass: true\n});\nexports.createDenseMatrixClass = createDenseMatrixClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$module$node_modules$mathjs$lib$cjs$error$DimensionError","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","subset","forEach","valueOf","getDataType","fromJSON","isClass","prototype","isDenseMatrix","_swapRows","__esModule","storage","_data","diagonal","toString","createDenseMatrix","reshape","_datatype","value","_size","mathjs","type","clone","datatype","create","set","resize","size","toArray","swapRows","data","get","createDenseMatrixClass","format","toJSON"]],"~:compiled-at",1619135723746,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$type$matrix$DenseMatrix.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/type/matrix/DenseMatrix.js\"],\n\"sourcesContent\":[\"shadow$provide[36] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createDenseMatrixClass = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _DimensionError = require(\\\"../../error/DimensionError.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'DenseMatrix';\\nvar dependencies = ['Matrix'];\\nvar createDenseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Matrix = _ref.Matrix;\\n\\n  /**\\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\\n   * @class DenseMatrix\\n   */\\n  function DenseMatrix(data, datatype) {\\n    if (!(this instanceof DenseMatrix)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    if (datatype && !(0, _is.isString)(datatype)) {\\n      throw new Error('Invalid datatype: ' + datatype);\\n    }\\n\\n    if ((0, _is.isMatrix)(data)) {\\n      // check data is a DenseMatrix\\n      if (data.type === 'DenseMatrix') {\\n        // clone data & size\\n        this._data = (0, _object.clone)(data._data);\\n        this._size = (0, _object.clone)(data._size);\\n        this._datatype = datatype || data._datatype;\\n      } else {\\n        // build data from existing matrix\\n        this._data = data.toArray();\\n        this._size = data.size();\\n        this._datatype = datatype || data._datatype;\\n      }\\n    } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {\\n      // initialize fields from JSON representation\\n      this._data = data.data;\\n      this._size = data.size; // verify the dimensions of the array\\n\\n      (0, _array.validate)(this._data, this._size);\\n      this._datatype = datatype || data.datatype;\\n    } else if ((0, _is.isArray)(data)) {\\n      // replace nested Matrices with Arrays\\n      this._data = preprocess(data); // get the dimensions of the array\\n\\n      this._size = (0, _array.arraySize)(this._data); // verify the dimensions of the array, TODO: compute size while processing array\\n\\n      (0, _array.validate)(this._data, this._size); // data type unknown\\n\\n      this._datatype = datatype;\\n    } else if (data) {\\n      // unsupported type\\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\\n    } else {\\n      // nothing provided\\n      this._data = [];\\n      this._size = [0];\\n      this._datatype = datatype;\\n    }\\n  }\\n\\n  DenseMatrix.prototype = new Matrix();\\n  /**\\n   * Create a new DenseMatrix\\n   */\\n\\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\\n    return new DenseMatrix(data, datatype);\\n  };\\n  /**\\n   * Attach type information\\n   */\\n\\n\\n  DenseMatrix.prototype.type = 'DenseMatrix';\\n  DenseMatrix.prototype.isDenseMatrix = true;\\n  /**\\n   * Get the matrix type\\n   *\\n   * Usage:\\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\\n   *\\n   * @memberOf DenseMatrix\\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \\\"mixed\\\"\\n   */\\n\\n  DenseMatrix.prototype.getDataType = function () {\\n    return (0, _array.getArrayDataType)(this._data, _is.typeOf);\\n  };\\n  /**\\n   * Get the storage format used by the matrix.\\n   *\\n   * Usage:\\n   *     const format = matrix.storage()  // retrieve storage format\\n   *\\n   * @memberof DenseMatrix\\n   * @return {string}           The storage format.\\n   */\\n\\n\\n  DenseMatrix.prototype.storage = function () {\\n    return 'dense';\\n  };\\n  /**\\n   * Get the datatype of the data stored in the matrix.\\n   *\\n   * Usage:\\n   *     const format = matrix.datatype()   // retrieve matrix datatype\\n   *\\n   * @memberof DenseMatrix\\n   * @return {string}           The datatype.\\n   */\\n\\n\\n  DenseMatrix.prototype.datatype = function () {\\n    return this._datatype;\\n  };\\n  /**\\n   * Create a new DenseMatrix\\n   * @memberof DenseMatrix\\n   * @param {Array} data\\n   * @param {string} [datatype]\\n   */\\n\\n\\n  DenseMatrix.prototype.create = function (data, datatype) {\\n    return new DenseMatrix(data, datatype);\\n  };\\n  /**\\n   * Get a subset of the matrix, or replace a subset of the matrix.\\n   *\\n   * Usage:\\n   *     const subset = matrix.subset(index)               // retrieve subset\\n   *     const value = matrix.subset(index, replacement)   // replace subset\\n   *\\n   * @memberof DenseMatrix\\n   * @param {Index} index\\n   * @param {Array | Matrix | *} [replacement]\\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\\n   *                                  the matrix is resized. If not provided,\\n   *                                  new matrix elements will be filled with zeros.\\n   */\\n\\n\\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\\n    switch (arguments.length) {\\n      case 1:\\n        return _get(this, index);\\n      // intentional fall through\\n\\n      case 2:\\n      case 3:\\n        return _set(this, index, replacement, defaultValue);\\n\\n      default:\\n        throw new SyntaxError('Wrong number of arguments');\\n    }\\n  };\\n  /**\\n   * Get a single element from the matrix.\\n   * @memberof DenseMatrix\\n   * @param {number[]} index   Zero-based index\\n   * @return {*} value\\n   */\\n\\n\\n  DenseMatrix.prototype.get = function (index) {\\n    if (!(0, _is.isArray)(index)) {\\n      throw new TypeError('Array expected');\\n    }\\n\\n    if (index.length !== this._size.length) {\\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\\n    } // check index\\n\\n\\n    for (var x = 0; x < index.length; x++) {\\n      (0, _array.validateIndex)(index[x], this._size[x]);\\n    }\\n\\n    var data = this._data;\\n\\n    for (var i = 0, ii = index.length; i < ii; i++) {\\n      var indexI = index[i];\\n      (0, _array.validateIndex)(indexI, data.length);\\n      data = data[indexI];\\n    }\\n\\n    return data;\\n  };\\n  /**\\n   * Replace a single element in the matrix.\\n   * @memberof DenseMatrix\\n   * @param {number[]} index   Zero-based index\\n   * @param {*} value\\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\\n   *                                  the matrix is resized. If not provided,\\n   *                                  new matrix elements will be left undefined.\\n   * @return {DenseMatrix} self\\n   */\\n\\n\\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\\n    if (!(0, _is.isArray)(index)) {\\n      throw new TypeError('Array expected');\\n    }\\n\\n    if (index.length < this._size.length) {\\n      throw new _DimensionError.DimensionError(index.length, this._size.length, '<');\\n    }\\n\\n    var i, ii, indexI; // enlarge matrix when needed\\n\\n    var size = index.map(function (i) {\\n      return i + 1;\\n    });\\n\\n    _fit(this, size, defaultValue); // traverse over the dimensions\\n\\n\\n    var data = this._data;\\n\\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\\n      indexI = index[i];\\n      (0, _array.validateIndex)(indexI, data.length);\\n      data = data[indexI];\\n    } // set new value\\n\\n\\n    indexI = index[index.length - 1];\\n    (0, _array.validateIndex)(indexI, data.length);\\n    data[indexI] = value;\\n    return this;\\n  };\\n  /**\\n   * Get a submatrix of this matrix\\n   * @memberof DenseMatrix\\n   * @param {DenseMatrix} matrix\\n   * @param {Index} index   Zero-based index\\n   * @private\\n   */\\n\\n\\n  function _get(matrix, index) {\\n    if (!(0, _is.isIndex)(index)) {\\n      throw new TypeError('Invalid index');\\n    }\\n\\n    var isScalar = index.isScalar();\\n\\n    if (isScalar) {\\n      // return a scalar\\n      return matrix.get(index.min());\\n    } else {\\n      // validate dimensions\\n      var size = index.size();\\n\\n      if (size.length !== matrix._size.length) {\\n        throw new _DimensionError.DimensionError(size.length, matrix._size.length);\\n      } // validate if any of the ranges in the index is out of range\\n\\n\\n      var min = index.min();\\n      var max = index.max();\\n\\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\\n        (0, _array.validateIndex)(min[i], matrix._size[i]);\\n        (0, _array.validateIndex)(max[i], matrix._size[i]);\\n      } // retrieve submatrix\\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\\n\\n\\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\\n    }\\n  }\\n  /**\\n   * Recursively get a submatrix of a multi dimensional matrix.\\n   * Index is not checked for correct number or length of dimensions.\\n   * @memberof DenseMatrix\\n   * @param {Array} data\\n   * @param {Index} index\\n   * @param {number} dims   Total number of dimensions\\n   * @param {number} dim    Current dimension\\n   * @return {Array} submatrix\\n   * @private\\n   */\\n\\n\\n  function _getSubmatrix(data, index, dims, dim) {\\n    var last = dim === dims - 1;\\n    var range = index.dimension(dim);\\n\\n    if (last) {\\n      return range.map(function (i) {\\n        (0, _array.validateIndex)(i, data.length);\\n        return data[i];\\n      }).valueOf();\\n    } else {\\n      return range.map(function (i) {\\n        (0, _array.validateIndex)(i, data.length);\\n        var child = data[i];\\n        return _getSubmatrix(child, index, dims, dim + 1);\\n      }).valueOf();\\n    }\\n  }\\n  /**\\n   * Replace a submatrix in this matrix\\n   * Indexes are zero-based.\\n   * @memberof DenseMatrix\\n   * @param {DenseMatrix} matrix\\n   * @param {Index} index\\n   * @param {DenseMatrix | Array | *} submatrix\\n   * @param {*} defaultValue          Default value, filled in on new entries when\\n   *                                  the matrix is resized.\\n   * @return {DenseMatrix} matrix\\n   * @private\\n   */\\n\\n\\n  function _set(matrix, index, submatrix, defaultValue) {\\n    if (!index || index.isIndex !== true) {\\n      throw new TypeError('Invalid index');\\n    } // get index size and check whether the index contains a single value\\n\\n\\n    var iSize = index.size();\\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\\n\\n    var sSize;\\n\\n    if ((0, _is.isMatrix)(submatrix)) {\\n      sSize = submatrix.size();\\n      submatrix = submatrix.valueOf();\\n    } else {\\n      sSize = (0, _array.arraySize)(submatrix);\\n    }\\n\\n    if (isScalar) {\\n      // set a scalar\\n      // check whether submatrix is a scalar\\n      if (sSize.length !== 0) {\\n        throw new TypeError('Scalar expected');\\n      }\\n\\n      matrix.set(index.min(), submatrix, defaultValue);\\n    } else {\\n      // set a submatrix\\n      // validate dimensions\\n      if (iSize.length < matrix._size.length) {\\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\\n      }\\n\\n      if (sSize.length < iSize.length) {\\n        // calculate number of missing outer dimensions\\n        var i = 0;\\n        var outer = 0;\\n\\n        while (iSize[i] === 1 && sSize[i] === 1) {\\n          i++;\\n        }\\n\\n        while (iSize[i] === 1) {\\n          outer++;\\n          i++;\\n        } // unsqueeze both outer and inner dimensions\\n\\n\\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\\n      } // check whether the size of the submatrix matches the index size\\n\\n\\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\\n      } // enlarge matrix when needed\\n\\n\\n      var size = index.max().map(function (i) {\\n        return i + 1;\\n      });\\n\\n      _fit(matrix, size, defaultValue); // insert the sub matrix\\n\\n\\n      var dims = iSize.length;\\n      var dim = 0;\\n\\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\\n    }\\n\\n    return matrix;\\n  }\\n  /**\\n   * Replace a submatrix of a multi dimensional matrix.\\n   * @memberof DenseMatrix\\n   * @param {Array} data\\n   * @param {Index} index\\n   * @param {Array} submatrix\\n   * @param {number} dims   Total number of dimensions\\n   * @param {number} dim\\n   * @private\\n   */\\n\\n\\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\\n    var last = dim === dims - 1;\\n    var range = index.dimension(dim);\\n\\n    if (last) {\\n      range.forEach(function (dataIndex, subIndex) {\\n        (0, _array.validateIndex)(dataIndex);\\n        data[dataIndex] = submatrix[subIndex[0]];\\n      });\\n    } else {\\n      range.forEach(function (dataIndex, subIndex) {\\n        (0, _array.validateIndex)(dataIndex);\\n\\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\\n      });\\n    }\\n  }\\n  /**\\n   * Resize the matrix to the given size. Returns a copy of the matrix when\\n   * `copy=true`, otherwise return the matrix itself (resize in place).\\n   *\\n   * @memberof DenseMatrix\\n   * @param {number[] || Matrix} size The new size the matrix should have.\\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\\n   *                                  If not provided, the matrix elements will\\n   *                                  be filled with zeros.\\n   * @param {boolean} [copy]          Return a resized copy of the matrix\\n   *\\n   * @return {Matrix}                 The resized matrix\\n   */\\n\\n\\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\\n    // validate arguments\\n    if (!(0, _is.isCollection)(size)) {\\n      throw new TypeError('Array or Matrix expected');\\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\\n\\n\\n    var sizeArray = size.valueOf().map(function (value) {\\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\\n    }); // matrix to resize\\n\\n    var m = copy ? this.clone() : this; // resize matrix\\n\\n    return _resize(m, sizeArray, defaultValue);\\n  };\\n\\n  function _resize(matrix, size, defaultValue) {\\n    // check size\\n    if (size.length === 0) {\\n      // first value in matrix\\n      var v = matrix._data; // go deep\\n\\n      while ((0, _is.isArray)(v)) {\\n        v = v[0];\\n      }\\n\\n      return v;\\n    } // resize matrix\\n\\n\\n    matrix._size = size.slice(0); // copy the array\\n\\n    matrix._data = (0, _array.resize)(matrix._data, matrix._size, defaultValue); // return matrix\\n\\n    return matrix;\\n  }\\n  /**\\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\\n   *\\n   * NOTE: This might be better suited to copy by default, instead of modifying\\n   *       in place. For now, it operates in place to remain consistent with\\n   *       resize().\\n   *\\n   * @memberof DenseMatrix\\n   * @param {number[]} size           The new size the matrix should have.\\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\\n   *\\n   * @return {Matrix}                 The reshaped matrix\\n   */\\n\\n\\n  DenseMatrix.prototype.reshape = function (size, copy) {\\n    var m = copy ? this.clone() : this;\\n    m._data = (0, _array.reshape)(m._data, size);\\n\\n    var currentLength = m._size.reduce(function (length, size) {\\n      return length * size;\\n    });\\n\\n    m._size = (0, _array.processSizesWildcard)(size, currentLength);\\n    return m;\\n  };\\n  /**\\n   * Enlarge the matrix when it is smaller than given size.\\n   * If the matrix is larger or equal sized, nothing is done.\\n   * @memberof DenseMatrix\\n   * @param {DenseMatrix} matrix           The matrix to be resized\\n   * @param {number[]} size\\n   * @param {*} defaultValue          Default value, filled in on new entries.\\n   * @private\\n   */\\n\\n\\n  function _fit(matrix, size, defaultValue) {\\n    var // copy the array\\n    newSize = matrix._size.slice(0);\\n\\n    var changed = false; // add dimensions when needed\\n\\n    while (newSize.length < size.length) {\\n      newSize.push(0);\\n      changed = true;\\n    } // enlarge size when needed\\n\\n\\n    for (var i = 0, ii = size.length; i < ii; i++) {\\n      if (size[i] > newSize[i]) {\\n        newSize[i] = size[i];\\n        changed = true;\\n      }\\n    }\\n\\n    if (changed) {\\n      // resize only when size is changed\\n      _resize(matrix, newSize, defaultValue);\\n    }\\n  }\\n  /**\\n   * Create a clone of the matrix\\n   * @memberof DenseMatrix\\n   * @return {DenseMatrix} clone\\n   */\\n\\n\\n  DenseMatrix.prototype.clone = function () {\\n    var m = new DenseMatrix({\\n      data: (0, _object.clone)(this._data),\\n      size: (0, _object.clone)(this._size),\\n      datatype: this._datatype\\n    });\\n    return m;\\n  };\\n  /**\\n   * Retrieve the size of the matrix.\\n   * @memberof DenseMatrix\\n   * @returns {number[]} size\\n   */\\n\\n\\n  DenseMatrix.prototype.size = function () {\\n    return this._size.slice(0); // return a clone of _size\\n  };\\n  /**\\n   * Create a new matrix with the results of the callback function executed on\\n   * each entry of the matrix.\\n   * @memberof DenseMatrix\\n   * @param {Function} callback   The callback function is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Matrix being traversed.\\n   *\\n   * @return {DenseMatrix} matrix\\n   */\\n\\n\\n  DenseMatrix.prototype.map = function (callback) {\\n    // matrix instance\\n    var me = this;\\n\\n    var recurse = function recurse(value, index) {\\n      if ((0, _is.isArray)(value)) {\\n        return value.map(function (child, i) {\\n          return recurse(child, index.concat(i));\\n        });\\n      } else {\\n        return callback(value, index, me);\\n      }\\n    }; // determine the new datatype when the original matrix has datatype defined\\n    // TODO: should be done in matrix constructor instead\\n\\n\\n    var data = recurse(this._data, []);\\n    var datatype = this._datatype !== undefined ? (0, _array.getArrayDataType)(data, _is.typeOf) : undefined;\\n    return new DenseMatrix(data, datatype);\\n  };\\n  /**\\n   * Execute a callback function on each entry of the matrix.\\n   * @memberof DenseMatrix\\n   * @param {Function} callback   The callback function is invoked with three\\n   *                              parameters: the value of the element, the index\\n   *                              of the element, and the Matrix being traversed.\\n   */\\n\\n\\n  DenseMatrix.prototype.forEach = function (callback) {\\n    // matrix instance\\n    var me = this;\\n\\n    var recurse = function recurse(value, index) {\\n      if ((0, _is.isArray)(value)) {\\n        value.forEach(function (child, i) {\\n          recurse(child, index.concat(i));\\n        });\\n      } else {\\n        callback(value, index, me);\\n      }\\n    };\\n\\n    recurse(this._data, []);\\n  };\\n  /**\\n   * Create an Array with a copy of the data of the DenseMatrix\\n   * @memberof DenseMatrix\\n   * @returns {Array} array\\n   */\\n\\n\\n  DenseMatrix.prototype.toArray = function () {\\n    return (0, _object.clone)(this._data);\\n  };\\n  /**\\n   * Get the primitive value of the DenseMatrix: a multidimensional array\\n   * @memberof DenseMatrix\\n   * @returns {Array} array\\n   */\\n\\n\\n  DenseMatrix.prototype.valueOf = function () {\\n    return this._data;\\n  };\\n  /**\\n   * Get a string representation of the matrix, with optional formatting options.\\n   * @memberof DenseMatrix\\n   * @param {Object | number | Function} [options]  Formatting options. See\\n   *                                                lib/utils/number:format for a\\n   *                                                description of the available\\n   *                                                options.\\n   * @returns {string} str\\n   */\\n\\n\\n  DenseMatrix.prototype.format = function (options) {\\n    return (0, _string.format)(this._data, options);\\n  };\\n  /**\\n   * Get a string representation of the matrix\\n   * @memberof DenseMatrix\\n   * @returns {string} str\\n   */\\n\\n\\n  DenseMatrix.prototype.toString = function () {\\n    return (0, _string.format)(this._data);\\n  };\\n  /**\\n   * Get a JSON representation of the matrix\\n   * @memberof DenseMatrix\\n   * @returns {Object}\\n   */\\n\\n\\n  DenseMatrix.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'DenseMatrix',\\n      data: this._data,\\n      size: this._size,\\n      datatype: this._datatype\\n    };\\n  };\\n  /**\\n   * Get the kth Matrix diagonal.\\n   *\\n   * @memberof DenseMatrix\\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\\n   *\\n   * @returns {Matrix}                     The matrix with the diagonal values.\\n   */\\n\\n\\n  DenseMatrix.prototype.diagonal = function (k) {\\n    // validate k if any\\n    if (k) {\\n      // convert BigNumber to a number\\n      if ((0, _is.isBigNumber)(k)) {\\n        k = k.toNumber();\\n      } // is must be an integer\\n\\n\\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\\n        throw new TypeError('The parameter k must be an integer number');\\n      }\\n    } else {\\n      // default value\\n      k = 0;\\n    }\\n\\n    var kSuper = k > 0 ? k : 0;\\n    var kSub = k < 0 ? -k : 0; // rows & columns\\n\\n    var rows = this._size[0];\\n    var columns = this._size[1]; // number diagonal values\\n\\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\\n\\n    var data = []; // loop rows\\n\\n    for (var i = 0; i < n; i++) {\\n      data[i] = this._data[i + kSub][i + kSuper];\\n    } // create DenseMatrix\\n\\n\\n    return new DenseMatrix({\\n      data: data,\\n      size: [n],\\n      datatype: this._datatype\\n    });\\n  };\\n  /**\\n   * Create a diagonal matrix.\\n   *\\n   * @memberof DenseMatrix\\n   * @param {Array} size                     The matrix size.\\n   * @param {number | Matrix | Array } value The values for the diagonal.\\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\\n   * @param {number} [defaultValue]          The default value for non-diagonal\\n   * @param {string} [datatype]              The datatype for the diagonal\\n   *\\n   * @returns {DenseMatrix}\\n   */\\n\\n\\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\\n    if (!(0, _is.isArray)(size)) {\\n      throw new TypeError('Array expected, size parameter');\\n    }\\n\\n    if (size.length !== 2) {\\n      throw new Error('Only two dimensions matrix are supported');\\n    } // map size & validate\\n\\n\\n    size = size.map(function (s) {\\n      // check it is a big number\\n      if ((0, _is.isBigNumber)(s)) {\\n        // convert it\\n        s = s.toNumber();\\n      } // validate arguments\\n\\n\\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\\n        throw new Error('Size values must be positive integers');\\n      }\\n\\n      return s;\\n    }); // validate k if any\\n\\n    if (k) {\\n      // convert BigNumber to a number\\n      if ((0, _is.isBigNumber)(k)) {\\n        k = k.toNumber();\\n      } // is must be an integer\\n\\n\\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\\n        throw new TypeError('The parameter k must be an integer number');\\n      }\\n    } else {\\n      // default value\\n      k = 0;\\n    }\\n\\n    var kSuper = k > 0 ? k : 0;\\n    var kSub = k < 0 ? -k : 0; // rows and columns\\n\\n    var rows = size[0];\\n    var columns = size[1]; // number of non-zero items\\n\\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\\n\\n    var _value; // check value\\n\\n\\n    if ((0, _is.isArray)(value)) {\\n      // validate array\\n      if (value.length !== n) {\\n        // number of values in array must be n\\n        throw new Error('Invalid value array length');\\n      } // define function\\n\\n\\n      _value = function _value(i) {\\n        // return value @ i\\n        return value[i];\\n      };\\n    } else if ((0, _is.isMatrix)(value)) {\\n      // matrix size\\n      var ms = value.size(); // validate matrix\\n\\n      if (ms.length !== 1 || ms[0] !== n) {\\n        // number of values in array must be n\\n        throw new Error('Invalid matrix length');\\n      } // define function\\n\\n\\n      _value = function _value(i) {\\n        // return value @ i\\n        return value.get([i]);\\n      };\\n    } else {\\n      // define function\\n      _value = function _value() {\\n        // return value\\n        return value;\\n      };\\n    } // discover default value if needed\\n\\n\\n    if (!defaultValue) {\\n      // check first value in array\\n      defaultValue = (0, _is.isBigNumber)(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\\n      : 0;\\n    } // empty array\\n\\n\\n    var data = []; // check we need to resize array\\n\\n    if (size.length > 0) {\\n      // resize array\\n      data = (0, _array.resize)(data, size, defaultValue); // fill diagonal\\n\\n      for (var d = 0; d < n; d++) {\\n        data[d + kSub][d + kSuper] = _value(d);\\n      }\\n    } // create DenseMatrix\\n\\n\\n    return new DenseMatrix({\\n      data: data,\\n      size: [rows, columns]\\n    });\\n  };\\n  /**\\n   * Generate a matrix from a JSON object\\n   * @memberof DenseMatrix\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"DenseMatrix\\\", data: [], size: []}`,\\n   *                       where mathjs is optional\\n   * @returns {DenseMatrix}\\n   */\\n\\n\\n  DenseMatrix.fromJSON = function (json) {\\n    return new DenseMatrix(json);\\n  };\\n  /**\\n   * Swap rows i and j in Matrix.\\n   *\\n   * @memberof DenseMatrix\\n   * @param {number} i       Matrix row index 1\\n   * @param {number} j       Matrix row index 2\\n   *\\n   * @return {Matrix}        The matrix reference\\n   */\\n\\n\\n  DenseMatrix.prototype.swapRows = function (i, j) {\\n    // check index\\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\\n      throw new Error('Row index must be positive integers');\\n    } // check dimensions\\n\\n\\n    if (this._size.length !== 2) {\\n      throw new Error('Only two dimensional matrix is supported');\\n    } // validate index\\n\\n\\n    (0, _array.validateIndex)(i, this._size[0]);\\n    (0, _array.validateIndex)(j, this._size[0]); // swap rows\\n\\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\\n\\n\\n    return this;\\n  };\\n  /**\\n   * Swap rows i and j in Dense Matrix data structure.\\n   *\\n   * @param {number} i       Matrix row index 1\\n   * @param {number} j       Matrix row index 2\\n   * @param {Array} data     Matrix data\\n   */\\n\\n\\n  DenseMatrix._swapRows = function (i, j, data) {\\n    // swap values i <-> j\\n    var vi = data[i];\\n    data[i] = data[j];\\n    data[j] = vi;\\n  };\\n  /**\\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\\n   * Matrices. Replaces all nested Matrices with Arrays\\n   * @memberof DenseMatrix\\n   * @param {Array} data\\n   * @return {Array} data\\n   */\\n\\n\\n  function preprocess(data) {\\n    for (var i = 0, ii = data.length; i < ii; i++) {\\n      var elem = data[i];\\n\\n      if ((0, _is.isArray)(elem)) {\\n        data[i] = preprocess(elem);\\n      } else if (elem && elem.isMatrix === true) {\\n        data[i] = preprocess(elem.valueOf());\\n      }\\n    }\\n\\n    return data;\\n  }\\n\\n  return DenseMatrix;\\n}, {\\n  isClass: true\\n});\\nexports.createDenseMatrixClass = createDenseMatrixClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createDenseMatrixClass\",\"_is\",\"_array\",\"_string\",\"_number\",\"_object\",\"_DimensionError\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"DenseMatrix\",\"data\",\"datatype\",\"SyntaxError\",\"isString\",\"Error\",\"isMatrix\",\"type\",\"_data\",\"clone\",\"_size\",\"toArray\",\"size\",\"_datatype\",\"isArray\",\"validate\",\"preprocess\",\"arraySize\",\"TypeError\",\"typeOf\",\"_getSubmatrix\",\"index\",\"dims\",\"dim\",\"last\",\"range\",\"dimension\",\"map\",\"i\",\"validateIndex\",\"length\",\"valueOf\",\"child\",\"_set\",\"matrix\",\"submatrix\",\"defaultValue\",\"isIndex\",\"iSize\",\"isScalar\",\"sSize\",\"set\",\"min\",\"DimensionError\",\"outer\",\"unsqueeze\",\"deepStrictEqual\",\"max\",\"_fit\",\"_setSubmatrix\",\"forEach\",\"dataIndex\",\"subIndex\",\"_resize\",\"v\",\"slice\",\"resize\",\"newSize\",\"changed\",\"push\",\"ii\",\"elem\",\"prototype\",\"Matrix\",\"createDenseMatrix\",\"DenseMatrix.prototype.createDenseMatrix\",\"isDenseMatrix\",\"getDataType\",\"DenseMatrix.prototype.getDataType\",\"getArrayDataType\",\"storage\",\"DenseMatrix.prototype.storage\",\"DenseMatrix.prototype.datatype\",\"create\",\"DenseMatrix.prototype.create\",\"subset\",\"DenseMatrix.prototype.subset\",\"replacement\",\"arguments\",\"get\",\"DenseMatrix.prototype.get\",\"x\",\"indexI\",\"DenseMatrix.prototype.set\",\"DenseMatrix.prototype.resize\",\"copy\",\"isCollection\",\"sizeArray\",\"Array\",\"m\",\"reshape\",\"DenseMatrix.prototype.reshape\",\"currentLength\",\"reduce\",\"processSizesWildcard\",\"DenseMatrix.prototype.clone\",\"DenseMatrix.prototype.size\",\"DenseMatrix.prototype.map\",\"callback\",\"me\",\"recurse\",\"concat\",\"undefined\",\"DenseMatrix.prototype.forEach\",\"DenseMatrix.prototype.toArray\",\"DenseMatrix.prototype.valueOf\",\"format\",\"DenseMatrix.prototype.format\",\"options\",\"toString\",\"DenseMatrix.prototype.toString\",\"toJSON\",\"DenseMatrix.prototype.toJSON\",\"mathjs\",\"diagonal\",\"DenseMatrix.prototype.diagonal\",\"k\",\"isBigNumber\",\"toNumber\",\"isNumber\",\"isInteger\",\"kSuper\",\"kSub\",\"n\",\"Math\",\"rows\",\"columns\",\"DenseMatrix.diagonal\",\"s\",\"_value\",\"ms\",\"mul\",\"d\",\"fromJSON\",\"DenseMatrix.fromJSON\",\"json\",\"swapRows\",\"DenseMatrix.prototype.swapRows\",\"j\",\"_swapRows\",\"DenseMatrix._swapRows\",\"vi\",\"isClass\"]\n}\n"]