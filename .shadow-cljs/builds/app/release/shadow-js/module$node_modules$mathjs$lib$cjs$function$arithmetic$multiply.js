["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/multiply.js"],"~:js","shadow$provide[99]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createMultiply=void 0;c=b(25);var q=b(14),f=b(15),u=b(24),k=b(76),t=b(77);b=(0,c.factory)(\"multiply\",\"typed matrix addScalar multiplyScalar equalScalar dot\".split(\" \"),function(p){function g(x,D){switch(x.length){case 1:switch(D.length){case 1:if(x[0]!==D[0])throw new RangeError(\"Dimension mismatch in multiplication. Vectors must have the same length\");break;case 2:if(x[0]!==D[0])throw new RangeError(\"Dimension mismatch in multiplication. Vector length (\"+\nx[0]+\") must match Matrix rows (\"+D[0]+\")\");break;default:throw Error(\"Can only multiply a 1 or 2 dimensional matrix (Matrix B has \"+D.length+\" dimensions)\");}break;case 2:switch(D.length){case 1:if(x[1]!==D[0])throw new RangeError(\"Dimension mismatch in multiplication. Matrix columns (\"+x[1]+\") must match Vector length (\"+D[0]+\")\");break;case 2:if(x[1]!==D[0])throw new RangeError(\"Dimension mismatch in multiplication. Matrix A columns (\"+x[1]+\") must match Matrix B rows (\"+D[0]+\")\");break;default:throw Error(\"Can only multiply a 1 or 2 dimensional matrix (Matrix B has \"+\nD.length+\" dimensions)\");}break;default:throw Error(\"Can only multiply a 1 or 2 dimensional matrix (Matrix A has \"+x.length+\" dimensions)\");}}var d=p.typed,l=p.matrix,h=p.addScalar,n=p.multiplyScalar,r=p.equalScalar,v=p.dot,C=(0,k.createAlgorithm11)({typed:d,equalScalar:r}),z=(0,t.createAlgorithm14)({typed:d}),w=d(\"_multiplyMatrixVector\",{\"DenseMatrix, any\":function(x,D){var F=x._data,E=x._size,G=x._datatype,I=D._data,L=D._datatype;D=E[0];E=E[1];var M=h,S=n;if(G&&L&&G===L&&\"string\"===typeof G){var P=\nG;M=d.find(h,[P,P]);S=d.find(n,[P,P])}G=[];for(L=0;L<D;L++){for(var R=F[L],ba=S(R[0],I[0]),Q=1;Q<E;Q++)ba=M(ba,S(R[Q],I[Q]));G[L]=ba}return x.createDenseMatrix({data:G,size:[D],datatype:P})},\"SparseMatrix, any\":function(x,D){var F=x._values,E=x._index,G=x._ptr,I=x._datatype;if(!F)throw Error(\"Cannot multiply Pattern only Matrix times Dense Matrix\");var L=D._data,M=D._datatype,S=x._size[0],P=D._size[0];D=[];var R=[],ba=[],Q=h,T=n,Y=r,ca=0;if(I&&M&&I===M&&\"string\"===typeof I){var ka=I;Q=d.find(h,[ka,\nka]);T=d.find(n,[ka,ka]);Y=d.find(r,[ka,ka]);ca=d.convert(0,ka)}I=[];M=[];for(var ha=ba[0]=0;ha<P;ha++){var wa=L[ha];if(!Y(wa,ca))for(var Ia=G[ha+1],Ha=G[ha];Ha<Ia;Ha++){var oa=E[Ha];M[oa]?I[oa]=Q(I[oa],T(wa,F[Ha])):(M[oa]=!0,R.push(oa),I[oa]=T(wa,F[Ha]))}}F=R.length;for(E=0;E<F;E++)D[E]=I[R[E]];ba[1]=R.length;return x.createSparseMatrix({values:D,index:R,ptr:ba,size:[S,1],datatype:ka})}}),B=d(\"_multiplyMatrixMatrix\",{\"DenseMatrix, DenseMatrix\":function(x,D){var F=x._data,E=x._size,G=x._datatype,\nI=D._data,L=D._datatype,M=E[0];E=E[1];D=D._size[1];var S=h,P=n;if(G&&L&&G===L&&\"string\"===typeof G){var R=G;S=d.find(h,[R,R]);P=d.find(n,[R,R])}G=[];for(L=0;L<M;L++){var ba=F[L];G[L]=[];for(var Q=0;Q<D;Q++){for(var T=P(ba[0],I[0][Q]),Y=1;Y<E;Y++)T=S(T,P(ba[Y],I[Y][Q]));G[L][Q]=T}}return x.createDenseMatrix({data:G,size:[M,D],datatype:R})},\"DenseMatrix, SparseMatrix\":function(x,D){var F=x._data,E=x._size,G=x._datatype;x=D._values;var I=D._index,L=D._ptr,M=D._size,S=D._datatype;if(!x)throw Error(\"Cannot multiply Dense Matrix times Pattern only Matrix\");\nE=E[0];M=M[1];var P=h,R=n,ba=r,Q=0;if(G&&S&&G===S&&\"string\"===typeof G){var T=G;P=d.find(h,[T,T]);R=d.find(n,[T,T]);ba=d.find(r,[T,T]);Q=d.convert(0,T)}G=[];S=[];var Y=[];D=D.createSparseMatrix({values:G,index:S,ptr:Y,size:[E,M],datatype:T});for(T=0;T<M;T++){Y[T]=S.length;var ca=L[T],ka=L[T+1];if(ka>ca)for(var ha=0,wa=0;wa<E;wa++){for(var Ia=wa+1,Ha=void 0,oa=ca;oa<ka;oa++){var Ka=I[oa];ha!==Ia?(Ha=R(F[wa][Ka],x[oa]),ha=Ia):Ha=P(Ha,R(F[wa][Ka],x[oa]))}ha!==Ia||ba(Ha,Q)||(S.push(wa),G.push(Ha))}}Y[M]=\nS.length;return D},\"SparseMatrix, DenseMatrix\":function(x,D){var F=x._values,E=x._index,G=x._ptr,I=x._datatype;if(!F)throw Error(\"Cannot multiply Pattern only Matrix times Dense Matrix\");var L=D._data,M=D._datatype,S=x._size[0],P=D._size[0];D=D._size[1];var R=h,ba=n,Q=r,T=0;if(I&&M&&I===M&&\"string\"===typeof I){var Y=I;R=d.find(h,[Y,Y]);ba=d.find(n,[Y,Y]);Q=d.find(r,[Y,Y]);T=d.convert(0,Y)}I=[];M=[];var ca=[];x=x.createSparseMatrix({values:I,index:M,ptr:ca,size:[S,D],datatype:Y});S=[];Y=[];for(var ka=\n0;ka<D;ka++){ca[ka]=M.length;for(var ha=ka+1,wa=0;wa<P;wa++){var Ia=L[wa][ka];if(!Q(Ia,T))for(var Ha=G[wa+1],oa=G[wa];oa<Ha;oa++){var Ka=E[oa];Y[Ka]!==ha?(Y[Ka]=ha,M.push(Ka),S[Ka]=ba(Ia,F[oa])):S[Ka]=R(S[Ka],ba(Ia,F[oa]))}}ha=M.length;for(wa=ca[ka];wa<ha;wa++)I[wa]=S[M[wa]]}ca[D]=M.length;return x},\"SparseMatrix, SparseMatrix\":function(x,D){var F=x._values,E=x._index,G=x._ptr,I=x._datatype,L=D._values,M=D._index,S=D._ptr,P=D._datatype,R=x._size[0];D=D._size[1];var ba=F&&L,Q=h,T=n;if(I&&P&&I===P&&\n\"string\"===typeof I){var Y=I;Q=d.find(h,[Y,Y]);T=d.find(n,[Y,Y])}I=ba?[]:void 0;P=[];var ca=[];x=x.createSparseMatrix({values:I,index:P,ptr:ca,size:[R,D],datatype:Y});R=ba?[]:void 0;Y=[];for(var ka,ha,wa,Ia,Ha,oa=0;oa<D;oa++){ca[oa]=P.length;var Ka=oa+1;wa=S[oa];for(Ia=S[oa+1];wa<Ia;wa++)if(ha=M[wa],ba)for(ka=G[ha],ha=G[ha+1];ka<ha;ka++)Ha=E[ka],Y[Ha]!==Ka?(Y[Ha]=Ka,P.push(Ha),R[Ha]=T(L[wa],F[ka])):R[Ha]=Q(R[Ha],T(L[wa],F[ka]));else for(ka=G[ha],ha=G[ha+1];ka<ha;ka++)Ha=E[ka],Y[Ha]!==Ka&&(Y[Ha]=Ka,\nP.push(Ha));if(ba)for(Ia=P.length,Ka=ca[oa];Ka<Ia;Ka++)I[Ka]=R[P[Ka]]}ca[D]=P.length;return x}});return d(\"multiply\",(0,f.extend)({\"Array, Array\":function(x,D){g((0,u.arraySize)(x),(0,u.arraySize)(D));x=this(l(x),l(D));return(0,q.isMatrix)(x)?x.valueOf():x},\"Matrix, Matrix\":function(x,D){var F=x.size(),E=D.size();g(F,E);if(1===F.length){if(1===E.length){if(0===F[0])throw Error(\"Cannot multiply two empty vectors\");return v(x,D)}if(\"dense\"!==D.storage())throw Error(\"Support for SparseMatrix not implemented\");\nF=x._data;var G=x._datatype;E=D._data;var I=D._datatype,L=x._size[0];D=D._size[1];var M=h,S=n;if(G&&I&&G===I&&\"string\"===typeof G){var P=G;M=d.find(h,[P,P]);S=d.find(n,[P,P])}G=[];for(I=0;I<D;I++){for(var R=S(F[0],E[0][I]),ba=1;ba<L;ba++)R=M(R,S(F[ba],E[ba][I]));G[I]=R}return x.createDenseMatrix({data:G,size:[D],datatype:P})}return 1===E.length?w(x,D):B(x,D)},\"Matrix, Array\":function(x,D){return this(x,l(D))},\"Array, Matrix\":function(x,D){return this(l(x,D.storage()),D)},\"SparseMatrix, any\":function(x,\nD){return C(x,D,n,!1)},\"DenseMatrix, any\":function(x,D){return z(x,D,n,!1)},\"any, SparseMatrix\":function(x,D){return C(D,x,n,!0)},\"any, DenseMatrix\":function(x,D){return z(D,x,n,!0)},\"Array, any\":function(x,D){return z(l(x),D,n,!1).valueOf()},\"any, Array\":function(x,D){return z(l(D),x,n,!0).valueOf()},\"any, any\":n,\"any, any, ...any\":function(x,D,F){x=this(x,D);for(D=0;D<F.length;D++)x=this(x,F[D]);return x}},n.signatures))});a.createMultiply=b}","~:source","shadow$provide[99] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMultiply = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _algorithm = require(\"../../type/matrix/utils/algorithm11.js\");\n\nvar _algorithm2 = require(\"../../type/matrix/utils/algorithm14.js\");\n\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\nvar createMultiply = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      addScalar = _ref.addScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      equalScalar = _ref.equalScalar,\n      dot = _ref.dot;\n  var algorithm11 = (0, _algorithm.createAlgorithm11)({\n    typed: typed,\n    equalScalar: equalScalar\n  });\n  var algorithm14 = (0, _algorithm2.createAlgorithm14)({\n    typed: typed\n  });\n\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n\n            break;\n\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n\n            break;\n\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (N)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {number}             Scalar value\n   */\n\n\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    }\n\n    return dot(a, b);\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Matrix         (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Dense Matrix   (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var alength = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix columns\n\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\n\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n\n      c[j] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {Matrix}             Dense Vector   (M)\n   */\n\n\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Matrix         (NxC)\n   *\n   * @return {Matrix}             Matrix         (MxC)\n   */\n\n\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix  (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             Dense Vector (M)\n   */\n\n\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // sum (do not initialize it with zero)\n\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\n\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n\n      c[i] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            DenseMatrix    (NxC)\n   *\n   * @return {Matrix}             DenseMatrix    (MxC)\n   */\n\n\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // initialize row array\n\n      c[i] = []; // loop matrix b columns\n\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\n\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n\n        c[i][j] = sum;\n      }\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            SparseMatrix   (NxC)\n   *\n   * @return {Matrix}             SparseMatrix   (MxC)\n   */\n\n\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate b matrix\n\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    } // rows & columns\n\n\n    var arows = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // indeces in column jb\n\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\n\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0; // loop a rows\n\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1; // C[i, jb]\n\n          var cij = void 0; // values in b column j\n\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb]; // check value has been initialized\n\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\n\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          } // check column has been processed and value != 0\n\n\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix    (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             SparseMatrix    (M, 1)\n   */\n\n\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0]; // result\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // workspace\n\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // update ptr\n\n    cptr[0] = 0; // rows in b\n\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\n\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka]; // check value exists in current j\n\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true; // add i to pattern of C\n\n            cindex.push(ia); // x(ia) = A\n\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    } // copy values from x to column jb of c\n\n\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p]; // copy value\n\n      cvalues[p] = x[ic];\n    } // update ptr\n\n\n    cptr[1] = cindex.length; // return sparse matrix\n\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            DenseMatrix       (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // rows in jb\n\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\n\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      } // copy values from x to column jb of c\n\n\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p]; // copy value\n\n        cvalues[p] = x[ic];\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            SparseMatrix      (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\n\n    var values = avalues && bvalues; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // variables\n\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // B values & index in j\n\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb]; // check we need to process values\n\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia);\n            }\n          }\n        }\n      } // check we need to process matrix values (pattern matrix)\n\n\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p]; // copy value\n\n          cvalues[p] = x[ic];\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * Multiply two or more values, `x * y`.\n   * For matrices, the matrix product is calculated.\n   *\n   * Syntax:\n   *\n   *    math.multiply(x, y)\n   *    math.multiply(x, y, z, ...)\n   *\n   * Examples:\n   *\n   *    math.multiply(4, 5.2)        // returns number 20.8\n   *    math.multiply(2, 3, 4)       // returns number 24\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    const d = [[1, 2, 3], [3, -4, 7]]\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\n   *\n   *    const e = math.unit('2.1 km')\n   *    math.multiply(3, e)          // returns Unit 6.3 km\n   *\n   * See also:\n   *\n   *    divide, prod, cross, dot\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\n   */\n\n\n  return typed(name, (0, _object.extend)({\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n    'Array, Array': function ArrayArray(x, y) {\n      // check dimensions\n      _validateMatrixDimensions((0, _array.arraySize)(x), (0, _array.arraySize)(y)); // use dense matrix implementation\n\n\n      var m = this(matrix(x), matrix(y)); // return array or scalar\n\n      return (0, _is.isMatrix)(m) ? m.valueOf() : m;\n    },\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size(); // check dimensions\n\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\n\n\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        } // Vector * Matrix\n\n\n        return _multiplyVectorMatrix(x, y);\n      } // process y dimensions\n\n\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      } // Matrix * Matrix\n\n\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use Matrix * Matrix implementation\n      return this(x, matrix(y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use Matrix * Matrix implementation\n      return this(matrix(x, y.storage()), y);\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm11(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, multiplyScalar, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': function anyAnyAny(x, y, rest) {\n      var result = this(x, y);\n\n      for (var i = 0; i < rest.length; i++) {\n        result = this(result, rest[i]);\n      }\n\n      return result;\n    }\n  }, multiplyScalar.signatures));\n});\nexports.createMultiply = createMultiply;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$type$matrix$utils$algorithm14","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$type$matrix$utils$algorithm11","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$object","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["values","typed","index","createMultiply","__esModule","value","equalScalar","datatype","size","ptr","data"]],"~:compiled-at",1619135723783,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$multiply.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/multiply.js\"],\n\"sourcesContent\":[\"shadow$provide[99] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createMultiply = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _object = require(\\\"../../utils/object.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _algorithm = require(\\\"../../type/matrix/utils/algorithm11.js\\\");\\n\\nvar _algorithm2 = require(\\\"../../type/matrix/utils/algorithm14.js\\\");\\n\\nvar name = 'multiply';\\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\\nvar createMultiply = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      addScalar = _ref.addScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      equalScalar = _ref.equalScalar,\\n      dot = _ref.dot;\\n  var algorithm11 = (0, _algorithm.createAlgorithm11)({\\n    typed: typed,\\n    equalScalar: equalScalar\\n  });\\n  var algorithm14 = (0, _algorithm2.createAlgorithm14)({\\n    typed: typed\\n  });\\n\\n  function _validateMatrixDimensions(size1, size2) {\\n    // check left operand dimensions\\n    switch (size1.length) {\\n      case 1:\\n        // check size2\\n        switch (size2.length) {\\n          case 1:\\n            // Vector x Vector\\n            if (size1[0] !== size2[0]) {\\n              // throw error\\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\\n            }\\n\\n            break;\\n\\n          case 2:\\n            // Vector x Matrix\\n            if (size1[0] !== size2[0]) {\\n              // throw error\\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\\n            }\\n\\n            break;\\n\\n          default:\\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\\n        }\\n\\n        break;\\n\\n      case 2:\\n        // check size2\\n        switch (size2.length) {\\n          case 1:\\n            // Matrix x Vector\\n            if (size1[1] !== size2[0]) {\\n              // throw error\\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\\n            }\\n\\n            break;\\n\\n          case 2:\\n            // Matrix x Matrix\\n            if (size1[1] !== size2[0]) {\\n              // throw error\\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\\n            }\\n\\n            break;\\n\\n          default:\\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\\n        }\\n\\n        break;\\n\\n      default:\\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\\n    }\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            Dense Vector   (N)\\n   * @param {Matrix} b            Dense Vector   (N)\\n   *\\n   * @return {number}             Scalar value\\n   */\\n\\n\\n  function _multiplyVectorVector(a, b, n) {\\n    // check empty vector\\n    if (n === 0) {\\n      throw new Error('Cannot multiply two empty vectors');\\n    }\\n\\n    return dot(a, b);\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            Dense Vector   (M)\\n   * @param {Matrix} b            Matrix         (MxN)\\n   *\\n   * @return {Matrix}             Dense Vector   (N)\\n   */\\n\\n\\n  function _multiplyVectorMatrix(a, b) {\\n    // process storage\\n    if (b.storage() !== 'dense') {\\n      throw new Error('Support for SparseMatrix not implemented');\\n    }\\n\\n    return _multiplyVectorDenseMatrix(a, b);\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            Dense Vector   (M)\\n   * @param {Matrix} b            Dense Matrix   (MxN)\\n   *\\n   * @return {Matrix}             Dense Vector   (N)\\n   */\\n\\n\\n  function _multiplyVectorDenseMatrix(a, b) {\\n    // a dense\\n    var adata = a._data;\\n    var asize = a._size;\\n    var adt = a._datatype; // b dense\\n\\n    var bdata = b._data;\\n    var bsize = b._size;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var alength = asize[0];\\n    var bcolumns = bsize[1]; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n    } // result\\n\\n\\n    var c = []; // loop matrix columns\\n\\n    for (var j = 0; j < bcolumns; j++) {\\n      // sum (do not initialize it with zero)\\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\\n\\n      for (var i = 1; i < alength; i++) {\\n        // multiply & accumulate\\n        sum = af(sum, mf(adata[i], bdata[i][j]));\\n      }\\n\\n      c[j] = sum;\\n    } // return matrix\\n\\n\\n    return a.createDenseMatrix({\\n      data: c,\\n      size: [bcolumns],\\n      datatype: dt\\n    });\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            Matrix         (MxN)\\n   * @param {Matrix} b            Dense Vector   (N)\\n   *\\n   * @return {Matrix}             Dense Vector   (M)\\n   */\\n\\n\\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\\n    'SparseMatrix, any': _multiplySparseMatrixVector\\n  });\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            Matrix         (MxN)\\n   * @param {Matrix} b            Matrix         (NxC)\\n   *\\n   * @return {Matrix}             Matrix         (MxC)\\n   */\\n\\n\\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\\n  });\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            DenseMatrix  (MxN)\\n   * @param {Matrix} b            Dense Vector (N)\\n   *\\n   * @return {Matrix}             Dense Vector (M)\\n   */\\n\\n\\n  function _multiplyDenseMatrixVector(a, b) {\\n    // a dense\\n    var adata = a._data;\\n    var asize = a._size;\\n    var adt = a._datatype; // b dense\\n\\n    var bdata = b._data;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var arows = asize[0];\\n    var acolumns = asize[1]; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n    } // result\\n\\n\\n    var c = []; // loop matrix a rows\\n\\n    for (var i = 0; i < arows; i++) {\\n      // current row\\n      var row = adata[i]; // sum (do not initialize it with zero)\\n\\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\\n\\n      for (var j = 1; j < acolumns; j++) {\\n        // multiply & accumulate\\n        sum = af(sum, mf(row[j], bdata[j]));\\n      }\\n\\n      c[i] = sum;\\n    } // return matrix\\n\\n\\n    return a.createDenseMatrix({\\n      data: c,\\n      size: [arows],\\n      datatype: dt\\n    });\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            DenseMatrix    (MxN)\\n   * @param {Matrix} b            DenseMatrix    (NxC)\\n   *\\n   * @return {Matrix}             DenseMatrix    (MxC)\\n   */\\n\\n\\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\\n    // a dense\\n    var adata = a._data;\\n    var asize = a._size;\\n    var adt = a._datatype; // b dense\\n\\n    var bdata = b._data;\\n    var bsize = b._size;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var arows = asize[0];\\n    var acolumns = asize[1];\\n    var bcolumns = bsize[1]; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n    } // result\\n\\n\\n    var c = []; // loop matrix a rows\\n\\n    for (var i = 0; i < arows; i++) {\\n      // current row\\n      var row = adata[i]; // initialize row array\\n\\n      c[i] = []; // loop matrix b columns\\n\\n      for (var j = 0; j < bcolumns; j++) {\\n        // sum (avoid initializing sum to zero)\\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\\n\\n        for (var x = 1; x < acolumns; x++) {\\n          // multiply & accumulate\\n          sum = af(sum, mf(row[x], bdata[x][j]));\\n        }\\n\\n        c[i][j] = sum;\\n      }\\n    } // return matrix\\n\\n\\n    return a.createDenseMatrix({\\n      data: c,\\n      size: [arows, bcolumns],\\n      datatype: dt\\n    });\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            DenseMatrix    (MxN)\\n   * @param {Matrix} b            SparseMatrix   (NxC)\\n   *\\n   * @return {Matrix}             SparseMatrix   (MxC)\\n   */\\n\\n\\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\\n    // a dense\\n    var adata = a._data;\\n    var asize = a._size;\\n    var adt = a._datatype; // b sparse\\n\\n    var bvalues = b._values;\\n    var bindex = b._index;\\n    var bptr = b._ptr;\\n    var bsize = b._size;\\n    var bdt = b._datatype; // validate b matrix\\n\\n    if (!bvalues) {\\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\\n    } // rows & columns\\n\\n\\n    var arows = asize[0];\\n    var bcolumns = bsize[1]; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // equalScalar signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, dt);\\n    } // result\\n\\n\\n    var cvalues = [];\\n    var cindex = [];\\n    var cptr = []; // c matrix\\n\\n    var c = b.createSparseMatrix({\\n      values: cvalues,\\n      index: cindex,\\n      ptr: cptr,\\n      size: [arows, bcolumns],\\n      datatype: dt\\n    }); // loop b columns\\n\\n    for (var jb = 0; jb < bcolumns; jb++) {\\n      // update ptr\\n      cptr[jb] = cindex.length; // indeces in column jb\\n\\n      var kb0 = bptr[jb];\\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\\n\\n      if (kb1 > kb0) {\\n        // last row mark processed\\n        var last = 0; // loop a rows\\n\\n        for (var i = 0; i < arows; i++) {\\n          // column mark\\n          var mark = i + 1; // C[i, jb]\\n\\n          var cij = void 0; // values in b column j\\n\\n          for (var kb = kb0; kb < kb1; kb++) {\\n            // row\\n            var ib = bindex[kb]; // check value has been initialized\\n\\n            if (last !== mark) {\\n              // first value in column jb\\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\\n\\n              last = mark;\\n            } else {\\n              // accumulate value\\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\\n            }\\n          } // check column has been processed and value != 0\\n\\n\\n          if (last === mark && !eq(cij, zero)) {\\n            // push row & value\\n            cindex.push(i);\\n            cvalues.push(cij);\\n          }\\n        }\\n      }\\n    } // update ptr\\n\\n\\n    cptr[bcolumns] = cindex.length; // return sparse matrix\\n\\n    return c;\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            SparseMatrix    (MxN)\\n   * @param {Matrix} b            Dense Vector (N)\\n   *\\n   * @return {Matrix}             SparseMatrix    (M, 1)\\n   */\\n\\n\\n  function _multiplySparseMatrixVector(a, b) {\\n    // a sparse\\n    var avalues = a._values;\\n    var aindex = a._index;\\n    var aptr = a._ptr;\\n    var adt = a._datatype; // validate a matrix\\n\\n    if (!avalues) {\\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\\n    } // b dense\\n\\n\\n    var bdata = b._data;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var arows = a._size[0];\\n    var brows = b._size[0]; // result\\n\\n    var cvalues = [];\\n    var cindex = [];\\n    var cptr = []; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // equalScalar signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, dt);\\n    } // workspace\\n\\n\\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\\n\\n    var w = []; // update ptr\\n\\n    cptr[0] = 0; // rows in b\\n\\n    for (var ib = 0; ib < brows; ib++) {\\n      // b[ib]\\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\\n\\n      if (!eq(vbi, zero)) {\\n        // A values & index in ib column\\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\\n          // a row\\n          var ia = aindex[ka]; // check value exists in current j\\n\\n          if (!w[ia]) {\\n            // ia is new entry in j\\n            w[ia] = true; // add i to pattern of C\\n\\n            cindex.push(ia); // x(ia) = A\\n\\n            x[ia] = mf(vbi, avalues[ka]);\\n          } else {\\n            // i exists in C already\\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\\n          }\\n        }\\n      }\\n    } // copy values from x to column jb of c\\n\\n\\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\\n      // row\\n      var ic = cindex[p]; // copy value\\n\\n      cvalues[p] = x[ic];\\n    } // update ptr\\n\\n\\n    cptr[1] = cindex.length; // return sparse matrix\\n\\n    return a.createSparseMatrix({\\n      values: cvalues,\\n      index: cindex,\\n      ptr: cptr,\\n      size: [arows, 1],\\n      datatype: dt\\n    });\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            SparseMatrix      (MxN)\\n   * @param {Matrix} b            DenseMatrix       (NxC)\\n   *\\n   * @return {Matrix}             SparseMatrix      (MxC)\\n   */\\n\\n\\n  function _multiplySparseMatrixDenseMatrix(a, b) {\\n    // a sparse\\n    var avalues = a._values;\\n    var aindex = a._index;\\n    var aptr = a._ptr;\\n    var adt = a._datatype; // validate a matrix\\n\\n    if (!avalues) {\\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\\n    } // b dense\\n\\n\\n    var bdata = b._data;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var arows = a._size[0];\\n    var brows = b._size[0];\\n    var bcolumns = b._size[1]; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // equalScalar signature to use\\n\\n    var eq = equalScalar; // zero value\\n\\n    var zero = 0; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\\n\\n      zero = typed.convert(0, dt);\\n    } // result\\n\\n\\n    var cvalues = [];\\n    var cindex = [];\\n    var cptr = []; // c matrix\\n\\n    var c = a.createSparseMatrix({\\n      values: cvalues,\\n      index: cindex,\\n      ptr: cptr,\\n      size: [arows, bcolumns],\\n      datatype: dt\\n    }); // workspace\\n\\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\\n\\n    var w = []; // loop b columns\\n\\n    for (var jb = 0; jb < bcolumns; jb++) {\\n      // update ptr\\n      cptr[jb] = cindex.length; // mark in workspace for current column\\n\\n      var mark = jb + 1; // rows in jb\\n\\n      for (var ib = 0; ib < brows; ib++) {\\n        // b[ib, jb]\\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\\n\\n        if (!eq(vbij, zero)) {\\n          // A values & index in ib column\\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\\n            // a row\\n            var ia = aindex[ka]; // check value exists in current j\\n\\n            if (w[ia] !== mark) {\\n              // ia is new entry in j\\n              w[ia] = mark; // add i to pattern of C\\n\\n              cindex.push(ia); // x(ia) = A\\n\\n              x[ia] = mf(vbij, avalues[ka]);\\n            } else {\\n              // i exists in C already\\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\\n            }\\n          }\\n        }\\n      } // copy values from x to column jb of c\\n\\n\\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\\n        // row\\n        var ic = cindex[p]; // copy value\\n\\n        cvalues[p] = x[ic];\\n      }\\n    } // update ptr\\n\\n\\n    cptr[bcolumns] = cindex.length; // return sparse matrix\\n\\n    return c;\\n  }\\n  /**\\n   * C = A * B\\n   *\\n   * @param {Matrix} a            SparseMatrix      (MxN)\\n   * @param {Matrix} b            SparseMatrix      (NxC)\\n   *\\n   * @return {Matrix}             SparseMatrix      (MxC)\\n   */\\n\\n\\n  function _multiplySparseMatrixSparseMatrix(a, b) {\\n    // a sparse\\n    var avalues = a._values;\\n    var aindex = a._index;\\n    var aptr = a._ptr;\\n    var adt = a._datatype; // b sparse\\n\\n    var bvalues = b._values;\\n    var bindex = b._index;\\n    var bptr = b._ptr;\\n    var bdt = b._datatype; // rows & columns\\n\\n    var arows = a._size[0];\\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\\n\\n    var values = avalues && bvalues; // datatype\\n\\n    var dt; // addScalar signature to use\\n\\n    var af = addScalar; // multiplyScalar signature to use\\n\\n    var mf = multiplyScalar; // process data types\\n\\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\\n      // datatype\\n      dt = adt; // find signatures that matches (dt, dt)\\n\\n      af = typed.find(addScalar, [dt, dt]);\\n      mf = typed.find(multiplyScalar, [dt, dt]);\\n    } // result\\n\\n\\n    var cvalues = values ? [] : undefined;\\n    var cindex = [];\\n    var cptr = []; // c matrix\\n\\n    var c = a.createSparseMatrix({\\n      values: cvalues,\\n      index: cindex,\\n      ptr: cptr,\\n      size: [arows, bcolumns],\\n      datatype: dt\\n    }); // workspace\\n\\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\\n\\n    var w = []; // variables\\n\\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\\n\\n    for (var jb = 0; jb < bcolumns; jb++) {\\n      // update ptr\\n      cptr[jb] = cindex.length; // mark in workspace for current column\\n\\n      var mark = jb + 1; // B values & index in j\\n\\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\\n        // b row\\n        ib = bindex[kb]; // check we need to process values\\n\\n        if (values) {\\n          // loop values in a[:,ib]\\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\\n            // row\\n            ia = aindex[ka]; // check value exists in current j\\n\\n            if (w[ia] !== mark) {\\n              // ia is new entry in j\\n              w[ia] = mark; // add i to pattern of C\\n\\n              cindex.push(ia); // x(ia) = A\\n\\n              x[ia] = mf(bvalues[kb], avalues[ka]);\\n            } else {\\n              // i exists in C already\\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\\n            }\\n          }\\n        } else {\\n          // loop values in a[:,ib]\\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\\n            // row\\n            ia = aindex[ka]; // check value exists in current j\\n\\n            if (w[ia] !== mark) {\\n              // ia is new entry in j\\n              w[ia] = mark; // add i to pattern of C\\n\\n              cindex.push(ia);\\n            }\\n          }\\n        }\\n      } // check we need to process matrix values (pattern matrix)\\n\\n\\n      if (values) {\\n        // copy values from x to column jb of c\\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\\n          // row\\n          var ic = cindex[p]; // copy value\\n\\n          cvalues[p] = x[ic];\\n        }\\n      }\\n    } // update ptr\\n\\n\\n    cptr[bcolumns] = cindex.length; // return sparse matrix\\n\\n    return c;\\n  }\\n  /**\\n   * Multiply two or more values, `x * y`.\\n   * For matrices, the matrix product is calculated.\\n   *\\n   * Syntax:\\n   *\\n   *    math.multiply(x, y)\\n   *    math.multiply(x, y, z, ...)\\n   *\\n   * Examples:\\n   *\\n   *    math.multiply(4, 5.2)        // returns number 20.8\\n   *    math.multiply(2, 3, 4)       // returns number 24\\n   *\\n   *    const a = math.complex(2, 3)\\n   *    const b = math.complex(4, 1)\\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\\n   *\\n   *    const c = [[1, 2], [4, 3]]\\n   *    const d = [[1, 2, 3], [3, -4, 7]]\\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\\n   *\\n   *    const e = math.unit('2.1 km')\\n   *    math.multiply(3, e)          // returns Unit 6.3 km\\n   *\\n   * See also:\\n   *\\n   *    divide, prod, cross, dot\\n   *\\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\\n   */\\n\\n\\n  return typed(name, (0, _object.extend)({\\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\\n    'Array, Array': function ArrayArray(x, y) {\\n      // check dimensions\\n      _validateMatrixDimensions((0, _array.arraySize)(x), (0, _array.arraySize)(y)); // use dense matrix implementation\\n\\n\\n      var m = this(matrix(x), matrix(y)); // return array or scalar\\n\\n      return (0, _is.isMatrix)(m) ? m.valueOf() : m;\\n    },\\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\\n      // dimensions\\n      var xsize = x.size();\\n      var ysize = y.size(); // check dimensions\\n\\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\\n\\n\\n      if (xsize.length === 1) {\\n        // process y dimensions\\n        if (ysize.length === 1) {\\n          // Vector * Vector\\n          return _multiplyVectorVector(x, y, xsize[0]);\\n        } // Vector * Matrix\\n\\n\\n        return _multiplyVectorMatrix(x, y);\\n      } // process y dimensions\\n\\n\\n      if (ysize.length === 1) {\\n        // Matrix * Vector\\n        return _multiplyMatrixVector(x, y);\\n      } // Matrix * Matrix\\n\\n\\n      return _multiplyMatrixMatrix(x, y);\\n    },\\n    'Matrix, Array': function MatrixArray(x, y) {\\n      // use Matrix * Matrix implementation\\n      return this(x, matrix(y));\\n    },\\n    'Array, Matrix': function ArrayMatrix(x, y) {\\n      // use Matrix * Matrix implementation\\n      return this(matrix(x, y.storage()), y);\\n    },\\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\\n      return algorithm11(x, y, multiplyScalar, false);\\n    },\\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\\n      return algorithm14(x, y, multiplyScalar, false);\\n    },\\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\\n      return algorithm11(y, x, multiplyScalar, true);\\n    },\\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\\n      return algorithm14(y, x, multiplyScalar, true);\\n    },\\n    'Array, any': function ArrayAny(x, y) {\\n      // use matrix implementation\\n      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();\\n    },\\n    'any, Array': function anyArray(x, y) {\\n      // use matrix implementation\\n      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();\\n    },\\n    'any, any': multiplyScalar,\\n    'any, any, ...any': function anyAnyAny(x, y, rest) {\\n      var result = this(x, y);\\n\\n      for (var i = 0; i < rest.length; i++) {\\n        result = this(result, rest[i]);\\n      }\\n\\n      return result;\\n    }\\n  }, multiplyScalar.signatures));\\n});\\nexports.createMultiply = createMultiply;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createMultiply\",\"_factory\",\"_is\",\"_object\",\"_array\",\"_algorithm\",\"_algorithm2\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_validateMatrixDimensions\",\"size1\",\"size2\",\"length\",\"RangeError\",\"Error\",\"typed\",\"matrix\",\"addScalar\",\"multiplyScalar\",\"equalScalar\",\"dot\",\"algorithm11\",\"createAlgorithm11\",\"algorithm14\",\"createAlgorithm14\",\"_multiplyMatrixVector\",\"_multiplyDenseMatrixVector\",\"a\",\"b\",\"adata\",\"_data\",\"asize\",\"_size\",\"adt\",\"_datatype\",\"bdata\",\"bdt\",\"arows\",\"acolumns\",\"af\",\"mf\",\"dt\",\"find\",\"c\",\"i\",\"row\",\"sum\",\"j\",\"createDenseMatrix\",\"data\",\"size\",\"datatype\",\"_multiplySparseMatrixVector\",\"avalues\",\"_values\",\"aindex\",\"_index\",\"aptr\",\"_ptr\",\"brows\",\"cvalues\",\"cindex\",\"cptr\",\"eq\",\"zero\",\"convert\",\"x\",\"w\",\"ib\",\"vbi\",\"ka1\",\"ka\",\"ka0\",\"ia\",\"push\",\"p1\",\"p\",\"ic\",\"createSparseMatrix\",\"values\",\"index\",\"ptr\",\"_multiplyMatrixMatrix\",\"_multiplyDenseMatrixDenseMatrix\",\"bcolumns\",\"_multiplyDenseMatrixSparseMatrix\",\"bvalues\",\"bindex\",\"bptr\",\"bsize\",\"jb\",\"kb0\",\"kb1\",\"last\",\"mark\",\"cij\",\"kb\",\"_multiplySparseMatrixDenseMatrix\",\"vbij\",\"p0\",\"_multiplySparseMatrixSparseMatrix\",\"undefined\",\"extend\",\"ArrayArray\",\"y\",\"arraySize\",\"m\",\"isMatrix\",\"valueOf\",\"MatrixMatrix\",\"xsize\",\"ysize\",\"n\",\"storage\",\"alength\",\"MatrixArray\",\"ArrayMatrix\",\"SparseMatrixAny\",\"DenseMatrixAny\",\"anySparseMatrix\",\"anyDenseMatrix\",\"ArrayAny\",\"anyArray\",\"anyAnyAny\",\"rest\",\"result\",\"signatures\"]\n}\n"]