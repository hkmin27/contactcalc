["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/utils/function.js"],"~:js","shadow$provide[127]=function(c,b,y,a){function q(u){\"@babel/helpers - typeof\";q=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(k){return typeof k}:function(k){return k&&\"function\"===typeof Symbol&&k.constructor===Symbol&&k!==Symbol.prototype?\"symbol\":typeof k};return q(u)}Object.defineProperty(a,\"__esModule\",{value:!0});a.memoize=function(u){var k=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},t=k.hasher,p=k.limit;p=null==p?Number.POSITIVE_INFINITY:p;t=null==t?JSON.stringify:\nt;return function d(){\"object\"!==q(d.cache)&&(d.cache={values:new Map,lru:(0,f.lruQueue)(p||Number.POSITIVE_INFINITY)});for(var l=[],h=0;h<arguments.length;h++)l[h]=arguments[h];h=t(l);if(d.cache.values.has(h))return d.cache.lru.hit(h),d.cache.values.get(h);l=u.apply(u,l);d.cache.values.set(h,l);d.cache.values[\"delete\"](d.cache.lru.hit(h));return l}};a.memoizeCompare=function(u,k){var t=function g(){for(var d=[],l=0;l<arguments.length;l++)d[l]=arguments[l];for(l=0;l<g.cache.length;l++){var h=g.cache[l];\nif(k(d,h.args))return h.res}l=u.apply(u,d);g.cache.unshift({args:d,res:l});return l};t.cache=[];return t};a.maxArgumentCount=function(u){return Object.keys(u.signatures||{}).reduce(function(k,t){t=(t.match(/,/g)||[]).length+1;return Math.max(k,t)},-1)};var f=b(126)}","~:source","shadow$provide[127] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = memoize;\nexports.memoizeCompare = memoizeCompare;\nexports.maxArgumentCount = maxArgumentCount;\n\nvar _lruQueue = require(\"./lruQueue.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {Object} [options]\n * @param {function(args: Array): string} [options.hasher]\n *    A custom hash builder. Is JSON.stringify by default.\n * @param {number | undefined} [options.limit]\n *    Maximum number of values that may be cached. Undefined indicates\n *    unlimited (default)\n * @return {function}                       Returns the memoized function\n */\nfunction memoize(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      hasher = _ref.hasher,\n      limit = _ref.limit;\n\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\n  hasher = hasher == null ? JSON.stringify : hasher;\n  return function memoize() {\n    if (_typeof(memoize.cache) !== 'object') {\n      memoize.cache = {\n        values: new Map(),\n        lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)\n      };\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher(args);\n\n    if (memoize.cache.values.has(hash)) {\n      memoize.cache.lru.hit(hash);\n      return memoize.cache.values.get(hash);\n    }\n\n    var newVal = fn.apply(fn, args);\n    memoize.cache.values.set(hash, newVal);\n    memoize.cache.values[\"delete\"](memoize.cache.lru.hit(hash));\n    return newVal;\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\n\nfunction memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\n\nfunction maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$lruQueue"]],"~:properties",["^5",["values","res","args","__esModule","lru","memoizeCompare","cache","value","maxArgumentCount","memoize"]],"~:compiled-at",1619135723804,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$utils$function.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/utils/function.js\"],\n\"sourcesContent\":[\"shadow$provide[127] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.memoize = memoize;\\nexports.memoizeCompare = memoizeCompare;\\nexports.maxArgumentCount = maxArgumentCount;\\n\\nvar _lruQueue = require(\\\"./lruQueue.js\\\");\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * Memoize a given function by caching the computed result.\\n * The cache of a memoized function can be cleared by deleting the `cache`\\n * property of the function.\\n *\\n * @param {function} fn                     The function to be memoized.\\n *                                          Must be a pure function.\\n * @param {Object} [options]\\n * @param {function(args: Array): string} [options.hasher]\\n *    A custom hash builder. Is JSON.stringify by default.\\n * @param {number | undefined} [options.limit]\\n *    Maximum number of values that may be cached. Undefined indicates\\n *    unlimited (default)\\n * @return {function}                       Returns the memoized function\\n */\\nfunction memoize(fn) {\\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\\n      hasher = _ref.hasher,\\n      limit = _ref.limit;\\n\\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\\n  hasher = hasher == null ? JSON.stringify : hasher;\\n  return function memoize() {\\n    if (_typeof(memoize.cache) !== 'object') {\\n      memoize.cache = {\\n        values: new Map(),\\n        lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)\\n      };\\n    }\\n\\n    var args = [];\\n\\n    for (var i = 0; i < arguments.length; i++) {\\n      args[i] = arguments[i];\\n    }\\n\\n    var hash = hasher(args);\\n\\n    if (memoize.cache.values.has(hash)) {\\n      memoize.cache.lru.hit(hash);\\n      return memoize.cache.values.get(hash);\\n    }\\n\\n    var newVal = fn.apply(fn, args);\\n    memoize.cache.values.set(hash, newVal);\\n    memoize.cache.values[\\\"delete\\\"](memoize.cache.lru.hit(hash));\\n    return newVal;\\n  };\\n}\\n/**\\n * Memoize a given function by caching all results and the arguments,\\n * and comparing against the arguments of previous results before\\n * executing again.\\n * This is less performant than `memoize` which calculates a hash,\\n * which is very fast to compare. Use `memoizeCompare` only when it is\\n * not possible to create a unique serializable hash from the function\\n * arguments.\\n * The isEqual function must compare two sets of arguments\\n * and return true when equal (can be a deep equality check for example).\\n * @param {function} fn\\n * @param {function(a: *, b: *) : boolean} isEqual\\n * @returns {function}\\n */\\n\\n\\nfunction memoizeCompare(fn, isEqual) {\\n  var memoize = function memoize() {\\n    var args = [];\\n\\n    for (var i = 0; i < arguments.length; i++) {\\n      args[i] = arguments[i];\\n    }\\n\\n    for (var c = 0; c < memoize.cache.length; c++) {\\n      var cached = memoize.cache[c];\\n\\n      if (isEqual(args, cached.args)) {\\n        // TODO: move this cache entry to the top so recently used entries move up?\\n        return cached.res;\\n      }\\n    }\\n\\n    var res = fn.apply(fn, args);\\n    memoize.cache.unshift({\\n      args: args,\\n      res: res\\n    });\\n    return res;\\n  };\\n\\n  memoize.cache = [];\\n  return memoize;\\n}\\n/**\\n * Find the maximum number of arguments expected by a typed function.\\n * @param {function} fn   A typed function\\n * @return {number} Returns the maximum number of expected arguments.\\n *                  Returns -1 when no signatures where found on the function.\\n */\\n\\n\\nfunction maxArgumentCount(fn) {\\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\\n    var count = (signature.match(/,/g) || []).length + 1;\\n    return Math.max(args, count);\\n  }, -1);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"Object\",\"defineProperty\",\"value\",\"memoize\",\"fn\",\"_ref\",\"arguments\",\"length\",\"undefined\",\"hasher\",\"limit\",\"Number\",\"POSITIVE_INFINITY\",\"JSON\",\"stringify\",\"cache\",\"values\",\"Map\",\"lru\",\"_lruQueue\",\"lruQueue\",\"args\",\"i\",\"hash\",\"has\",\"hit\",\"get\",\"newVal\",\"apply\",\"set\",\"memoizeCompare\",\"isEqual\",\"c\",\"cached\",\"res\",\"unshift\",\"maxArgumentCount\",\"keys\",\"signatures\",\"reduce\",\"signature\",\"count\",\"match\",\"Math\",\"max\"]\n}\n"]