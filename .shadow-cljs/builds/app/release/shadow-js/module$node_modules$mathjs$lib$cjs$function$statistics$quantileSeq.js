["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js"],"~:js","shadow$provide[535]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createQuantileSeq=void 0;var q=b(14),f=b(19),u=b(24);c=b(25);c=(0,c.factory)(\"quantileSeq\",[\"typed\",\"add\",\"multiply\",\"partitionSelect\",\"compare\"],function(k){function t(r,v,C){r=(0,u.flatten)(r);var z=r.length;if(0===z)throw Error(\"Cannot calculate quantile of an empty sequence\");if((0,q.isNumber)(v)){z=v*(z-1);v=z%1;if(0===v)return r=C?r[z]:l(r,z),n(r),r;z=Math.floor(z);if(C){C=r[z];var w=r[z+1]}else{w=l(r,z+\n1);C=r[z];for(var B=0;B<z;++B)0<h(r[B],C)&&(C=r[B])}n(C);n(w);return g(d(C,1-v),d(w,v))}v=v.times(z-1);if(v.isInteger())return v=v.toNumber(),r=C?r[v]:l(r,v),n(r),r;z=v.floor();v=v.minus(z);z=z.toNumber();if(C)C=r[z],w=r[z+1];else for(w=l(r,z+1),C=r[z],B=0;B<z;++B)0<h(r[B],C)&&(C=r[B]);n(C);n(w);r=new v.constructor(1);return g(d(C,r.minus(v)),d(w,v))}var p=k.typed,g=k.add,d=k.multiply,l=k.partitionSelect,h=k.compare,n=p({\"number | BigNumber | Unit\":function(r){return r}});return function(r,v,C){var z;\nif(2>arguments.length||3<arguments.length)throw new SyntaxError(\"Function quantileSeq requires two or three parameters\");if((0,q.isCollection)(r)&&(C=C||!1,\"boolean\"===typeof C)){var w=r.valueOf();if((0,q.isNumber)(v)){if(0>v)throw Error(\"N/prob must be non-negative\");if(1>=v)return t(w,v,C);if(1<v){if(!(0,f.isInteger)(v))throw Error(\"N must be a positive integer\");var B=v+1;var x=Array(v);for(z=0;z<v;)x[z]=t(w,++z/B,C);return x}}if((0,q.isBigNumber)(v)){B=v.constructor;if(v.isNegative())throw Error(\"N/prob must be non-negative\");\nz=new B(1);if(v.lte(z))return new B(t(w,v,C));if(v.gt(z)){if(!v.isInteger())throw Error(\"N must be a positive integer\");z=v.toNumber();if(4294967295<z)throw Error(\"N must be less than or equal to 2^32-1, as that is the maximum length of an Array\");var D=new B(z+1);x=Array(z);for(var F=0;F<z;)x[F]=new B(t(w,(new B(++F)).div(D),C));return x}}if(Array.isArray(v)){x=Array(v.length);for(B=0;B<x.length;++B){D=v[B];if((0,q.isNumber)(D)){if(0>D||1<D)throw Error(\"Probability must be between 0 and 1, inclusive\");\n}else if((0,q.isBigNumber)(D)){if(z=new D.constructor(1),D.isNegative()||D.gt(z))throw Error(\"Probability must be between 0 and 1, inclusive\");}else throw new TypeError(\"Unexpected type of argument in function quantileSeq\");x[B]=t(w,D,C)}return x}}throw new TypeError(\"Unexpected type of argument in function quantileSeq\");}});a.createQuantileSeq=c}","~:source","shadow$provide[535] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQuantileSeq = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];\nvar createQuantileSeq = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      partitionSelect = _ref.partitionSelect,\n      compare = _ref.compare;\n\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n\n    if ((0, _is.isCollection)(data)) {\n      sorted = sorted || false;\n\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n\n        if ((0, _is.isNumber)(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!(0, _number.isInteger)(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n\n            return probArr;\n          }\n        }\n\n        if ((0, _is.isBigNumber)(probOrN)) {\n          var BigNumber = probOrN.constructor;\n\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          one = new BigNumber(1);\n\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n\n            var intN = probOrN.toNumber();\n\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n\n            var _nPlusOne = new BigNumber(intN + 1);\n\n            probArr = new Array(intN);\n\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n\n            return probArr;\n          }\n        }\n\n        if (Array.isArray(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          probArr = new Array(probOrN.length);\n\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrN[_i2];\n\n            if ((0, _is.isNumber)(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if ((0, _is.isBigNumber)(currProb)) {\n              one = new currProb.constructor(1);\n\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n\n          return probArr;\n        }\n\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = (0, _array.flatten)(array);\n    var len = flat.length;\n\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n\n    if ((0, _is.isNumber)(prob)) {\n      var _index = prob * (len - 1);\n\n      var _fracPart = _index % 1;\n\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n\n      var _integerPart = Math.floor(_index);\n\n      var _left;\n\n      var _right;\n\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n\n    var index = prob.times(len - 1);\n\n    if (index.isInteger()) {\n      index = index.toNumber();\n\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n\n      validate(_value);\n      return _value;\n    }\n\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return quantileSeq;\n});\nexports.createQuantileSeq = createQuantileSeq;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$number","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["createQuantileSeq","__esModule","value"]],"~:compiled-at",1619135724024,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$statistics$quantileSeq.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js\"],\n\"sourcesContent\":[\"shadow$provide[535] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createQuantileSeq = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _number = require(\\\"../../utils/number.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'quantileSeq';\\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];\\nvar createQuantileSeq = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      add = _ref.add,\\n      multiply = _ref.multiply,\\n      partitionSelect = _ref.partitionSelect,\\n      compare = _ref.compare;\\n\\n  /**\\n   * Compute the prob order quantile of a matrix or a list with values.\\n   * The sequence is sorted and the middle value is returned.\\n   * Supported types of sequence values are: Number, BigNumber, Unit\\n   * Supported types of probability are: Number, BigNumber\\n   *\\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\\n   * of all elements will be calculated.\\n   *\\n   * Syntax:\\n   *\\n   *     math.quantileSeq(A, prob[, sorted])\\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\\n   *     math.quantileSeq(A, N[, sorted])\\n   *\\n   * Examples:\\n   *\\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\\n   *\\n   * See also:\\n   *\\n   *     median, mean, min, max, sum, prod, std, variance\\n   *\\n   * @param {Array, Matrix} data                A single matrix or Array\\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\\n   *                                            the amount of evenly distributed steps of\\n   *                                            probabilities; only one of these options can\\n   *                                            be provided\\n   * @param {Boolean} sorted=false              is data sorted in ascending order\\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\\n   */\\n  function quantileSeq(data, probOrN, sorted) {\\n    var probArr, dataArr, one;\\n\\n    if (arguments.length < 2 || arguments.length > 3) {\\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\\n    }\\n\\n    if ((0, _is.isCollection)(data)) {\\n      sorted = sorted || false;\\n\\n      if (typeof sorted === 'boolean') {\\n        dataArr = data.valueOf();\\n\\n        if ((0, _is.isNumber)(probOrN)) {\\n          if (probOrN < 0) {\\n            throw new Error('N/prob must be non-negative');\\n          }\\n\\n          if (probOrN <= 1) {\\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\\n            return _quantileSeq(dataArr, probOrN, sorted);\\n          }\\n\\n          if (probOrN > 1) {\\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\\n            if (!(0, _number.isInteger)(probOrN)) {\\n              throw new Error('N must be a positive integer');\\n            }\\n\\n            var nPlusOne = probOrN + 1;\\n            probArr = new Array(probOrN);\\n\\n            for (var i = 0; i < probOrN;) {\\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\\n            }\\n\\n            return probArr;\\n          }\\n        }\\n\\n        if ((0, _is.isBigNumber)(probOrN)) {\\n          var BigNumber = probOrN.constructor;\\n\\n          if (probOrN.isNegative()) {\\n            throw new Error('N/prob must be non-negative');\\n          }\\n\\n          one = new BigNumber(1);\\n\\n          if (probOrN.lte(one)) {\\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\\n          }\\n\\n          if (probOrN.gt(one)) {\\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\\n            if (!probOrN.isInteger()) {\\n              throw new Error('N must be a positive integer');\\n            } // largest possible Array length is 2^32-1\\n            // 2^32 < 10^15, thus safe conversion guaranteed\\n\\n\\n            var intN = probOrN.toNumber();\\n\\n            if (intN > 4294967295) {\\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\\n            }\\n\\n            var _nPlusOne = new BigNumber(intN + 1);\\n\\n            probArr = new Array(intN);\\n\\n            for (var _i = 0; _i < intN;) {\\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\\n            }\\n\\n            return probArr;\\n          }\\n        }\\n\\n        if (Array.isArray(probOrN)) {\\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\\n          probArr = new Array(probOrN.length);\\n\\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\\n            var currProb = probOrN[_i2];\\n\\n            if ((0, _is.isNumber)(currProb)) {\\n              if (currProb < 0 || currProb > 1) {\\n                throw new Error('Probability must be between 0 and 1, inclusive');\\n              }\\n            } else if ((0, _is.isBigNumber)(currProb)) {\\n              one = new currProb.constructor(1);\\n\\n              if (currProb.isNegative() || currProb.gt(one)) {\\n                throw new Error('Probability must be between 0 and 1, inclusive');\\n              }\\n            } else {\\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\\n            }\\n\\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\\n          }\\n\\n          return probArr;\\n        }\\n\\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\\n      }\\n\\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\\n    }\\n\\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\\n  }\\n  /**\\n   * Calculate the prob order quantile of an n-dimensional array.\\n   *\\n   * @param {Array} array\\n   * @param {Number, BigNumber} prob\\n   * @param {Boolean} sorted\\n   * @return {Number, BigNumber, Unit} prob order quantile\\n   * @private\\n   */\\n\\n\\n  function _quantileSeq(array, prob, sorted) {\\n    var flat = (0, _array.flatten)(array);\\n    var len = flat.length;\\n\\n    if (len === 0) {\\n      throw new Error('Cannot calculate quantile of an empty sequence');\\n    }\\n\\n    if ((0, _is.isNumber)(prob)) {\\n      var _index = prob * (len - 1);\\n\\n      var _fracPart = _index % 1;\\n\\n      if (_fracPart === 0) {\\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\\n        validate(value);\\n        return value;\\n      }\\n\\n      var _integerPart = Math.floor(_index);\\n\\n      var _left;\\n\\n      var _right;\\n\\n      if (sorted) {\\n        _left = flat[_integerPart];\\n        _right = flat[_integerPart + 1];\\n      } else {\\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\\n\\n        _left = flat[_integerPart];\\n\\n        for (var i = 0; i < _integerPart; ++i) {\\n          if (compare(flat[i], _left) > 0) {\\n            _left = flat[i];\\n          }\\n        }\\n      }\\n\\n      validate(_left);\\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\\n\\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\\n    } // If prob is a BigNumber\\n\\n\\n    var index = prob.times(len - 1);\\n\\n    if (index.isInteger()) {\\n      index = index.toNumber();\\n\\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\\n\\n      validate(_value);\\n      return _value;\\n    }\\n\\n    var integerPart = index.floor();\\n    var fracPart = index.minus(integerPart);\\n    var integerPartNumber = integerPart.toNumber();\\n    var left;\\n    var right;\\n\\n    if (sorted) {\\n      left = flat[integerPartNumber];\\n      right = flat[integerPartNumber + 1];\\n    } else {\\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\\n\\n      left = flat[integerPartNumber];\\n\\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\\n        if (compare(flat[_i3], left) > 0) {\\n          left = flat[_i3];\\n        }\\n      }\\n    }\\n\\n    validate(left);\\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\\n\\n    var one = new fracPart.constructor(1);\\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\\n  }\\n  /**\\n   * Check if array value types are valid, throw error otherwise.\\n   * @param {number | BigNumber | Unit} x\\n   * @param {number | BigNumber | Unit} x\\n   * @private\\n   */\\n\\n\\n  var validate = typed({\\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\\n      return x;\\n    }\\n  });\\n  return quantileSeq;\\n});\\nexports.createQuantileSeq = createQuantileSeq;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createQuantileSeq\",\"_is\",\"_number\",\"_array\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_quantileSeq\",\"array\",\"prob\",\"sorted\",\"flat\",\"flatten\",\"len\",\"length\",\"Error\",\"isNumber\",\"_index\",\"_fracPart\",\"partitionSelect\",\"validate\",\"_integerPart\",\"Math\",\"floor\",\"_left\",\"_right\",\"i\",\"compare\",\"add\",\"multiply\",\"index\",\"times\",\"isInteger\",\"_value\",\"toNumber\",\"integerPart\",\"fracPart\",\"minus\",\"integerPartNumber\",\"left\",\"right\",\"_i3\",\"one\",\"constructor\",\"typed\",\"numberBigNumberUnit\",\"x\",\"quantileSeq\",\"data\",\"probOrN\",\"arguments\",\"SyntaxError\",\"isCollection\",\"dataArr\",\"valueOf\",\"nPlusOne\",\"probArr\",\"Array\",\"isBigNumber\",\"BigNumber\",\"isNegative\",\"lte\",\"gt\",\"intN\",\"_nPlusOne\",\"_i\",\"div\",\"isArray\",\"_i2\",\"currProb\",\"TypeError\"]\n}\n"]