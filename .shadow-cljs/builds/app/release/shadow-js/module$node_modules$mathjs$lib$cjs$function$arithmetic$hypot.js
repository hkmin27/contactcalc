["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/arithmetic/hypot.js"],"~:js","shadow$provide[243]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.createHypot=void 0;c=b(25);var q=b(24);b=(0,c.factory)(\"hypot\",\"typed abs addScalar divideScalar multiplyScalar sqrt smaller isPositive\".split(\" \"),function(f){var u=f.typed,k=f.abs,t=f.addScalar,p=f.divideScalar,g=f.multiplyScalar,d=f.sqrt,l=f.smaller,h=f.isPositive;return u(\"hypot\",{\"... number | BigNumber\":function(n){for(var r=0,v=0,C=0;C<n.length;C++){var z=k(n[C]);l(v,z)?(r=g(r,g(p(v,z),p(v,z))),r=t(r,1),\nv=z):r=t(r,h(z)?g(p(z,v),p(z,v)):z)}return g(v,d(r))},Array:function(n){return this.apply(this,(0,q.flatten)(n))},Matrix:function(n){return this.apply(this,(0,q.flatten)(n.toArray()))}})});a.createHypot=b}","~:source","shadow$provide[243] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createHypot = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar name = 'hypot';\nvar dependencies = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];\nvar createHypot = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      sqrt = _ref.sqrt,\n      smaller = _ref.smaller,\n      isPositive = _ref.isPositive;\n\n  /**\n   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:\n   *\n   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)\n   *\n   * For matrix input, the hypotenusa is calculated for all values in the matrix.\n   *\n   * Syntax:\n   *\n   *     math.hypot(a, b, ...)\n   *     math.hypot([a, b, c, ...])\n   *\n   * Examples:\n   *\n   *     math.hypot(3, 4)      // 5\n   *     math.hypot(3, 4, 5)   // 7.0710678118654755\n   *     math.hypot([3, 4, 5]) // 7.0710678118654755\n   *     math.hypot(-2)        // 2\n   *\n   * See also:\n   *\n   *     abs, norm\n   *\n   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.\n   *                                                          Matrix and Array input is flattened and returns a\n   *                                                          single number for the whole matrix.\n   * @return {number | BigNumber} Returns the hypothenusa of the input values.\n   */\n  return typed(name, {\n    '... number | BigNumber': _hypot,\n    Array: function Array(x) {\n      return this.apply(this, (0, _array.flatten)(x));\n    },\n    Matrix: function Matrix(x) {\n      return this.apply(this, (0, _array.flatten)(x.toArray()));\n    }\n  });\n  /**\n   * Calculate the hypotenusa for an Array with values\n   * @param {Array.<number | BigNumber>} args\n   * @return {number | BigNumber} Returns the result\n   * @private\n   */\n\n  function _hypot(args) {\n    // code based on `hypot` from es6-shim:\n    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633\n    var result = 0;\n    var largest = 0;\n\n    for (var i = 0; i < args.length; i++) {\n      var value = abs(args[i]);\n\n      if (smaller(largest, value)) {\n        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));\n        result = addScalar(result, 1);\n        largest = value;\n      } else {\n        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);\n      }\n    }\n\n    return multiplyScalar(largest, sqrt(result));\n  }\n});\nexports.createHypot = createHypot;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","Matrix","Array","createHypot"]],"~:compiled-at",1619135723951,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$arithmetic$hypot.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,WAAR,CAAsB,IAAK,EAEvBC,EAAAA,CAAWP,CAAA,CAAQ,EAAR,CAEf,KAAIQ,EAASR,CAAA,CAAQ,EAAR,CAITM,EAAAA,CAA6B,CAAC,CAAA,CAAGC,CAASE,CAAAA,OAAb,EAFtBC,OAEsB,CADdC,yEAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CACc,CAA0C,QAAS,CAACC,CAAD,CAAO,CAAA,IACrFC,EAAQD,CAAKC,CAAAA,KADwE,CAErFC,EAAMF,CAAKE,CAAAA,GAF0E,CAGrFC,EAAYH,CAAKG,CAAAA,SAHoE,CAIrFC,EAAeJ,CAAKI,CAAAA,YAJiE,CAKrFC,EAAiBL,CAAKK,CAAAA,cAL+D,CAMrFC,EAAON,CAAKM,CAAAA,IANyE,CAOrFC,EAAUP,CAAKO,CAAAA,OAPsE,CAQrFC,EAAaR,CAAKQ,CAAAA,UA8BtB,OAAOP,EAAA,CAxCEH,OAwCF,CAAY,CACjB,yBAeFW,QAAe,CAACC,CAAD,CAAO,CAMpB,IAHA,IAAIC,EAAS,CAAb,CACIC,EAAU,CADd,CAGSC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBH,CAAKI,CAAAA,MAAzB,CAAiCD,CAAA,EAAjC,CAAsC,CACpC,IAAIpB,EAAQS,CAAA,CAAIQ,CAAA,CAAKG,CAAL,CAAJ,CAERN,EAAA,CAAQK,CAAR,CAAiBnB,CAAjB,CAAJ,EACEkB,CAEA,CAFSN,CAAA,CAAeM,CAAf,CAAuBN,CAAA,CAAeD,CAAA,CAAaQ,CAAb,CAAsBnB,CAAtB,CAAf,CAA6CW,CAAA,CAAaQ,CAAb,CAAsBnB,CAAtB,CAA7C,CAAvB,CAET,CADAkB,CACA,CADSR,CAAA,CAAUQ,CAAV,CAAkB,CAAlB,CACT;AAAAC,CAAA,CAAUnB,CAHZ,EAKEkB,CALF,CAKWR,CAAA,CAAUQ,CAAV,CAAkBH,CAAA,CAAWf,CAAX,CAAA,CAAoBY,CAAA,CAAeD,CAAA,CAAaX,CAAb,CAAoBmB,CAApB,CAAf,CAA6CR,CAAA,CAAaX,CAAb,CAAoBmB,CAApB,CAA7C,CAApB,CAAiGnB,CAAnH,CARyB,CAYtC,MAAOY,EAAA,CAAeO,CAAf,CAAwBN,CAAA,CAAKK,CAAL,CAAxB,CAlBa,CAhBH,CAEjBI,MAAOA,QAAc,CAACC,CAAD,CAAI,CACvB,MAAO,KAAKC,CAAAA,KAAL,CAAW,IAAX,CAAiB,CAAC,CAAA,CAAGrB,CAAOsB,CAAAA,OAAX,EAAoBF,CAApB,CAAjB,CADgB,CAFR,CAKjBG,OAAQA,QAAe,CAACH,CAAD,CAAI,CACzB,MAAO,KAAKC,CAAAA,KAAL,CAAW,IAAX,CAAiB,CAAC,CAAA,CAAGrB,CAAOsB,CAAAA,OAAX,EAAoBF,CAAEI,CAAAA,OAAF,EAApB,CAAjB,CADkB,CALV,CAAZ,CAtCkF,CAA1D,CA2EjC9B,EAAQI,CAAAA,WAAR,CAAsBA,CAzFwC;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/arithmetic/hypot.js\"],\n\"sourcesContent\":[\"shadow$provide[243] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createHypot = void 0;\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar name = 'hypot';\\nvar dependencies = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];\\nvar createHypot = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      abs = _ref.abs,\\n      addScalar = _ref.addScalar,\\n      divideScalar = _ref.divideScalar,\\n      multiplyScalar = _ref.multiplyScalar,\\n      sqrt = _ref.sqrt,\\n      smaller = _ref.smaller,\\n      isPositive = _ref.isPositive;\\n\\n  /**\\n   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:\\n   *\\n   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)\\n   *\\n   * For matrix input, the hypotenusa is calculated for all values in the matrix.\\n   *\\n   * Syntax:\\n   *\\n   *     math.hypot(a, b, ...)\\n   *     math.hypot([a, b, c, ...])\\n   *\\n   * Examples:\\n   *\\n   *     math.hypot(3, 4)      // 5\\n   *     math.hypot(3, 4, 5)   // 7.0710678118654755\\n   *     math.hypot([3, 4, 5]) // 7.0710678118654755\\n   *     math.hypot(-2)        // 2\\n   *\\n   * See also:\\n   *\\n   *     abs, norm\\n   *\\n   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.\\n   *                                                          Matrix and Array input is flattened and returns a\\n   *                                                          single number for the whole matrix.\\n   * @return {number | BigNumber} Returns the hypothenusa of the input values.\\n   */\\n  return typed(name, {\\n    '... number | BigNumber': _hypot,\\n    Array: function Array(x) {\\n      return this.apply(this, (0, _array.flatten)(x));\\n    },\\n    Matrix: function Matrix(x) {\\n      return this.apply(this, (0, _array.flatten)(x.toArray()));\\n    }\\n  });\\n  /**\\n   * Calculate the hypotenusa for an Array with values\\n   * @param {Array.<number | BigNumber>} args\\n   * @return {number | BigNumber} Returns the result\\n   * @private\\n   */\\n\\n  function _hypot(args) {\\n    // code based on `hypot` from es6-shim:\\n    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633\\n    var result = 0;\\n    var largest = 0;\\n\\n    for (var i = 0; i < args.length; i++) {\\n      var value = abs(args[i]);\\n\\n      if (smaller(largest, value)) {\\n        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));\\n        result = addScalar(result, 1);\\n        largest = value;\\n      } else {\\n        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);\\n      }\\n    }\\n\\n    return multiplyScalar(largest, sqrt(result));\\n  }\\n});\\nexports.createHypot = createHypot;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createHypot\",\"_factory\",\"_array\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"abs\",\"addScalar\",\"divideScalar\",\"multiplyScalar\",\"sqrt\",\"smaller\",\"isPositive\",\"_hypot\",\"args\",\"result\",\"largest\",\"i\",\"length\",\"Array\",\"x\",\"apply\",\"flatten\",\"Matrix\",\"toArray\"]\n}\n"]