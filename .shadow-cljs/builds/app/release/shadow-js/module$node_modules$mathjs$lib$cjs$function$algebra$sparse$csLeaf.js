["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js"],"~:js","shadow$provide[285]=function(c,b,y,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.csLeaf=function(q,f,u,k,t,p,g){if(q<=f||u[k+f]<=u[t+q])return-1;u[t+q]=u[k+f];k=u[p+q];u[p+q]=f;if(-1===k)f=1;else{f=2;for(q=k;q!==u[g+q];q=u[g+q]);for(p=k;p!==q;p=k)k=u[g+p],u[g+p]=q}return{jleaf:f,q:q}}}","~:source","shadow$provide[285] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csLeaf = csLeaf;\n\n/**\n * This function determines if j is a leaf of the ith row subtree.\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\n *\n * @param {Number}  i               The ith row subtree\n * @param {Number}  j               The node to test\n * @param {Array}   w               The workspace array\n * @param {Number}  first           The index offset within the workspace for the first array\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\n *\n * @return {Object}\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n  var s, sparent; // our result\n\n  var jleaf = 0;\n  var q; // check j is a leaf\n\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\n    return -1;\n  } // update max first[j] seen so far\n\n\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\n\n  var jprev = w[prevleaf + i];\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\n\n  if (jprev === -1) {\n    // 1st leaf, q = root of ith subtree\n    jleaf = 1;\n    q = i;\n  } else {\n    // update jleaf\n    jleaf = 2; // q = least common ancester (jprev,j)\n\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\n      ;\n    }\n\n    for (s = jprev; s !== q; s = sparent) {\n      // path compression\n      sparent = w[ancestor + s];\n      w[ancestor + s] = q;\n    }\n  }\n\n  return {\n    jleaf: jleaf,\n    q: q\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["q","csLeaf","__esModule","jleaf","value"]],"~:compiled-at",1619135723978,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG9DC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,EAAQI,CAAAA,MAAR,CAkBAA,QAAe,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAUC,CAAV,CAAiBC,CAAjB,CAA2BC,CAA3B,CAAqCC,CAArC,CAA+C,CAM5D,GAAIN,CAAJ,EAASC,CAAT,EAAcC,CAAA,CAAEC,CAAF,CAAUF,CAAV,CAAd,EAA8BC,CAAA,CAAEE,CAAF,CAAaJ,CAAb,CAA9B,CACE,MAAO,EAITE,EAAA,CAAEE,CAAF,CAAaJ,CAAb,CAAA,CAAkBE,CAAA,CAAEC,CAAF,CAAUF,CAAV,CAEdM,EAAAA,CAAQL,CAAA,CAAEG,CAAF,CAAaL,CAAb,CACZE,EAAA,CAAEG,CAAF,CAAaL,CAAb,CAAA,CAAkBC,CAElB,IAAc,EAAd,GAAIM,CAAJ,CAEEC,CAAA,CAAQ,CAFV,KAIO,CAELA,CAAA,CAAQ,CAER,KAAKC,CAAL,CAASF,CAAT,CAAgBE,CAAhB,GAAsBP,CAAA,CAAEI,CAAF,CAAaG,CAAb,CAAtB,CAAuCA,CAAvC,CAA2CP,CAAA,CAAEI,CAAF,CAAaG,CAAb,CAA3C,EAIA,IAAKC,CAAL,CAASH,CAAT,CAAgBG,CAAhB,GAAsBD,CAAtB,CAAyBC,CAAzB,CAA6BC,CAA7B,CAEEA,CACA,CADUT,CAAA,CAAEI,CAAF,CAAaI,CAAb,CACV,CAAAR,CAAA,CAAEI,CAAF,CAAaI,CAAb,CAAA,CAAkBD,CAXf,CAeP,MAAO,CACLD,MAAOA,CADF,CAELC,EAAGA,CAFE,CAnCqD,CAxBA;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js\"],\n\"sourcesContent\":[\"shadow$provide[285] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.csLeaf = csLeaf;\\n\\n/**\\n * This function determines if j is a leaf of the ith row subtree.\\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\\n *\\n * @param {Number}  i               The ith row subtree\\n * @param {Number}  j               The node to test\\n * @param {Array}   w               The workspace array\\n * @param {Number}  first           The index offset within the workspace for the first array\\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\\n *\\n * @return {Object}\\n *\\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n */\\nfunction csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\\n  var s, sparent; // our result\\n\\n  var jleaf = 0;\\n  var q; // check j is a leaf\\n\\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\\n    return -1;\\n  } // update max first[j] seen so far\\n\\n\\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\\n\\n  var jprev = w[prevleaf + i];\\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\\n\\n  if (jprev === -1) {\\n    // 1st leaf, q = root of ith subtree\\n    jleaf = 1;\\n    q = i;\\n  } else {\\n    // update jleaf\\n    jleaf = 2; // q = least common ancester (jprev,j)\\n\\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\\n      ;\\n    }\\n\\n    for (s = jprev; s !== q; s = sparent) {\\n      // path compression\\n      sparent = w[ancestor + s];\\n      w[ancestor + s] = q;\\n    }\\n  }\\n\\n  return {\\n    jleaf: jleaf,\\n    q: q\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"csLeaf\",\"i\",\"j\",\"w\",\"first\",\"maxfirst\",\"prevleaf\",\"ancestor\",\"jprev\",\"jleaf\",\"q\",\"s\",\"sparent\"]\n}\n"]