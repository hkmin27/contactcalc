["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/expression/node/IndexNode.js"],"~:js","shadow$provide[263]=function(c,b,y,a){function q(g){var d=Array.isArray(g)?f(g):void 0;d||(d=\"undefined\"!==typeof Symbol&&Symbol.iterator in Object(g)?Array.from(g):void 0);if(!d)a:{if(g){if(\"string\"===typeof g){d=f(g,void 0);break a}d=Object.prototype.toString.call(g).slice(8,-1);\"Object\"===d&&g.constructor&&(d=g.constructor.name);if(\"Map\"===d||\"Set\"===d){d=Array.from(g);break a}if(\"Arguments\"===d||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d)){d=f(g,void 0);break a}}d=void 0}if(!(g=d))throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\nreturn g}function f(g,d){if(null==d||d>g.length)d=g.length;for(var l=0,h=Array(d);l<d;l++)h[l]=g[l];return h}Object.defineProperty(a,\"__esModule\",{value:!0});a.createIndexNode=void 0;var u=b(14),k=b(24),t=b(21);c=b(25);var p=b(147);b=(0,c.factory)(\"IndexNode\",[\"Range\",\"Node\",\"size\"],function(g){function d(r,v){if(!(this instanceof d))throw new SyntaxError(\"Constructor must be called with the new operator\");this.dimensions=r;this.dotNotation=v||!1;if(!Array.isArray(r)||!r.every(u.isNode))throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\nif(this.dotNotation&&!this.isObjectProperty())throw Error(\"dotNotation only applicable for object properties\");}function l(r,v,C){return new h((0,u.isBigNumber)(r)?r.toNumber():r,(0,u.isBigNumber)(v)?v.toNumber():v,(0,u.isBigNumber)(C)?C.toNumber():C)}var h=g.Range,n=g.size;d.prototype=new g.Node;d.prototype.type=\"IndexNode\";d.prototype.isIndexNode=!0;d.prototype._compile=function(r,v){var C=(0,k.map)(this.dimensions,function(w,B){if((0,u.isRangeNode)(w)){if(w.needsEnd()){var x=Object.create(v);x.end=\n!0;var D=w.start._compile(r,x),F=w.end._compile(r,x),E=w.step?w.step._compile(r,x):function(){return 1};return function(P,R,ba){var Q=n(ba).valueOf();R=Object.create(R);R.end=Q[B];return l(D(P,R,ba),F(P,R,ba),E(P,R,ba))}}var G=w.start._compile(r,v),I=w.end._compile(r,v),L=w.step?w.step._compile(r,v):function(){return 1};return function(P,R,ba){return l(G(P,R,ba),I(P,R,ba),L(P,R,ba))}}if((0,u.isSymbolNode)(w)&&\"end\"===w.name){x=Object.create(v);x.end=!0;var M=w._compile(r,x);return function(P,R,ba){var Q=\nn(ba).valueOf();R=Object.create(R);R.end=Q[B];return M(P,R,ba)}}var S=w._compile(r,v);return function(P,R,ba){return S(P,R,ba)}}),z=(0,p.getSafeProperty)(r,\"index\");return function(w,B,x){var D=(0,k.map)(C,function(F){return F(w,B,x)});return z.apply(void 0,q(D))}};d.prototype.forEach=function(r){for(var v=0;v<this.dimensions.length;v++)r(this.dimensions[v],\"dimensions[\"+v+\"]\",this)};d.prototype.map=function(r){for(var v=[],C=0;C<this.dimensions.length;C++)v[C]=this._ifNode(r(this.dimensions[C],\"dimensions[\"+\nC+\"]\",this));return new d(v,this.dotNotation)};d.prototype.clone=function(){return new d(this.dimensions.slice(0),this.dotNotation)};d.prototype.isObjectProperty=function(){return 1===this.dimensions.length&&(0,u.isConstantNode)(this.dimensions[0])&&\"string\"===typeof this.dimensions[0].value};d.prototype.getObjectProperty=function(){return this.isObjectProperty()?this.dimensions[0].value:null};d.prototype._toString=function(r){return this.dotNotation?\".\"+this.getObjectProperty():\"[\"+this.dimensions.join(\", \")+\n\"]\"};d.prototype.toJSON=function(){return{mathjs:\"IndexNode\",dimensions:this.dimensions,dotNotation:this.dotNotation}};d.fromJSON=function(r){return new d(r.dimensions,r.dotNotation)};d.prototype.toHTML=function(r){r=[];for(var v=0;v<this.dimensions.length;v++)r[v]=this.dimensions[v].toHTML();return this.dotNotation?'\\x3cspan class\\x3d\"math-operator math-accessor-operator\"\\x3e.\\x3c/span\\x3e\\x3cspan class\\x3d\"math-symbol math-property\"\\x3e'+(0,t.escape)(this.getObjectProperty())+\"\\x3c/span\\x3e\":'\\x3cspan class\\x3d\"math-parenthesis math-square-parenthesis\"\\x3e[\\x3c/span\\x3e'+\nr.join('\\x3cspan class\\x3d\"math-separator\"\\x3e,\\x3c/span\\x3e')+'\\x3cspan class\\x3d\"math-parenthesis math-square-parenthesis\"\\x3e]\\x3c/span\\x3e'};d.prototype._toTex=function(r){var v=this.dimensions.map(function(C){return C.toTex(r)});return this.dotNotation?\".\"+this.getObjectProperty():\"_{\"+v.join(\",\")+\"}\"};return d},{isClass:!0,isNode:!0});a.createIndexNode=b}","~:source","shadow$provide[263] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nvar createIndexNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = (0, _array.map)(this.dimensions, function (range, i) {\n      if ((0, _is.isRangeNode)(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if ((0, _is.isSymbolNode)(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = (0, _customs.getSafeProperty)(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = (0, _array.map)(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && (0, _is.isConstantNode)(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + (0, _string.escape)(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range((0, _is.isBigNumber)(start) ? start.toNumber() : start, (0, _is.isBigNumber)(end) ? end.toNumber() : end, (0, _is.isBigNumber)(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createIndexNode = createIndexNode;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$customs","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["map","isIndexNode","forEach","fromJSON","isClass","toHTML","prototype","createIndexNode","isObjectProperty","_toString","isNode","_toTex","__esModule","getObjectProperty","value","dimensions","mathjs","type","clone","dotNotation","_compile","end","toJSON"]],"~:compiled-at",1619135723965,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$expression$node$IndexNode.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/expression/node/IndexNode.js\"],\n\"sourcesContent\":[\"shadow$provide[263] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createIndexNode = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _customs = require(\\\"../../utils/customs.js\\\");\\n\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError(\\\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _iterableToArray(iter) { if (typeof Symbol !== \\\"undefined\\\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nvar name = 'IndexNode';\\nvar dependencies = ['Range', 'Node', 'size'];\\nvar createIndexNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var Range = _ref.Range,\\n      Node = _ref.Node,\\n      size = _ref.size;\\n\\n  /**\\n   * @constructor IndexNode\\n   * @extends Node\\n   *\\n   * Describes a subset of a matrix or an object property.\\n   * Cannot be used on its own, needs to be used within an AccessorNode or\\n   * AssignmentNode.\\n   *\\n   * @param {Node[]} dimensions\\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\\n   *                                       this index was written using dot\\n   *                                       notation like `a.b`, or using bracket\\n   *                                       notation like `a[\\\"b\\\"]` (default).\\n   *                                       Used to stringify an IndexNode.\\n   */\\n  function IndexNode(dimensions, dotNotation) {\\n    if (!(this instanceof IndexNode)) {\\n      throw new SyntaxError('Constructor must be called with the new operator');\\n    }\\n\\n    this.dimensions = dimensions;\\n    this.dotNotation = dotNotation || false; // validate input\\n\\n    if (!Array.isArray(dimensions) || !dimensions.every(_is.isNode)) {\\n      throw new TypeError('Array containing Nodes expected for parameter \\\"dimensions\\\"');\\n    }\\n\\n    if (this.dotNotation && !this.isObjectProperty()) {\\n      throw new Error('dotNotation only applicable for object properties');\\n    }\\n  }\\n\\n  IndexNode.prototype = new Node();\\n  IndexNode.prototype.type = 'IndexNode';\\n  IndexNode.prototype.isIndexNode = true;\\n  /**\\n   * Compile a node into a JavaScript function.\\n   * This basically pre-calculates as much as possible and only leaves open\\n   * calculations which depend on a dynamic scope with variables.\\n   * @param {Object} math     Math.js namespace with functions and constants.\\n   * @param {Object} argNames An object with argument names as key and `true`\\n   *                          as value. Used in the SymbolNode to optimize\\n   *                          for arguments from user assigned functions\\n   *                          (see FunctionAssignmentNode) or special symbols\\n   *                          like `end` (see IndexNode).\\n   * @return {function} Returns a function which can be called like:\\n   *                        evalNode(scope: Object, args: Object, context: *)\\n   */\\n\\n  IndexNode.prototype._compile = function (math, argNames) {\\n    // TODO: implement support for bignumber (currently bignumbers are silently\\n    //       reduced to numbers when changing the value to zero-based)\\n    // TODO: Optimization: when the range values are ConstantNodes,\\n    //       we can beforehand resolve the zero-based value\\n    // optimization for a simple object property\\n    var evalDimensions = (0, _array.map)(this.dimensions, function (range, i) {\\n      if ((0, _is.isRangeNode)(range)) {\\n        if (range.needsEnd()) {\\n          // create a range containing end (like '4:end')\\n          var childArgNames = Object.create(argNames);\\n          childArgNames.end = true;\\n\\n          var evalStart = range.start._compile(math, childArgNames);\\n\\n          var evalEnd = range.end._compile(math, childArgNames);\\n\\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\\n            return 1;\\n          };\\n          return function evalDimension(scope, args, context) {\\n            var s = size(context).valueOf();\\n            var childArgs = Object.create(args);\\n            childArgs.end = s[i];\\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\\n          };\\n        } else {\\n          // create range\\n          var _evalStart = range.start._compile(math, argNames);\\n\\n          var _evalEnd = range.end._compile(math, argNames);\\n\\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\\n            return 1;\\n          };\\n\\n          return function evalDimension(scope, args, context) {\\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\\n          };\\n        }\\n      } else if ((0, _is.isSymbolNode)(range) && range.name === 'end') {\\n        // SymbolNode 'end'\\n        var _childArgNames = Object.create(argNames);\\n\\n        _childArgNames.end = true;\\n\\n        var evalRange = range._compile(math, _childArgNames);\\n\\n        return function evalDimension(scope, args, context) {\\n          var s = size(context).valueOf();\\n          var childArgs = Object.create(args);\\n          childArgs.end = s[i];\\n          return evalRange(scope, childArgs, context);\\n        };\\n      } else {\\n        // ConstantNode\\n        var _evalRange = range._compile(math, argNames);\\n\\n        return function evalDimension(scope, args, context) {\\n          return _evalRange(scope, args, context);\\n        };\\n      }\\n    });\\n    var index = (0, _customs.getSafeProperty)(math, 'index');\\n    return function evalIndexNode(scope, args, context) {\\n      var dimensions = (0, _array.map)(evalDimensions, function (evalDimension) {\\n        return evalDimension(scope, args, context);\\n      });\\n      return index.apply(void 0, _toConsumableArray(dimensions));\\n    };\\n  };\\n  /**\\n   * Execute a callback for each of the child nodes of this node\\n   * @param {function(child: Node, path: string, parent: Node)} callback\\n   */\\n\\n\\n  IndexNode.prototype.forEach = function (callback) {\\n    for (var i = 0; i < this.dimensions.length; i++) {\\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\\n    }\\n  };\\n  /**\\n   * Create a new IndexNode having it's childs be the results of calling\\n   * the provided callback function for each of the childs of the original node.\\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\\n   * @returns {IndexNode} Returns a transformed copy of the node\\n   */\\n\\n\\n  IndexNode.prototype.map = function (callback) {\\n    var dimensions = [];\\n\\n    for (var i = 0; i < this.dimensions.length; i++) {\\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\\n    }\\n\\n    return new IndexNode(dimensions, this.dotNotation);\\n  };\\n  /**\\n   * Create a clone of this node, a shallow copy\\n   * @return {IndexNode}\\n   */\\n\\n\\n  IndexNode.prototype.clone = function () {\\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\\n  };\\n  /**\\n   * Test whether this IndexNode contains a single property name\\n   * @return {boolean}\\n   */\\n\\n\\n  IndexNode.prototype.isObjectProperty = function () {\\n    return this.dimensions.length === 1 && (0, _is.isConstantNode)(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\\n  };\\n  /**\\n   * Returns the property name if IndexNode contains a property.\\n   * If not, returns null.\\n   * @return {string | null}\\n   */\\n\\n\\n  IndexNode.prototype.getObjectProperty = function () {\\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\\n  };\\n  /**\\n   * Get string representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  IndexNode.prototype._toString = function (options) {\\n    // format the parameters like \\\"[1, 0:5]\\\"\\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\\n  };\\n  /**\\n   * Get a JSON representation of the node\\n   * @returns {Object}\\n   */\\n\\n\\n  IndexNode.prototype.toJSON = function () {\\n    return {\\n      mathjs: 'IndexNode',\\n      dimensions: this.dimensions,\\n      dotNotation: this.dotNotation\\n    };\\n  };\\n  /**\\n   * Instantiate an IndexNode from its JSON representation\\n   * @param {Object} json  An object structured like\\n   *                       `{\\\"mathjs\\\": \\\"IndexNode\\\", dimensions: [...], dotNotation: false}`,\\n   *                       where mathjs is optional\\n   * @returns {IndexNode}\\n   */\\n\\n\\n  IndexNode.fromJSON = function (json) {\\n    return new IndexNode(json.dimensions, json.dotNotation);\\n  };\\n  /**\\n   * Get HTML representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  IndexNode.prototype.toHTML = function (options) {\\n    // format the parameters like \\\"[1, 0:5]\\\"\\n    var dimensions = [];\\n\\n    for (var i = 0; i < this.dimensions.length; i++) {\\n      dimensions[i] = this.dimensions[i].toHTML();\\n    }\\n\\n    if (this.dotNotation) {\\n      return '<span class=\\\"math-operator math-accessor-operator\\\">.</span>' + '<span class=\\\"math-symbol math-property\\\">' + (0, _string.escape)(this.getObjectProperty()) + '</span>';\\n    } else {\\n      return '<span class=\\\"math-parenthesis math-square-parenthesis\\\">[</span>' + dimensions.join('<span class=\\\"math-separator\\\">,</span>') + '<span class=\\\"math-parenthesis math-square-parenthesis\\\">]</span>';\\n    }\\n  };\\n  /**\\n   * Get LaTeX representation\\n   * @param {Object} options\\n   * @return {string} str\\n   */\\n\\n\\n  IndexNode.prototype._toTex = function (options) {\\n    var dimensions = this.dimensions.map(function (range) {\\n      return range.toTex(options);\\n    });\\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\\n  }; // helper function to create a Range from start, step and end\\n\\n\\n  function createRange(start, end, step) {\\n    return new Range((0, _is.isBigNumber)(start) ? start.toNumber() : start, (0, _is.isBigNumber)(end) ? end.toNumber() : end, (0, _is.isBigNumber)(step) ? step.toNumber() : step);\\n  }\\n\\n  return IndexNode;\\n}, {\\n  isClass: true,\\n  isNode: true\\n});\\nexports.createIndexNode = createIndexNode;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_toConsumableArray\",\"arr\",\"Array\",\"isArray\",\"_arrayLikeToArray\",\"Symbol\",\"iterator\",\"Object\",\"iter\",\"from\",\"o\",\"minLen\",\"n\",\"prototype\",\"toString\",\"call\",\"slice\",\"constructor\",\"name\",\"test\",\"TypeError\",\"len\",\"length\",\"i\",\"arr2\",\"defineProperty\",\"value\",\"createIndexNode\",\"_is\",\"_array\",\"_string\",\"_factory\",\"_customs\",\"factory\",\"dependencies\",\"_ref\",\"IndexNode\",\"dimensions\",\"dotNotation\",\"SyntaxError\",\"every\",\"isNode\",\"isObjectProperty\",\"Error\",\"createRange\",\"start\",\"end\",\"step\",\"Range\",\"isBigNumber\",\"toNumber\",\"size\",\"Node\",\"type\",\"isIndexNode\",\"_compile\",\"IndexNode.prototype._compile\",\"math\",\"argNames\",\"evalDimensions\",\"map\",\"range\",\"isRangeNode\",\"needsEnd\",\"childArgNames\",\"create\",\"evalStart\",\"evalEnd\",\"evalStep\",\"evalDimension\",\"scope\",\"args\",\"context\",\"s\",\"valueOf\",\"childArgs\",\"_evalStart\",\"_evalEnd\",\"_evalStep\",\"isSymbolNode\",\"_childArgNames\",\"evalRange\",\"_evalRange\",\"index\",\"getSafeProperty\",\"evalIndexNode\",\"apply\",\"forEach\",\"IndexNode.prototype.forEach\",\"callback\",\"IndexNode.prototype.map\",\"_ifNode\",\"clone\",\"IndexNode.prototype.clone\",\"IndexNode.prototype.isObjectProperty\",\"isConstantNode\",\"getObjectProperty\",\"IndexNode.prototype.getObjectProperty\",\"_toString\",\"IndexNode.prototype._toString\",\"options\",\"join\",\"toJSON\",\"IndexNode.prototype.toJSON\",\"mathjs\",\"fromJSON\",\"IndexNode.fromJSON\",\"json\",\"toHTML\",\"IndexNode.prototype.toHTML\",\"escape\",\"_toTex\",\"IndexNode.prototype._toTex\",\"toTex\",\"isClass\"]\n}\n"]