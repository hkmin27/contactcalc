["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.csLeaf=function(i,j,w,first,maxfirst,prevleaf,ancestor){if(i<=j||w[first+j]<=w[maxfirst+i])return-1;w[maxfirst+i]=w[first+j];first=w[prevleaf+i];w[prevleaf+i]=j;if(-1===first)j=1;else{j=2;for(i=first;i!==w[ancestor+i];i=w[ancestor+i]);for(prevleaf=first;prevleaf!==i;prevleaf=first)first=w[ancestor+prevleaf],w[ancestor+\nprevleaf]=i}return{jleaf:j,q:i}}}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csLeaf = csLeaf;\n\n/**\n * This function determines if j is a leaf of the ith row subtree.\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\n *\n * @param {Number}  i               The ith row subtree\n * @param {Number}  j               The node to test\n * @param {Array}   w               The workspace array\n * @param {Number}  first           The index offset within the workspace for the first array\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\n *\n * @return {Object}\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n  var s, sparent; // our result\n\n  var jleaf = 0;\n  var q; // check j is a leaf\n\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\n    return -1;\n  } // update max first[j] seen so far\n\n\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\n\n  var jprev = w[prevleaf + i];\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\n\n  if (jprev === -1) {\n    // 1st leaf, q = root of ith subtree\n    jleaf = 1;\n    q = i;\n  } else {\n    // update jleaf\n    jleaf = 2; // q = least common ancester (jprev,j)\n\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\n      ;\n    }\n\n    for (s = jprev; s !== q; s = sparent) {\n      // path compression\n      sparent = w[ancestor + s];\n      w[ancestor + s] = q;\n    }\n  }\n\n  return {\n    jleaf: jleaf,\n    q: q\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["q","csLeaf","__esModule","jleaf","value"]],"~:compiled-at",1619135262383,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAkBAA,QAAe,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAUC,KAAV,CAAiBC,QAAjB,CAA2BC,QAA3B,CAAqCC,QAArC,CAA+C,CAM5D,GAAIN,CAAJ,EAASC,CAAT,EAAcC,CAAA,CAAEC,KAAF,CAAUF,CAAV,CAAd,EAA8BC,CAAA,CAAEE,QAAF,CAAaJ,CAAb,CAA9B,CACE,MAAO,EAITE,EAAA,CAAEE,QAAF,CAAaJ,CAAb,CAAA,CAAkBE,CAAA,CAAEC,KAAF,CAAUF,CAAV,CAEdM,MAAAA,CAAQL,CAAA,CAAEG,QAAF,CAAaL,CAAb,CACZE,EAAA,CAAEG,QAAF,CAAaL,CAAb,CAAA,CAAkBC,CAElB,IAAc,EAAd,GAAIM,KAAJ,CAEEC,CAAA,CAAQ,CAFV,KAIO,CAELA,CAAA,CAAQ,CAER,KAAKC,CAAL,CAASF,KAAT,CAAgBE,CAAhB,GAAsBP,CAAA,CAAEI,QAAF,CAAaG,CAAb,CAAtB,CAAuCA,CAAvC,CAA2CP,CAAA,CAAEI,QAAF,CAAaG,CAAb,CAA3C,EAIA,IAAKC,QAAL,CAASH,KAAT,CAAgBG,QAAhB,GAAsBD,CAAtB,CAAyBC,QAAzB,CAA6BC,KAA7B,CAEEA,KACA,CADUT,CAAA,CAAEI,QAAF,CAAaI,QAAb,CACV,CAAAR,CAAA,CAAEI,QAAF;AAAaI,QAAb,CAAA,CAAkBD,CAXf,CAeP,MAAO,CACLD,MAAOA,CADF,CAELC,EAAGA,CAFE,CAnCqD,CAxBgE;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.csLeaf = csLeaf;\\n\\n/**\\n * This function determines if j is a leaf of the ith row subtree.\\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\\n *\\n * @param {Number}  i               The ith row subtree\\n * @param {Number}  j               The node to test\\n * @param {Array}   w               The workspace array\\n * @param {Number}  first           The index offset within the workspace for the first array\\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\\n *\\n * @return {Object}\\n *\\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n */\\nfunction csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\\n  var s, sparent; // our result\\n\\n  var jleaf = 0;\\n  var q; // check j is a leaf\\n\\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\\n    return -1;\\n  } // update max first[j] seen so far\\n\\n\\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\\n\\n  var jprev = w[prevleaf + i];\\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\\n\\n  if (jprev === -1) {\\n    // 1st leaf, q = root of ith subtree\\n    jleaf = 1;\\n    q = i;\\n  } else {\\n    // update jleaf\\n    jleaf = 2; // q = least common ancester (jprev,j)\\n\\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\\n      ;\\n    }\\n\\n    for (s = jprev; s !== q; s = sparent) {\\n      // path compression\\n      sparent = w[ancestor + s];\\n      w[ancestor + s] = q;\\n    }\\n  }\\n\\n  return {\\n    jleaf: jleaf,\\n    q: q\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"csLeaf\",\"i\",\"j\",\"w\",\"first\",\"maxfirst\",\"prevleaf\",\"ancestor\",\"jprev\",\"jleaf\",\"q\",\"s\",\"sparent\"]\n}\n"]