["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csReach.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csReach=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.csReach=function(g,b,k,xi,pinv){var gptr=g._ptr,bindex=b._index,bptr=b._ptr;b=g._size[1];var top=b;var p=bptr[k];for(k=bptr[k+1];p<k;p++)bptr=bindex[p],(0,_csMarked.csMarked)(gptr,bptr)||(top=(0,_csDfs.csDfs)(bptr,g,top,xi,pinv));for(p=top;p<b;p++)(0,_csMark.csMark)(gptr,xi[p]);return top};var _csMarked=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMarked\"),\n_csMark=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMark\"),_csDfs=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs\")}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csReach\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csReach = csReach;\n\nvar _csMarked = require(\"./csMarked.js\");\n\nvar _csMark = require(\"./csMark.js\");\n\nvar _csDfs = require(\"./csDfs.js\");\n\n/**\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n *\n * @param {Matrix}  g               The G matrix\n * @param {Matrix}  b               The B matrix\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector\n *\n * @return {Number}                 The index for the nonzero pattern\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csReach(g, b, k, xi, pinv) {\n  // g arrays\n  var gptr = g._ptr;\n  var gsize = g._size; // b arrays\n\n  var bindex = b._index;\n  var bptr = b._ptr; // columns\n\n  var n = gsize[1]; // vars\n\n  var p, p0, p1; // initialize top\n\n  var top = n; // loop column indeces in B\n\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n    // node i\n    var i = bindex[p]; // check node i is marked\n\n    if (!(0, _csMarked.csMarked)(gptr, i)) {\n      // start a dfs at unmarked node i\n      top = (0, _csDfs.csDfs)(i, g, top, xi, pinv);\n    }\n  } // loop columns from top -> n - 1\n\n\n  for (p = top; p < n; p++) {\n    // restore G\n    (0, _csMark.csMark)(gptr, xi[p]);\n  }\n\n  return top;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMark","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMarked","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs"]],"~:properties",["^5",["__esModule","value","csReach"]],"~:compiled-at",1619135262387,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csReach.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,OAAR,CAwBAA,QAAgB,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAUC,EAAV,CAAcC,IAAd,CAAoB,CAElC,IAAIC,KAAOL,CAAEM,CAAAA,IAAb,CAGIC,OAASN,CAAEO,CAAAA,MAHf,CAIIC,KAAOR,CAAEK,CAAAA,IAETI,EAAAA,CALQV,CAAEW,CAAAA,KAKN,CAAM,CAAN,CAR0B,KAY9BC,IAAMF,CAEL,KAAAG,EAAKJ,IAAA,CAAKP,CAAL,CAAV,KAAmBY,CAAnB,CAAwBL,IAAA,CAAKP,CAAL,CAAS,CAAT,CAAxB,CAA6Ca,CAA7C,CAAiDD,CAAjD,CAAqDC,CAAA,EAArD,CAEMC,IAEJ,CAFQT,MAAA,CAAOQ,CAAP,CAER,CAAK,CAAC,CAAA,CAAGE,SAAUC,CAAAA,QAAd,EAAwBb,IAAxB,CAA8BW,IAA9B,CAAL,GAEEJ,GAFF,CAEQ,CAAC,CAAA,CAAGO,MAAOC,CAAAA,KAAX,EAAkBJ,IAAlB,CAAqBhB,CAArB,CAAwBY,GAAxB,CAA6BT,EAA7B,CAAiCC,IAAjC,CAFR,CAOF,KAAKW,CAAL,CAASH,GAAT,CAAcG,CAAd,CAAkBL,CAAlB,CAAqBK,CAAA,EAArB,CAEE,CAAC,CAAA,CAAGM,OAAQC,CAAAA,MAAZ,EAAoBjB,IAApB,CAA0BF,EAAA,CAAGY,CAAH,CAA1B,CAGF,OAAOH,IA9B2B,CAtBpC,KAAIK,UAAYxB,OAAA,CAAQ,qEAAR,CAAhB;AAEI4B,QAAU5B,OAAA,CAAQ,mEAAR,CAFd,CAII0B,OAAS1B,OAAA,CAAQ,kEAAR,CAZkH;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csReach.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csReach\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.csReach = csReach;\\n\\nvar _csMarked = require(\\\"./csMarked.js\\\");\\n\\nvar _csMark = require(\\\"./csMark.js\\\");\\n\\nvar _csDfs = require(\\\"./csDfs.js\\\");\\n\\n/**\\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\\n *\\n * @param {Matrix}  g               The G matrix\\n * @param {Matrix}  b               The B matrix\\n * @param {Number}  k               The kth column in B\\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\\n * @param {Array}   pinv            The inverse row permutation vector\\n *\\n * @return {Number}                 The index for the nonzero pattern\\n *\\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n */\\nfunction csReach(g, b, k, xi, pinv) {\\n  // g arrays\\n  var gptr = g._ptr;\\n  var gsize = g._size; // b arrays\\n\\n  var bindex = b._index;\\n  var bptr = b._ptr; // columns\\n\\n  var n = gsize[1]; // vars\\n\\n  var p, p0, p1; // initialize top\\n\\n  var top = n; // loop column indeces in B\\n\\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\\n    // node i\\n    var i = bindex[p]; // check node i is marked\\n\\n    if (!(0, _csMarked.csMarked)(gptr, i)) {\\n      // start a dfs at unmarked node i\\n      top = (0, _csDfs.csDfs)(i, g, top, xi, pinv);\\n    }\\n  } // loop columns from top -> n - 1\\n\\n\\n  for (p = top; p < n; p++) {\\n    // restore G\\n    (0, _csMark.csMark)(gptr, xi[p]);\\n  }\\n\\n  return top;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"csReach\",\"g\",\"b\",\"k\",\"xi\",\"pinv\",\"gptr\",\"_ptr\",\"bindex\",\"_index\",\"bptr\",\"n\",\"_size\",\"top\",\"p0\",\"p1\",\"p\",\"i\",\"_csMarked\",\"csMarked\",\"_csDfs\",\"csDfs\",\"_csMark\",\"csMark\"]\n}\n"]