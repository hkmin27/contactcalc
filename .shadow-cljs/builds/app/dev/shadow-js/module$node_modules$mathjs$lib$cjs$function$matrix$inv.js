["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/inv.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$inv=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createInv=void 0;var _is=require(\"module$node_modules$mathjs$lib$cjs$utils$is\"),_array=require(\"module$node_modules$mathjs$lib$cjs$utils$array\");global=require(\"module$node_modules$mathjs$lib$cjs$utils$factory\");var _string=require(\"module$node_modules$mathjs$lib$cjs$utils$string\");require=(0,global.factory)(\"inv\",\"typed matrix divideScalar addScalar multiply unaryMinus det identity abs\".split(\" \"),\nfunction(_ref){function _inv(mat,rows,cols){if(1===rows){rows=mat[0][0];if(0===rows)throw Error(\"Cannot calculate inverse, determinant is zero\");return[[divideScalar(1,rows)]]}if(2===rows){rows=det(mat);if(0===rows)throw Error(\"Cannot calculate inverse, determinant is zero\");return[[divideScalar(mat[1][1],rows),divideScalar(unaryMinus(mat[0][1]),rows)],[divideScalar(unaryMinus(mat[1][0]),rows),divideScalar(mat[0][0],rows)]]}var A=mat.concat();for(mat=0;mat<rows;mat++)A[mat]=A[mat].concat();for(var B=\nidentity(rows).valueOf(),c=0;c<cols;c++){var s=abs(A[c][c]);var f=c;for(mat=c+1;mat<rows;)abs(A[mat][c])>s&&(s=abs(A[mat][c]),f=mat),mat++;if(0===s)throw Error(\"Cannot calculate inverse, determinant is zero\");mat=f;mat!==c&&(s=A[c],A[c]=A[mat],A[mat]=s,s=B[c],B[c]=B[mat],B[mat]=s);var Ac=A[c],Bc=B[c];for(mat=0;mat<rows;mat++){var Ar=A[mat],Br=B[mat];if(mat!==c){if(0!==Ar[c]){f=divideScalar(unaryMinus(Ar[c]),Ac[c]);for(s=c;s<cols;s++)Ar[s]=addScalar(Ar[s],multiply(f,Ac[s]));for(s=0;s<cols;s++)Br[s]=\naddScalar(Br[s],multiply(f,Bc[s]))}}else{f=Ac[c];for(s=c;s<cols;s++)Ar[s]=divideScalar(Ar[s],f);for(s=0;s<cols;s++)Br[s]=divideScalar(Br[s],f)}}}return B}var typed=_ref.typed,matrix=_ref.matrix,divideScalar=_ref.divideScalar,addScalar=_ref.addScalar,multiply=_ref.multiply,unaryMinus=_ref.unaryMinus,det=_ref.det,identity=_ref.identity,abs=_ref.abs;return typed(\"inv\",{\"Array | Matrix\":function(x){var size=(0,_is.isMatrix)(x)?x.size():(0,_array.arraySize)(x);switch(size.length){case 1:if(1===size[0])return(0,\n_is.isMatrix)(x)?matrix([divideScalar(1,x.valueOf()[0])]):[divideScalar(1,x[0])];throw new RangeError(\"Matrix must be square (size: \"+(0,_string.format)(size)+\")\");case 2:var rows=size[0],cols=size[1];if(rows===cols)return(0,_is.isMatrix)(x)?matrix(_inv(x.valueOf(),rows,cols),x.storage()):_inv(x,rows,cols);throw new RangeError(\"Matrix must be square (size: \"+(0,_string.format)(size)+\")\");default:throw new RangeError(\"Matrix must be two dimensional (size: \"+(0,_string.format)(size)+\")\");}},any:function(x){return divideScalar(1,\nx)}})});exports.createInv=require}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$matrix$inv\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInv = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      addScalar = _ref.addScalar,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      det = _ref.det,\n      identity = _ref.identity,\n      abs = _ref.abs;\n\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if ((0, _is.isMatrix)(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              if ((0, _is.isMatrix)(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n});\nexports.createInv = createInv;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","createInv","any","value"]],"~:compiled-at",1619135262517,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$inv.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/inv.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$matrix$inv\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createInv = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar name = 'inv';\\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      matrix = _ref.matrix,\\n      divideScalar = _ref.divideScalar,\\n      addScalar = _ref.addScalar,\\n      multiply = _ref.multiply,\\n      unaryMinus = _ref.unaryMinus,\\n      det = _ref.det,\\n      identity = _ref.identity,\\n      abs = _ref.abs;\\n\\n  /**\\n   * Calculate the inverse of a square matrix.\\n   *\\n   * Syntax:\\n   *\\n   *     math.inv(x)\\n   *\\n   * Examples:\\n   *\\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\\n   *     math.inv(4)                 // returns 0.25\\n   *     1 / 4                       // returns 0.25\\n   *\\n   * See also:\\n   *\\n   *     det, transpose\\n   *\\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\\n   */\\n  return typed(name, {\\n    'Array | Matrix': function ArrayMatrix(x) {\\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\\n\\n      switch (size.length) {\\n        case 1:\\n          // vector\\n          if (size[0] === 1) {\\n            if ((0, _is.isMatrix)(x)) {\\n              return matrix([divideScalar(1, x.valueOf()[0])]);\\n            } else {\\n              return [divideScalar(1, x[0])];\\n            }\\n          } else {\\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n          }\\n\\n        case 2:\\n          // two dimensional array\\n          {\\n            var rows = size[0];\\n            var cols = size[1];\\n\\n            if (rows === cols) {\\n              if ((0, _is.isMatrix)(x)) {\\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\\n              } else {\\n                // return an Array\\n                return _inv(x, rows, cols);\\n              }\\n            } else {\\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n            }\\n          }\\n\\n        default:\\n          // multi dimensional array\\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\\n      }\\n    },\\n    any: function any(x) {\\n      // scalar\\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\\n    }\\n  });\\n  /**\\n   * Calculate the inverse of a square matrix\\n   * @param {Array[]} mat     A square matrix\\n   * @param {number} rows     Number of rows\\n   * @param {number} cols     Number of columns, must equal rows\\n   * @return {Array[]} inv    Inverse matrix\\n   * @private\\n   */\\n\\n  function _inv(mat, rows, cols) {\\n    var r, s, f, value, temp;\\n\\n    if (rows === 1) {\\n      // this is a 1 x 1 matrix\\n      value = mat[0][0];\\n\\n      if (value === 0) {\\n        throw Error('Cannot calculate inverse, determinant is zero');\\n      }\\n\\n      return [[divideScalar(1, value)]];\\n    } else if (rows === 2) {\\n      // this is a 2 x 2 matrix\\n      var d = det(mat);\\n\\n      if (d === 0) {\\n        throw Error('Cannot calculate inverse, determinant is zero');\\n      }\\n\\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\\n    } else {\\n      // this is a matrix of 3 x 3 or larger\\n      // calculate inverse using gauss-jordan elimination\\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\\n      //      http://mathworld.wolfram.com/MatrixInverse.html\\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\\n      // make a copy of the matrix (only the arrays, not of the elements)\\n      var A = mat.concat();\\n\\n      for (r = 0; r < rows; r++) {\\n        A[r] = A[r].concat();\\n      } // create an identity matrix which in the end will contain the\\n      // matrix inverse\\n\\n\\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\\n\\n      for (var c = 0; c < cols; c++) {\\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\\n        var ABig = abs(A[c][c]);\\n        var rBig = c;\\n        r = c + 1;\\n\\n        while (r < rows) {\\n          if (abs(A[r][c]) > ABig) {\\n            ABig = abs(A[r][c]);\\n            rBig = r;\\n          }\\n\\n          r++;\\n        }\\n\\n        if (ABig === 0) {\\n          throw Error('Cannot calculate inverse, determinant is zero');\\n        }\\n\\n        r = rBig;\\n\\n        if (r !== c) {\\n          temp = A[c];\\n          A[c] = A[r];\\n          A[r] = temp;\\n          temp = B[c];\\n          B[c] = B[r];\\n          B[r] = temp;\\n        } // eliminate non-zero values on the other rows at column c\\n\\n\\n        var Ac = A[c];\\n        var Bc = B[c];\\n\\n        for (r = 0; r < rows; r++) {\\n          var Ar = A[r];\\n          var Br = B[r];\\n\\n          if (r !== c) {\\n            // eliminate value at column c and row r\\n            if (Ar[c] !== 0) {\\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\\n              // at column c\\n\\n              for (s = c; s < cols; s++) {\\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\\n              }\\n\\n              for (s = 0; s < cols; s++) {\\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\\n              }\\n            }\\n          } else {\\n            // normalize value at Acc to 1,\\n            // divide each value on row r with the value at Acc\\n            f = Ac[c];\\n\\n            for (s = c; s < cols; s++) {\\n              Ar[s] = divideScalar(Ar[s], f);\\n            }\\n\\n            for (s = 0; s < cols; s++) {\\n              Br[s] = divideScalar(Br[s], f);\\n            }\\n          }\\n        }\\n      }\\n\\n      return B;\\n    }\\n  }\\n});\\nexports.createInv = createInv;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createInv\",\"_is\",\"_array\",\"_factory\",\"_string\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"_inv\",\"mat\",\"rows\",\"cols\",\"Error\",\"divideScalar\",\"d\",\"det\",\"unaryMinus\",\"A\",\"concat\",\"r\",\"B\",\"identity\",\"valueOf\",\"c\",\"ABig\",\"abs\",\"rBig\",\"temp\",\"Ac\",\"Bc\",\"Ar\",\"Br\",\"f\",\"s\",\"addScalar\",\"multiply\",\"typed\",\"matrix\",\"ArrayMatrix\",\"x\",\"size\",\"isMatrix\",\"arraySize\",\"length\",\"RangeError\",\"format\",\"storage\",\"any\"]\n}\n"]