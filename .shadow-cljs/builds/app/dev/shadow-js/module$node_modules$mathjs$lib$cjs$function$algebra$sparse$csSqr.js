["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createCsSqr=void 0;var _csPermute=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPermute\"),_csPost=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPost\"),_csEtree=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csEtree\"),_csAmd=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csAmd\"),\n_csCounts=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts\");global=require(\"module$node_modules$mathjs$lib$cjs$utils$factory\");global=(0,global.factory)(\"csSqr\",[\"add\",\"multiply\",\"transpose\"],function(_ref){var add=_ref.add,multiply=_ref.multiply;_ref=_ref.transpose;var csAmd=(0,_csAmd.createCsAmd)({add:add,multiply:multiply,transpose:_ref}),csCounts=(0,_csCounts.createCsCounts)({transpose:_ref});return function(order,a,qr){var aptr=a._ptr,n=a._size[1],s={};s.q=csAmd(order,\na);if(order&&!s.q)return null;if(qr){qr=order?(0,_csPermute.csPermute)(a,null,s.q,0):a;s.parent=(0,_csEtree.csEtree)(qr,1);order=(0,_csPost.csPost)(s.parent,n);s.cp=csCounts(qr,s.parent,order,1);if(order=qr&&s.parent&&s.cp){order=qr._ptr;a=qr._index;aptr=qr._size;qr=aptr[0];aptr=aptr[1];s.pinv=[];s.leftmost=[];var parent=s.parent,pinv=s.pinv,leftmost=s.leftmost,w=[],tail=qr+aptr,nque=qr+2*aptr,i,k;for(k=0;k<aptr;k++)w[qr+k]=-1,w[tail+k]=-1,w[nque+k]=0;for(i=0;i<qr;i++)leftmost[i]=-1;for(k=aptr-1;0<=\nk;k--){var p=order[k];for(i=order[k+1];p<i;p++)leftmost[a[p]]=k}for(i=qr-1;0<=i;i--)pinv[i]=-1,k=leftmost[i],-1!==k&&(0===w[nque+k]++&&(w[tail+k]=i),w[0+i]=w[qr+k],w[qr+k]=i);s.lnz=0;s.m2=qr;for(k=0;k<aptr;k++)i=w[qr+k],s.lnz++,0>i&&(i=s.m2++),pinv[i]=k,0>=--nque[k]||(s.lnz+=w[nque+k],order=parent[k],-1!==order&&(0===w[nque+order]&&(w[tail+order]=w[tail+k]),w[0+w[tail+k]]=w[qr+order],w[qr+order]=w[0+i],w[nque+order]+=w[nque+k]));for(i=0;i<qr;i++)0>pinv[i]&&(pinv[i]=k++);order=!0}if(order)for(order=\ns.unz=0;order<n;order++)s.unz+=s.cp[order]}else s.unz=4*aptr[n]+n,s.lnz=s.unz;return s}});exports.createCsSqr=global}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSqr = void 0;\n\nvar _csPermute = require(\"./csPermute.js\");\n\nvar _csPost = require(\"./csPost.js\");\n\nvar _csEtree = require(\"./csEtree.js\");\n\nvar _csAmd = require(\"./csAmd.js\");\n\nvar _csCounts = require(\"./csCounts.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose;\n  var csAmd = (0, _csAmd.createCsAmd)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = (0, _csCounts.createCsCounts)({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\n\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});\nexports.createCsSqr = createCsSqr;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPost","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csEtree","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csAmd","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPermute","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["leftmost","multiply","cp","q","parent","__esModule","lnz","value","unz","pinv","m2","createCsSqr","add","transpose"]],"~:compiled-at",1619135262385,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSqr\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createCsSqr = void 0;\\n\\nvar _csPermute = require(\\\"./csPermute.js\\\");\\n\\nvar _csPost = require(\\\"./csPost.js\\\");\\n\\nvar _csEtree = require(\\\"./csEtree.js\\\");\\n\\nvar _csAmd = require(\\\"./csAmd.js\\\");\\n\\nvar _csCounts = require(\\\"./csCounts.js\\\");\\n\\nvar _factory = require(\\\"../../../utils/factory.js\\\");\\n\\nvar name = 'csSqr';\\nvar dependencies = ['add', 'multiply', 'transpose'];\\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var add = _ref.add,\\n      multiply = _ref.multiply,\\n      transpose = _ref.transpose;\\n  var csAmd = (0, _csAmd.createCsAmd)({\\n    add: add,\\n    multiply: multiply,\\n    transpose: transpose\\n  });\\n  var csCounts = (0, _csCounts.createCsCounts)({\\n    transpose: transpose\\n  });\\n  /**\\n   * Symbolic ordering and analysis for QR and LU decompositions.\\n   *\\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\\n   * @param {Matrix}  a               The A matrix\\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\\n   *                                  symbolic ordering and analysis for LU decomposition (false)\\n   *\\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\\n   *\\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n   */\\n\\n  return function csSqr(order, a, qr) {\\n    // a arrays\\n    var aptr = a._ptr;\\n    var asize = a._size; // columns\\n\\n    var n = asize[1]; // vars\\n\\n    var k; // symbolic analysis result\\n\\n    var s = {}; // fill-reducing ordering\\n\\n    s.q = csAmd(order, a); // validate results\\n\\n    if (order && !s.q) {\\n      return null;\\n    } // QR symbolic analysis\\n\\n\\n    if (qr) {\\n      // apply permutations if needed\\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\\n\\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\\n\\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\\n\\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\\n\\n      if (c && s.parent && s.cp && _vcount(c, s)) {\\n        // calculate number of nonzero elements\\n        for (s.unz = 0, k = 0; k < n; k++) {\\n          s.unz += s.cp[k];\\n        }\\n      }\\n    } else {\\n      // for LU factorization only, guess nnz(L) and nnz(U)\\n      s.unz = 4 * aptr[n] + n;\\n      s.lnz = s.unz;\\n    } // return result S\\n\\n\\n    return s;\\n  };\\n  /**\\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\\n   */\\n\\n  function _vcount(a, s) {\\n    // a arrays\\n    var aptr = a._ptr;\\n    var aindex = a._index;\\n    var asize = a._size; // rows & columns\\n\\n    var m = asize[0];\\n    var n = asize[1]; // initialize s arrays\\n\\n    s.pinv = []; // (m + n)\\n\\n    s.leftmost = []; // (m)\\n    // vars\\n\\n    var parent = s.parent;\\n    var pinv = s.pinv;\\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\\n\\n    var w = []; // (m + 3 * n)\\n\\n    var next = 0;\\n    var head = m;\\n    var tail = m + n;\\n    var nque = m + 2 * n; // vars\\n\\n    var i, k, p, p0, p1; // initialize w\\n\\n    for (k = 0; k < n; k++) {\\n      // queue k is empty\\n      w[head + k] = -1;\\n      w[tail + k] = -1;\\n      w[nque + k] = 0;\\n    } // initialize row arrays\\n\\n\\n    for (i = 0; i < m; i++) {\\n      leftmost[i] = -1;\\n    } // loop columns backwards\\n\\n\\n    for (k = n - 1; k >= 0; k--) {\\n      // values & index for column k\\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\\n        // leftmost[i] = min(find(A(i,:)))\\n        leftmost[aindex[p]] = k;\\n      }\\n    } // scan rows in reverse order\\n\\n\\n    for (i = m - 1; i >= 0; i--) {\\n      // row i is not yet ordered\\n      pinv[i] = -1;\\n      k = leftmost[i]; // check row i is empty\\n\\n      if (k === -1) {\\n        continue;\\n      } // first row in queue k\\n\\n\\n      if (w[nque + k]++ === 0) {\\n        w[tail + k] = i;\\n      } // put i at head of queue k\\n\\n\\n      w[next + i] = w[head + k];\\n      w[head + k] = i;\\n    }\\n\\n    s.lnz = 0;\\n    s.m2 = m; // find row permutation and nnz(V)\\n\\n    for (k = 0; k < n; k++) {\\n      // remove row i from queue k\\n      i = w[head + k]; // count V(k,k) as nonzero\\n\\n      s.lnz++; // add a fictitious row\\n\\n      if (i < 0) {\\n        i = s.m2++;\\n      } // associate row i with V(:,k)\\n\\n\\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\\n\\n      if (--nque[k] <= 0) {\\n        continue;\\n      } // nque[k] is nnz (V(k+1:m,k))\\n\\n\\n      s.lnz += w[nque + k]; // move all rows to parent of k\\n\\n      var pa = parent[k];\\n\\n      if (pa !== -1) {\\n        if (w[nque + pa] === 0) {\\n          w[tail + pa] = w[tail + k];\\n        }\\n\\n        w[next + w[tail + k]] = w[head + pa];\\n        w[head + pa] = w[next + i];\\n        w[nque + pa] += w[nque + k];\\n      }\\n    }\\n\\n    for (i = 0; i < m; i++) {\\n      if (pinv[i] < 0) {\\n        pinv[i] = k++;\\n      }\\n    }\\n\\n    return true;\\n  }\\n});\\nexports.createCsSqr = createCsSqr;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createCsSqr\",\"_csPermute\",\"_csPost\",\"_csEtree\",\"_csAmd\",\"_csCounts\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"add\",\"multiply\",\"transpose\",\"csAmd\",\"createCsAmd\",\"csCounts\",\"createCsCounts\",\"csSqr\",\"order\",\"a\",\"qr\",\"aptr\",\"_ptr\",\"n\",\"_size\",\"s\",\"q\",\"c\",\"csPermute\",\"parent\",\"csEtree\",\"post\",\"csPost\",\"cp\",\"aindex\",\"_index\",\"asize\",\"m\",\"pinv\",\"leftmost\",\"w\",\"tail\",\"nque\",\"i\",\"k\",\"p0\",\"p1\",\"p\",\"next\",\"lnz\",\"m2\",\"pa\",\"unz\"]\n}\n"]