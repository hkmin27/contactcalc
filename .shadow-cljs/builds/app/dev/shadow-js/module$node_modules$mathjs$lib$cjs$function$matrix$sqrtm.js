["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/matrix/sqrtm.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createSqrtm=void 0;var _is=require(\"module$node_modules$mathjs$lib$cjs$utils$is\"),_string=require(\"module$node_modules$mathjs$lib$cjs$utils$string\"),_array=require(\"module$node_modules$mathjs$lib$cjs$utils$array\");global=require(\"module$node_modules$mathjs$lib$cjs$utils$factory\");global=(0,global.factory)(\"sqrtm\",\"typed abs add multiply sqrt subtract inv size max identity\".split(\" \"),\nfunction(_ref){var typed=_ref.typed,abs=_ref.abs,add=_ref.add,multiply=_ref.multiply,sqrt=_ref.sqrt,subtract=_ref.subtract,inv=_ref.inv,size$jscomp$0=_ref.size,max=_ref.max,identity=_ref.identity;return typed(\"sqrtm\",{\"Array | Matrix\":function(A){var size=(0,_is.isMatrix)(A)?A.size():(0,_array.arraySize)(A);switch(size.length){case 1:if(1===size[0])return sqrt(A);throw new RangeError(\"Matrix must be square (size: \"+(0,_string.format)(size)+\")\");case 2:if(size[0]===size[1]){size=0;var Y=A;A=identity(size$jscomp$0(A));\ndo{var error=Y;Y=multiply(.5,add(error,inv(A)));A=multiply(.5,add(A,inv(error)));error=max(abs(subtract(Y,error)));if(1E-6<error&&1E3<++size)throw Error(\"computing square root of matrix: iterative method could not converge\");}while(1E-6<error);return Y}throw new RangeError(\"Matrix must be square (size: \"+(0,_string.format)(size)+\")\");default:throw new RangeError(\"Matrix must be at most two dimensional (size: \"+(0,_string.format)(size)+\")\");}}})});exports.createSqrtm=global}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSqrtm = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'sqrtm';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'sqrt', 'subtract', 'inv', 'size', 'max', 'identity'];\nvar createSqrtm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      sqrt = _ref.sqrt,\n      subtract = _ref.subtract,\n      inv = _ref.inv,\n      size = _ref.size,\n      max = _ref.max,\n      identity = _ref.identity;\n  var _maxIterations = 1e3;\n  var _tolerance = 1e-6;\n  /**\n   * Calculate the principal square root matrix using the Denman–Beavers iterative method\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   * @private\n   */\n\n  function _denmanBeavers(A) {\n    var error;\n    var iterations = 0;\n    var Y = A;\n    var Z = identity(size(A));\n\n    do {\n      var Yk = Y;\n      Y = multiply(0.5, add(Yk, inv(Z)));\n      Z = multiply(0.5, add(Z, inv(Yk)));\n      error = max(abs(subtract(Y, Yk)));\n\n      if (error > _tolerance && ++iterations > _maxIterations) {\n        throw new Error('computing square root of matrix: iterative method could not converge');\n      }\n    } while (error > _tolerance);\n\n    return Y;\n  }\n  /**\n   * Calculate the principal square root of a square matrix.\n   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix\n   *\n   * Syntax:\n   *\n   *     X = math.sqrtm(A)\n   *\n   * Examples:\n   *\n   *     math.sqrtm([[1, 2], [3, 4]]) // returns [[-2, 1], [1.5, -0.5]]\n   *\n   * See also:\n   *\n   *     sqrt, pow\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   */\n\n\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(A) {\n      var size = (0, _is.isMatrix)(A) ? A.size() : (0, _array.arraySize)(A);\n\n      switch (size.length) {\n        case 1:\n          // Single element Array | Matrix\n          if (size[0] === 1) {\n            return sqrt(A);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n          }\n\n        case 2:\n          {\n            // Two-dimensional Array | Matrix\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _denmanBeavers(A);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n            }\n          }\n\n        default:\n          // Multi dimensional array\n          throw new RangeError('Matrix must be at most two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n    }\n  });\n});\nexports.createSqrtm = createSqrtm;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$utils$string","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$utils$is","~$module$node_modules$mathjs$lib$cjs$utils$array","~$module$node_modules$mathjs$lib$cjs$utils$factory"]],"~:properties",["^5",["__esModule","value","createSqrtm"]],"~:compiled-at",1619135262526,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/matrix/sqrtm.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createSqrtm = void 0;\\n\\nvar _is = require(\\\"../../utils/is.js\\\");\\n\\nvar _string = require(\\\"../../utils/string.js\\\");\\n\\nvar _array = require(\\\"../../utils/array.js\\\");\\n\\nvar _factory = require(\\\"../../utils/factory.js\\\");\\n\\nvar name = 'sqrtm';\\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'sqrt', 'subtract', 'inv', 'size', 'max', 'identity'];\\nvar createSqrtm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\\n  var typed = _ref.typed,\\n      abs = _ref.abs,\\n      add = _ref.add,\\n      multiply = _ref.multiply,\\n      sqrt = _ref.sqrt,\\n      subtract = _ref.subtract,\\n      inv = _ref.inv,\\n      size = _ref.size,\\n      max = _ref.max,\\n      identity = _ref.identity;\\n  var _maxIterations = 1e3;\\n  var _tolerance = 1e-6;\\n  /**\\n   * Calculate the principal square root matrix using the Denman\\u2013Beavers iterative method\\n   *\\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman\\u2013Beavers_iteration\\n   *\\n   * @param  {Array | Matrix} A   The square matrix `A`\\n   * @return {Array | Matrix}     The principal square root of matrix `A`\\n   * @private\\n   */\\n\\n  function _denmanBeavers(A) {\\n    var error;\\n    var iterations = 0;\\n    var Y = A;\\n    var Z = identity(size(A));\\n\\n    do {\\n      var Yk = Y;\\n      Y = multiply(0.5, add(Yk, inv(Z)));\\n      Z = multiply(0.5, add(Z, inv(Yk)));\\n      error = max(abs(subtract(Y, Yk)));\\n\\n      if (error > _tolerance && ++iterations > _maxIterations) {\\n        throw new Error('computing square root of matrix: iterative method could not converge');\\n      }\\n    } while (error > _tolerance);\\n\\n    return Y;\\n  }\\n  /**\\n   * Calculate the principal square root of a square matrix.\\n   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.\\n   *\\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix\\n   *\\n   * Syntax:\\n   *\\n   *     X = math.sqrtm(A)\\n   *\\n   * Examples:\\n   *\\n   *     math.sqrtm([[1, 2], [3, 4]]) // returns [[-2, 1], [1.5, -0.5]]\\n   *\\n   * See also:\\n   *\\n   *     sqrt, pow\\n   *\\n   * @param  {Array | Matrix} A   The square matrix `A`\\n   * @return {Array | Matrix}     The principal square root of matrix `A`\\n   */\\n\\n\\n  return typed(name, {\\n    'Array | Matrix': function ArrayMatrix(A) {\\n      var size = (0, _is.isMatrix)(A) ? A.size() : (0, _array.arraySize)(A);\\n\\n      switch (size.length) {\\n        case 1:\\n          // Single element Array | Matrix\\n          if (size[0] === 1) {\\n            return sqrt(A);\\n          } else {\\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n          }\\n\\n        case 2:\\n          {\\n            // Two-dimensional Array | Matrix\\n            var rows = size[0];\\n            var cols = size[1];\\n\\n            if (rows === cols) {\\n              return _denmanBeavers(A);\\n            } else {\\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\\n            }\\n          }\\n\\n        default:\\n          // Multi dimensional array\\n          throw new RangeError('Matrix must be at most two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\\n      }\\n    }\\n  });\\n});\\nexports.createSqrtm = createSqrtm;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"createSqrtm\",\"_is\",\"_string\",\"_array\",\"_factory\",\"factory\",\"name\",\"dependencies\",\"_ref\",\"typed\",\"abs\",\"add\",\"multiply\",\"sqrt\",\"subtract\",\"inv\",\"size\",\"max\",\"identity\",\"ArrayMatrix\",\"A\",\"isMatrix\",\"arraySize\",\"length\",\"RangeError\",\"format\",\"rows\",\"cols\",\"iterations\",\"Y\",\"Z\",\"Yk\",\"error\",\"_tolerance\",\"_maxIterations\",\"Error\"]\n}\n"]