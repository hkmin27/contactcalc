["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mathjs/lib/cjs/function/algebra/sparse/csDfs.js"],"~:js","shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.csDfs=function(j,g,top,xi,pinv){var index=g._index,ptr=g._ptr;g=g._size[1];var p2,head=0;for(xi[0]=j;0<=head;){j=xi[head];var i=pinv?pinv[j]:j;(0,_csMarked.csMarked)(ptr,j)||((0,_csMark.csMark)(ptr,j),xi[g+head]=0>i?0:(0,_csUnflip.csUnflip)(ptr[i]));var done=1;var p=xi[g+head];for(p2=0>i?0:(0,_csUnflip.csUnflip)(ptr[i+\n1]);p<p2;p++)if(i=index[p],!(0,_csMarked.csMarked)(ptr,i)){xi[g+head]=p;xi[++head]=i;done=0;break}done&&(head--,xi[--top]=j)}return top};var _csMarked=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMarked\"),_csMark=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMark\"),_csUnflip=require(\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csUnflip\")}","~:source","shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csDfs = csDfs;\n\nvar _csMarked = require(\"./csMarked.js\");\n\nvar _csMark = require(\"./csMark.js\");\n\nvar _csUnflip = require(\"./csUnflip.js\");\n\n/**\n * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\n * at nodes in B (see csReach()).\n *\n * @param {Number}  j               The starting node for the DFS algorithm\n * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\n * @param {Number}  top             Start index in stack xi[top..n-1]\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n *\n * @return {Number}                 New value of top\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csDfs(j, g, top, xi, pinv) {\n  // g arrays\n  var index = g._index;\n  var ptr = g._ptr;\n  var size = g._size; // columns\n\n  var n = size[1]; // vars\n\n  var i, p, p2; // initialize head\n\n  var head = 0; // initialize the recursion stack\n\n  xi[0] = j; // loop\n\n  while (head >= 0) {\n    // get j from the top of the recursion stack\n    j = xi[head]; // apply permutation vector\n\n    var jnew = pinv ? pinv[j] : j; // check node j is marked\n\n    if (!(0, _csMarked.csMarked)(ptr, j)) {\n      // mark node j as visited\n      (0, _csMark.csMark)(ptr, j); // update stack (last n entries in xi)\n\n      xi[n + head] = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew]);\n    } // node j done if no unvisited neighbors\n\n\n    var done = 1; // examine all neighbors of j, stack (last n entries in xi)\n\n    for (p = xi[n + head], p2 = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew + 1]); p < p2; p++) {\n      // consider neighbor node i\n      i = index[p]; // check we have visited node i, skip it\n\n      if ((0, _csMarked.csMarked)(ptr, i)) {\n        continue;\n      } // pause depth-first search of node j, update stack (last n entries in xi)\n\n\n      xi[n + head] = p; // start dfs at node i\n\n      xi[++head] = i; // node j is not done\n\n      done = 0; // break, to start dfs(i)\n\n      break;\n    } // check depth-first search at node j is done\n\n\n    if (done) {\n      // remove j from the recursion stack\n      head--; // and place in the output stack\n\n      xi[--top] = j;\n    }\n  }\n\n  return top;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMark","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csMarked","~$shadow.js","~$module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csUnflip"]],"~:properties",["^5",["__esModule","value","csDfs"]],"~:compiled-at",1619135262386,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,gEAAA,CAAqF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG7HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,KAAR,CAwBAA,QAAc,CAACC,CAAD,CAAIC,CAAJ,CAAOC,GAAP,CAAYC,EAAZ,CAAgBC,IAAhB,CAAsB,CAElC,IAAIC,MAAQJ,CAAEK,CAAAA,MAAd,CACIC,IAAMN,CAAEO,CAAAA,IAGRC,EAAAA,CAFOR,CAAES,CAAAA,KAEL,CAAK,CAAL,CAN0B,KAQxBC,EARwB,CAU9BC,KAAO,CAIX,KAFAT,EAAA,CAAG,CAAH,CAEA,CAFQH,CAER,CAAe,CAAf,EAAOY,IAAP,CAAA,CAAkB,CAEhBZ,CAAA,CAAIG,EAAA,CAAGS,IAAH,CAEAC,KAAAA,EAAOT,IAAA,CAAOA,IAAA,CAAKJ,CAAL,CAAP,CAAiBA,CAEvB,EAAC,CAAA,CAAGc,SAAUC,CAAAA,QAAd,EAAwBR,GAAxB,CAA6BP,CAA7B,CAAL,GAEE,CAAC,CAAA,CAAGgB,OAAQC,CAAAA,MAAZ,EAAoBV,GAApB,CAAyBP,CAAzB,CAEA,CAAAG,EAAA,CAAGM,CAAH,CAAOG,IAAP,CAAA,CAAsB,CAAP,CAAAC,CAAA,CAAW,CAAX,CAAe,CAAC,CAAA,CAAGK,SAAUC,CAAAA,QAAd,EAAwBZ,GAAA,CAAIM,CAAJ,CAAxB,CAJhC,CAQA,KAAIO,KAAO,CAEN,KAAAC,EAAIlB,EAAA,CAAGM,CAAH,CAAOG,IAAP,CAAT,KAAuBD,EAAvB,CAAmC,CAAP,CAAAE,CAAA,CAAW,CAAX,CAAe,CAAC,CAAA,CAAGK,SAAUC,CAAAA,QAAd,EAAwBZ,GAAA,CAAIM,CAAJ;AAAW,CAAX,CAAxB,CAA3C,CAAmFQ,CAAnF,CAAuFV,EAAvF,CAA2FU,CAAA,EAA3F,CAIE,GAFAC,CAEI,CAFAjB,KAAA,CAAMgB,CAAN,CAEA,CAAA,CAAA,CAAC,CAAA,CAAGP,SAAUC,CAAAA,QAAd,EAAwBR,GAAxB,CAA6Be,CAA7B,CAAJ,CAAA,CAKAnB,EAAA,CAAGM,CAAH,CAAOG,IAAP,CAAA,CAAeS,CAEflB,GAAA,CAAG,EAAES,IAAL,CAAA,CAAaU,CAEbF,KAAA,CAAO,CAEP,MAXA,CAeEA,IAAJ,GAEER,IAAA,EAEA,CAAAT,EAAA,CAAG,EAAED,GAAL,CAAA,CAAYF,CAJd,CAnCgB,CA2ClB,MAAOE,IAzD2B,CAtBpC,KAAIY,UAAYrB,OAAA,CAAQ,qEAAR,CAAhB,CAEIuB,QAAUvB,OAAA,CAAQ,mEAAR,CAFd,CAIIyB,UAAYzB,OAAA,CAAQ,qEAAR,CAZ6G;\",\n\"sources\":[\"node_modules/mathjs/lib/cjs/function/algebra/sparse/csDfs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csDfs\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.csDfs = csDfs;\\n\\nvar _csMarked = require(\\\"./csMarked.js\\\");\\n\\nvar _csMark = require(\\\"./csMark.js\\\");\\n\\nvar _csUnflip = require(\\\"./csUnflip.js\\\");\\n\\n/**\\n * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\\n * at nodes in B (see csReach()).\\n *\\n * @param {Number}  j               The starting node for the DFS algorithm\\n * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\\n * @param {Number}  top             Start index in stack xi[top..n-1]\\n * @param {Number}  k               The kth column in B\\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\\n * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\\n *\\n * @return {Number}                 New value of top\\n *\\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\\n */\\nfunction csDfs(j, g, top, xi, pinv) {\\n  // g arrays\\n  var index = g._index;\\n  var ptr = g._ptr;\\n  var size = g._size; // columns\\n\\n  var n = size[1]; // vars\\n\\n  var i, p, p2; // initialize head\\n\\n  var head = 0; // initialize the recursion stack\\n\\n  xi[0] = j; // loop\\n\\n  while (head >= 0) {\\n    // get j from the top of the recursion stack\\n    j = xi[head]; // apply permutation vector\\n\\n    var jnew = pinv ? pinv[j] : j; // check node j is marked\\n\\n    if (!(0, _csMarked.csMarked)(ptr, j)) {\\n      // mark node j as visited\\n      (0, _csMark.csMark)(ptr, j); // update stack (last n entries in xi)\\n\\n      xi[n + head] = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew]);\\n    } // node j done if no unvisited neighbors\\n\\n\\n    var done = 1; // examine all neighbors of j, stack (last n entries in xi)\\n\\n    for (p = xi[n + head], p2 = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew + 1]); p < p2; p++) {\\n      // consider neighbor node i\\n      i = index[p]; // check we have visited node i, skip it\\n\\n      if ((0, _csMarked.csMarked)(ptr, i)) {\\n        continue;\\n      } // pause depth-first search of node j, update stack (last n entries in xi)\\n\\n\\n      xi[n + head] = p; // start dfs at node i\\n\\n      xi[++head] = i; // node j is not done\\n\\n      done = 0; // break, to start dfs(i)\\n\\n      break;\\n    } // check depth-first search at node j is done\\n\\n\\n    if (done) {\\n      // remove j from the recursion stack\\n      head--; // and place in the output stack\\n\\n      xi[--top] = j;\\n    }\\n  }\\n\\n  return top;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"csDfs\",\"j\",\"g\",\"top\",\"xi\",\"pinv\",\"index\",\"_index\",\"ptr\",\"_ptr\",\"n\",\"_size\",\"p2\",\"head\",\"jnew\",\"_csMarked\",\"csMarked\",\"_csMark\",\"csMark\",\"_csUnflip\",\"csUnflip\",\"done\",\"p\",\"i\"]\n}\n"]